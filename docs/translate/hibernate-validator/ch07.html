<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>Value extraction</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter-valueextraction">Value extraction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Value extraction is the process of extracting values from a container so that
they can be validated.</p>
</div>
<div class="paragraph">
<p>It is used when dealing with <a href="#container-element-constraints">container element
constraints</a> and <a href="#example-cascaded-validation-list">cascaded validation inside
containers</a>.</p>
</div>
<div class="sect2">
<h3 id="section-valueextraction-builtinvalueextractors">Built-in value extractors</h3>
<div class="paragraph">
<p>Hibernate Validator comes with built-in value extractors for the usual Java container
types so, except if you are using your own custom container types (or the ones
of external libraries such as <a href="https://github.com/google/guava">Guava</a>'s <code>Multimap</code>),
you should not have to add your own value extractors.</p>
</div>
<div class="paragraph">
<p>Built-in value extractors are present for all the following container types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Iterable</code>;</p>
</li>
<li>
<p><code>java.util.List</code>;</p>
</li>
<li>
<p><code>java.util.Map</code>: for keys and values;</p>
</li>
<li>
<p><code>java.util.Optional</code>, <code>java.util.OptionalInt</code>, <code>java.util.OptionalLong</code> and <code>java.util.OptionalDouble</code>;</p>
</li>
<li>
<p>{javafxDocsUrl}[JavaFX]'s <code>ObservableValue</code> (see <a href="#section-valueextraction-javafx">JavaFX value extractors</a>
for more details).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The complete list of built-in value extractors with all the details on how they
behave can be found in the
{bvSpecUrl}#valueextractordefinition-builtinvalueextractors[Jakarta Bean Validation specification].</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_a_valueextractor">Implementing a <code>ValueExtractor</code></h3>
<div class="paragraph">
<p>To extract values from a custom container, one needs to implement a <code>ValueExtractor</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Implementing a <code>ValueExtractor</code> is not enough, you also need to register it.
See <a href="#section-valueextraction-registeringvalueextractor">Registering a <code>ValueExtractor</code></a> for more details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ValueExtractor</code> is a very simple API as the only purpose of a value extractor is to provide
the extracted values to a <code>ValueReceiver</code>.</p>
</div>
<div class="paragraph">
<p>For instance, let&#8217;s consider the case of Guava&#8217;s <code>Optional</code>. It is an easy example
as we can shape its value extractor after the <code>java.util.Optional</code> one:</p>
</div>
<div id="example-valueextraction-guava-optional-valueextractor" class="exampleblock">
<div class="title">Example 1. A <code>ValueExtractor</code> for Guava&#8217;s <code>Optional</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/valueextractor/OptionalValueExtractor.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Some explanations are in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>@ExtractedValue</code> annotation marks the type argument under consideration: it
is going to be used to resolve the type of the validated value;</p>
</li>
<li>
<p>We use the <code>value()</code> method of the receiver as <code>Optional</code> is a pure wrapper type;</p>
</li>
<li>
<p>We don&#8217;t want to add a node to the property path of the constraint violation
as we want the violation to be reported as if it were directly on the property
so we pass a <code>null</code> node name to <code>value()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A more interesting example is the case of Guava&#8217;s <code>Multimap</code>: we would like to be
able to validate both the keys and the values of this container type.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first consider the case of the values. A value extractor extracting them
is required:</p>
</div>
<div id="example-valueextraction-guava-multimap-value-valueextractor" class="exampleblock">
<div class="title">Example 2. A <code>ValueExtractor</code> for <code>Multimap</code> values</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/valueextractor/MultimapValueValueExtractor.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It allows to validate constraints for the values of the <code>Multimap</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Constraints on the values of a <code>Multimap</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another value extractor is required to be able to put constraints on the keys
of a <code>Multimap</code>:</p>
</div>
<div id="example-valueextraction-guava-multimap-key-valueextractor" class="exampleblock">
<div class="title">Example 4. A <code>ValueExtractor</code> for <code>Multimap</code> keys</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/valueextractor/MultimapKeyValueExtractor.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once these two value extractors are registered, you can declare constraints on the
keys and values of a <code>Multimap</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Constraints on the keys and values of a <code>Multimap</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The differences between the two value extractors may be a bit subtle at a first
glance so let&#8217;s shed some light on them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>@ExtractedValue</code> annotation marks the targeted type argument (either
<code>K</code> or <code>V</code> in this case).</p>
</li>
<li>
<p>We use different node names (<code>&lt;multimap key&gt;</code> vs. <code>&lt;multimap value&gt;</code>).</p>
</li>
<li>
<p>In one case, we pass the values to the receiver (third argument of the
<code>keyedValue()</code> call), in the other, we pass the keys.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Depending on your container type, you should choose the <code>ValueReceiver</code>
method fitting the best:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>value()</code></dt>
<dd>
<p>for a simple wrapping container - it is used for <code>Optional</code>s</p>
</dd>
<dt class="hdlist1"><code>iterableValue()</code></dt>
<dd>
<p>for an iterable container - it is used for <code>Set</code>s</p>
</dd>
<dt class="hdlist1"><code>indexedValue()</code></dt>
<dd>
<p>for a container containing indexed values - it is used for <code>List</code>s</p>
</dd>
<dt class="hdlist1"><code>keyedValue()</code></dt>
<dd>
<p>for a container containing keyed values - it is used for <code>Map</code>s.
It is used for both the keys and the values. In the case of keys,
the key is also passed as the validated value.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For all these methods, you need to pass a node name: it is the name included in
the node added to the property path of the constraint violation. As mentioned
earlier, if the node name is <code>null</code>, no node is added to the property path:
it is be useful for pure wrapper types similar to <code>Optional</code>.</p>
</div>
<div class="paragraph">
<p>The choice of the method used is important as it adds contextual information to the
property path of the constraint violation e.g. the index or the key of the
validated value.</p>
</div>
</div>
<div class="sect2">
<h3 id="_non_generic_containers">Non generic containers</h3>
<div class="paragraph">
<p>You might have noticed that, until now, we only implemented value extractors
for generic containers.</p>
</div>
<div class="paragraph">
<p>Hibernate Validator also supports value extraction for non generic containers.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the case of <code>java.util.OptionalInt</code> which wraps a primitive <code>int</code>
into an <code>Optional</code>-like container.</p>
</div>
<div class="paragraph">
<p>A first attempt at a value extractor for <code>OptionalInt</code> would look like:</p>
</div>
<div id="example-valueextraction-optionalint-valueextractor" class="exampleblock">
<div class="title">Example 6. A <code>ValueExtractor</code> for <code>OptionalInt</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/nongeneric/OptionalIntValueExtractor.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There is an obvious thing missing for a non generic container: we don&#8217;t have
a type parameter. It has two consequences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we cannot determine the type of the validated value using the type argument;</p>
</li>
<li>
<p>we cannot add constraints on the type argument (e.g. <code>Container&lt;@NotNull String&gt;</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>First things first, we need a way to tell Hibernate Validator that the value
extracted from an <code>OptionalInt</code> is of type <code>Integer</code>.
As you can see in the above example, the <code>type</code> attribute of the <code>@ExtractedValue</code>
annotation allows to provide this information to the validation engine.</p>
</div>
<div class="paragraph">
<p>Then you have to tell the validation engine that the <code>Min</code> constraint you want to
add to the <code>OptionalInt</code> property relates to the wrapped value and not the wrapper.</p>
</div>
<div class="paragraph">
<p>Jakarta Bean Validation provides the <code>Unwrapping.Unwrap</code> payload for this situation:</p>
</div>
<div id="example-valueextraction-optionalint-unwrapping" class="exampleblock">
<div class="title">Example 7. Using <code>Unwrapping.Unwrap</code> payload</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If we take a step back, most - if not all - the constraints we would like to add to an
<code>OptionalInt</code> property would be applied to the wrapped value so having a way to make it
the default would be nice.</p>
</div>
<div class="paragraph">
<p>This is exactly what the <code>@UnwrapByDefault</code> annotation is for:</p>
</div>
<div id="example-valueextraction-optionalint-unwrapbydefault-valueextractor" class="exampleblock">
<div class="title">Example 8. A <code>ValueExtractor</code> for <code>OptionalInt</code> marked with <code>@UnwrapByDefault</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/nongeneric/UnwrapByDefaultOptionalIntValueExtractor.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When declaring this value extractor for <code>OptionalInt</code>, constraint annotations will
by default be applied to the wrapped value:</p>
</div>
<div id="example-valueextraction-optionalint-implicitunwrapping" class="exampleblock">
<div class="title">Example 9. Implicit unwrapping thanks to <code>@UnwrapByDefault</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that you can still declare an annotation for the wrapper itself by using
the <code>Unwrapping.Skip</code> payload:</p>
</div>
<div id="example-valueextraction-optionalint-avoid-implicitunwrapping" class="exampleblock">
<div class="title">Example 10. Avoid implicit unwrapping with <code>Unwrapping.Skip</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>@UnwrapByDefault</code> value extractor for <code>OptionalInt</code> is part of the built-in
value extractors: there is no need to add one.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-valueextraction-javafx">JavaFX value extractors</h3>
<div class="paragraph">
<p>Bean properties in JavaFX are typically not of simple data types like <code>String</code>
or <code>int</code>, but are wrapped in <code>Property</code> types which allows to make them observable,
use them for data binding etc.</p>
</div>
<div class="paragraph">
<p>Thus, value extraction is required to be able to apply constraints on the
wrapped values.</p>
</div>
<div class="paragraph">
<p>The JavaFX <code>ObservableValue</code> value extractor is marked with <code>@UnwrapByDefault</code>.
As such, the constraints hosted on the container target the wrapped value by
default.</p>
</div>
<div class="paragraph">
<p>Thus, you can constrain a <code>StringProperty</code> as below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Constraining a <code>StringProperty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or a <code>LongProperty</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Constraining a <code>LongProperty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The iterable property types, namely <code>ReadOnlyListProperty</code>,
<code>ListProperty</code> and their <code>Set</code> and <code>Map</code> counterparts are generic and, as such,
container element constraints can be used. Thus, they have specific value
extractors that are not marked with <code>@UnwrapByDefault</code>.</p>
</div>
<div class="paragraph">
<p>A <code>ReadOnlyListProperty</code> would naturally be constrained as a <code>List</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Constraining a <code>ReadOnlyListProperty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter07/Container.java[]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-valueextraction-registeringvalueextractor">Registering a <code>ValueExtractor</code></h3>
<div class="paragraph">
<p>Hibernate Validator does not detect automatically the value extractors in the
classpath so they have to be registered.</p>
</div>
<div class="paragraph">
<p>There are several ways to register value extractors (in increasing order of
priority):</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Provided by the validation engine itself</dt>
<dd>
<p>See <a href="#section-valueextraction-builtinvalueextractors">Built-in value extractors</a>.</p>
</dd>
<dt class="hdlist1">Via the Java service loader mechanism</dt>
<dd>
<p>The file <code>META-INF/services/jakarta.validation.valueextraction.ValueExtractor</code>
must be provided, with the fully-qualified names of one or more value
extractor implementations as its contents, each on a separate line.</p>
</dd>
<dt class="hdlist1">In the <code>META-INF/validation.xml</code> file</dt>
<dd>
<p>See <a href="#section-configuration-validation-xml">[section-configuration-validation-xml]</a> for more information about
how to register value extractors in the XML configuration.</p>
</dd>
<dt class="hdlist1">By calling <code>Configuration#addValueExtractor(ValueExtractor&lt;?&gt;)</code></dt>
<dd>
<p>See <a href="#section-bootstrapping-valueextractors">[section-bootstrapping-valueextractors]</a>
for more information.</p>
</dd>
<dt class="hdlist1">By invoking <code>ValidatorContext#addValueExtractor(ValueExtractor&lt;?&gt;)</code></dt>
<dd>
<p>It only declares the value extractor for this <code>Validator</code> instance.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A value extractor for a given type and type parameter specified at a higher
priority overrides any other extractors for the same type and type parameter
given at lower priorities.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolution_algorithms">Resolution algorithms</h3>
<div class="paragraph">
<p>In most cases, you should not have to worry about this but, if you are overriding
existing value extractors, you can find a detailed description of the value
extractors resolution algorithms in the Jakarta Bean Validation specification:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>for {bvSpecUrl}#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-constraints[container element constraints],</p>
</li>
<li>
<p>for {bvSpecUrl}#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-cascaded[cascaded validation],</p>
</li>
<li>
<p>and for {bvSpecUrl}#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-implicitunwrapping[implicit unwrapping].</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One important thing to have in mind is that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>for container element constraints, the declared type is used to resolve the value
extractors;</p>
</li>
<li>
<p>for cascaded validation, it is the runtime type.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-03-19 19:50:05 +0800
</div>
</div>
</body>
</html>