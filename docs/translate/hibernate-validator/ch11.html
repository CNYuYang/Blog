<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>Integrating with other frameworks</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="validator-integration">Integrating with other frameworks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate Validator is intended to be used to implement multi-layered data validation, where
constraints are expressed in a single place (the annotated domain model) and checked in various
different layers of the application. For this reason there are multiple integration points with
other technologies.</p>
</div>
<div class="sect2">
<h3 id="validator-checkconstraints-orm">ORM integration</h3>
<div class="paragraph">
<p>Hibernate Validator integrates with both Hibernate ORM and all pure Java Persistence providers.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>When lazy loaded associations are supposed to be validated it is recommended to place the constraint
on the getter of the association. Hibernate ORM replaces lazy loaded associations with proxy instances
which get initialized/loaded when requested via the getter. If, in such a case, the constraint is
placed on field level, the actual proxy instance is used which will lead to validation errors.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="validator-checkconstraints-db">Database schema-level validation</h4>
<div class="paragraph">
<p>Out of the box, Hibernate ORM will translate the constraints you have defined for
your entities into mapping metadata. For example, if a property of your entity is annotated
<code>@NotNull</code>, its columns will be declared as <code>not null</code> in the DDL schema generated by Hibernate ORM.</p>
</div>
<div class="paragraph">
<p>If, for some reason, the feature needs to be disabled, set <code>hibernate.validator.apply_to_ddl</code> to
<code>false</code>. See also <a href="#validator-defineconstraints-spec">[validator-defineconstraints-spec]</a> and <a href="#validator-defineconstraints-hv-constraints">[validator-defineconstraints-hv-constraints]</a>.</p>
</div>
<div class="paragraph">
<p>You can also limit the DDL constraint generation to a subset of the defined constraints by setting
the property <code>org.hibernate.validator.group.ddl</code>. The property specifies the comma-separated, fully
specified class names of the groups a constraint has to be part of in order to be considered for DDL
schema generation.</p>
</div>
</div>
<div class="sect3">
<h4 id="validator-checkconstraints-orm-hibernateevent">Hibernate ORM event-based validation</h4>
<div class="paragraph">
<p>Hibernate Validator has a built-in Hibernate event listener -
<a href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java"><code>org.hibernate.cfg.beanvalidation.BeanValidationEventListener</code></a> -
which is part of Hibernate ORM. Whenever a <code>PreInsertEvent</code>,
<code>PreUpdateEvent</code> or <code>PreDeleteEvent</code> occurs, the listener will verify all constraints of the entity
instance and throw an exception if any constraint is violated. Per default, objects will be checked
before any inserts or updates are made by Hibernate ORM. Pre deletion events will per default not
trigger a validation. You can configure the groups to be validated per event type using the
properties <code>jakarta.persistence.validation.group.pre-persist</code>,
<code>jakarta.persistence.validation.group.pre-update</code> and <code>jakarta.persistence.validation.group.pre-remove</code>.
The values of these properties are the comma-separated fully specified class names of the groups
to validate. <a href="#example-beanvalidationeventlistener-config">Manual configuration of <code>BeanValidationEvenListener</code></a> shows the default values for these
properties. In this case they could also be omitted.</p>
</div>
<div class="paragraph">
<p>On constraint violation, the event will raise a runtime <code>ConstraintViolationException</code> which contains
a set of <code>ConstraintViolation</code> instances describing each failure.</p>
</div>
<div class="paragraph">
<p>If Hibernate Validator is present in the classpath, Hibernate ORM will use it transparently.
To avoid validation even though Hibernate Validator is in the classpath, set
<code>jakarta.persistence.validation.mode</code> to none.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>If the beans are not annotated with validation annotations, there is no runtime performance cost.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In case you need to manually set the event listeners for Hibernate ORM, use the following
configuration in <em>hibernate.cfg.xml</em>:</p>
</div>
<div id="example-beanvalidationeventlistener-config" class="exampleblock">
<div class="title">Example 1. Manual configuration of <code>BeanValidationEvenListener</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-XML" data-lang="XML">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;property name="jakarta.persistence.validation.group.pre-persist"&gt;
            jakarta.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="jakarta.persistence.validation.group.pre-update"&gt;
            jakarta.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="jakarta.persistence.validation.group.pre-remove"&gt;&lt;/property&gt;
        ...
        &lt;event type="pre-update"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-insert"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-delete"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jpa">JPA</h4>
<div class="paragraph">
<p>If you are using JPA 2 and Hibernate Validator is in the classpath, the JPA2 specification requires
that Jakarta Bean Validation gets enabled. The properties <code>jakarta.persistence.validation.group.pre-persist</code>,
<code>jakarta.persistence.validation.group.pre-update</code> and <code>jakarta.persistence.validation.group.pre-remove</code> as
described in <a href="#validator-checkconstraints-orm-hibernateevent">Hibernate ORM event-based validation</a> can in this case be configured in
<em>persistence.xml</em>. <em>persistence.xml</em> also defines a node validation-mode which can be set to <code>AUTO</code>,
<code>CALLBACK</code> or <code>NONE</code>. The default is <code>AUTO</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-presentation-layer">JSF &amp; Seam</h3>
<div class="paragraph">
<p>When working with JSF2 or JBoss Seam and Hibernate Validator (Jakarta Bean Validation) is present in the
runtime environment, validation is triggered for every field in the application. <a href="#example-jsf2">Usage of Jakarta Bean Validation within JSF2</a>
shows an example of the <code>f:validateBean</code> tag in a JSF page. The <code>validationGroups</code> attribute is optional
and can be used to specify a comma separated list of validation groups. The default is
<code>jakarta.validation.groups.Default</code>. For more information refer to the Seam documentation or the JSF 2
specification.</p>
</div>
<div id="example-jsf2" class="exampleblock">
<div class="title">Example 2. Usage of Jakarta Bean Validation within JSF2</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-XML" data-lang="XML">&lt;h:form&gt;

  &lt;f:validateBean validationGroups="jakarta.validation.groups.Default"&gt;

    &lt;h:inputText value=#{model.property}/&gt;
    &lt;h:selectOneRadio value=#{model.radioProperty}&gt; ... &lt;/h:selectOneRadio&gt;
    &lt;!-- other input components here --&gt;

  &lt;/f:validateBean&gt;

&lt;/h:form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The integration between JSF 2 and Jakarta Bean Validation is described in the "Jakarta Bean Validation Integration"
chapter of <a href="http://jcp.org/en/jsr/detail?id=314">JSR-314</a>. It is interesting to know that JSF
2 implements a custom <code>MessageInterpolator</code> to ensure proper localization. To encourage the use
of the Jakarta Bean Validation message facility, JSF 2 will per default only display the generated Bean
Validation message. This can, however, be configured via the application resource bundle by
providing the following configuration (<code>{0}</code> is replaced with the Jakarta Bean Validation message and <code>{1}</code> is
replaced with the JSF component label):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>jakarta.faces.validator.BeanValidator.MESSAGE={1}: {0}</pre>
</div>
</div>
<div class="paragraph">
<p>The default is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>jakarta.faces.validator.BeanValidator.MESSAGE={0}</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-integration-with-cdi">CDI</h3>
<div class="paragraph">
<p>As of version 1.1, Bean Validation (and therefore Jakarta Bean Validation) is integrated with CDI
(Contexts and Dependency Injection for Jakarta EE).</p>
</div>
<div class="paragraph">
<p>This integration provides CDI managed beans for <code>Validator</code> and <code>ValidatorFactory</code> and enables
dependency injection in constraint validators as well as custom message interpolators, traversable
resolvers, constraint validator factories, parameter name providers, clock providers and value
extractors.</p>
</div>
<div class="paragraph">
<p>Furthermore, parameter and return value constraints on the methods and constructors of CDI managed
beans will automatically be validated upon invocation.</p>
</div>
<div class="paragraph">
<p>When your application runs on a Java EE container, this integration is enabled by default. When
working with CDI in a Servlet container or in a pure Java SE environment, you can use the CDI
portable extension provided by Hibernate Validator. To do so, add the portable extension to your
class path as described in <a href="#section-getting-started-cdi">[section-getting-started-cdi]</a>.</p>
</div>
<div class="sect3">
<h4 id="_dependency_injection">Dependency injection</h4>
<div class="paragraph">
<p>CDI&#8217;s dependency injection mechanism makes it very easy to retrieve <code>ValidatorFactory</code> and <code>Validator</code>
instances and use them in your managed beans. Just annotate instance fields of your bean with
<code>@jakarta.inject.Inject</code> as shown in <a href="#example-dependency-injection">Retrieving validator factory and validator via <code>@Inject</code></a>.</p>
</div>
<div id="example-dependency-injection" class="exampleblock">
<div class="title">Example 3. Retrieving validator factory and validator via <code>@Inject</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/validator/RentalStation.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The injected beans are the default validator factory and validator instances. In order to configure
them - e.g. to use a custom message interpolator - you can use the Jakarta Bean Validation XML descriptors
as discussed in <a href="#chapter-xml-configuration">[chapter-xml-configuration]</a>.</p>
</div>
<div class="paragraph">
<p>If you are working with several Jakarta Bean Validation providers, you can make sure that factory and
validator from Hibernate Validator are injected by annotating the injection points with the
<code>@HibernateValidator</code> qualifier which is demonstrated in <a href="#example-dependency-injection-using-hv">Using the <code>@HibernateValidator</code> qualifier annotation</a>.</p>
</div>
<div id="example-dependency-injection-using-hv" class="exampleblock">
<div class="title">Example 4. Using the <code>@HibernateValidator</code> qualifier annotation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/validator/qualifier/RentalStation.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The fully-qualified name of the qualifier annotation is
<code>org.hibernate.validator.cdi.HibernateValidator</code>. Be sure to not import
<code>org.hibernate.validator.HibernateValidator</code> instead which is the <code>ValidationProvider</code> implementation
used for selecting Hibernate Validator when working with the bootstrapping API (see
<a href="#section-retrieving-validator-factory-validator">[section-retrieving-validator-factory-validator]</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Via <code>@Inject</code> you also can inject dependencies into constraint validators and other Jakarta Bean Validation
objects such as <code>MessageInterpolator</code> implementations etc.</p>
</div>
<div class="paragraph">
<p><a href="#example-constraint-validator-injected-bean">Constraint validator with injected bean</a>
demonstrates how an injected CDI bean is used in a <code>ConstraintValidator</code> implementation to determine
whether the given constraint is valid or not. As the example shows, you also can work with the
<code>@PostConstruct</code> and <code>@PreDestroy</code> callbacks to implement any required construction and destruction
logic.</p>
</div>
<div id="example-constraint-validator-injected-bean" class="exampleblock">
<div class="title">Example 5. Constraint validator with injected bean</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/injection/ValidLicensePlateValidator.java[]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_method_validation">Method validation</h4>
<div class="paragraph">
<p>The method interception facilities of CDI allow for a very tight integration with Jakarta Bean Validation&#8217;s
method validation functionality. Just put constraint annotations to the parameters and return values
of the executables of your CDI beans and they will be validated automatically before (parameter
constraints) and after (return value constraints) a method or constructor is invoked.</p>
</div>
<div class="paragraph">
<p>Note that no explicit interceptor binding is required, instead the required method validation
interceptor will automatically be registered for all managed beans with constrained methods and
constructors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The interceptor <code>org.hibernate.validator.cdi.internal.interceptor.ValidationInterceptor</code> is
registered by <code>org.hibernate.validator.cdi.internal.ValidationExtension</code>. This happens implicitly
within a Java EE runtime environment or explicitly by adding the <em>hibernate-validator-cdi</em>
artifact - see <a href="#section-getting-started-cdi">[section-getting-started-cdi]</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can see an example in <a href="#example-cdi-method-validation">CDI managed beans with method-level constraints</a>.</p>
</div>
<div id="example-cdi-method-validation" class="exampleblock">
<div class="title">Example 6. CDI managed beans with method-level constraints</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/methodvalidation/RentalStation.java[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/methodvalidation/RentCarRequest.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here the <code>RentalStation</code> bean hosts several method constraints. When invoking one of the <code>RentalStation</code>
methods from another bean such as <code>RentCarRequest</code>, the constraints of the invoked method are
automatically validated. If any illegal parameter values are passed as in the example, a
<code>ConstraintViolationException</code> will be thrown by the method interceptor, providing detailed
information on the violated constraints. The same is the case if the method&#8217;s return value violates
any return value constraints.</p>
</div>
<div class="paragraph">
<p>Similarly, constructor constraints are validated automatically upon invocation. In the example the
<code>RentalStation</code> object returned by the constructor will be validated since the constructor return
value is marked with <code>@Valid</code>.</p>
</div>
<div class="sect4">
<h5 id="_validated_executable_types">Validated executable types</h5>
<div class="paragraph">
<p>Jakarta Bean Validation allows for a fine-grained control of the executable types which are automatically
validated. By default, constraints on constructors and non-getter methods are validated. Therefore
the <code>@NotNull</code> constraint on the method <code>RentalStation#getAvailableCars()</code> in
<a href="#example-cdi-method-validation">CDI managed beans with method-level constraints</a> does not get validated when the method is invoked.</p>
</div>
<div class="paragraph">
<p>You have the following options to configure which types of executables are validated upon
invocation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure the executable types globally via the XML descriptor <em>META-INF/validation.xml</em>;
see <a href="#section-configuration-validation-xml">[section-configuration-validation-xml]</a> for an example</p>
</li>
<li>
<p>Use the <code>@ValidateOnExecution</code> annotation on the executable or type level</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If several sources of configuration are specified for a given executable, <code>@ValidateOnExecution</code> on
the executable level takes precedence over <code>@ValidateOnExecution</code> on the type level and
<code>@ValidateOnExecution</code> generally takes precedence over the globally configured types in <em>META-
INF/validation.xml</em>.</p>
</div>
<div class="paragraph">
<p><a href="#example-using-validateonexecution">Using <code>@ValidateOnExecution</code></a> shows how to use the <code>@ValidateOnExecution</code> annotation:</p>
</div>
<div id="example-using-validateonexecution" class="exampleblock">
<div class="title">Example 7. Using <code>@ValidateOnExecution</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/methodvalidation/configuration/RentalStation.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here the method <code>rentCar()</code> won&#8217;t be validated upon invocation because it is annotated with
<code>@ValidateOnExecution(type = ExecutableType.NONE)</code>. In contrast, the constructor and the
method <code>getAvailableCars()</code> will be validated due to <code>@ValidateOnExecution(type =
ExecutableType.ALL)</code> being given on the type level. <code>ExecutableType.ALL</code> is a more compact form for
explicitly specifying all the types <code>CONSTRUCTORS</code>, <code>GETTER_METHODS</code> and <code>NON_GETTER_METHODS</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Executable validation can be turned off globally by specifying
<code>&lt;executable-validation enabled="false"/&gt;</code> in <em>META-INF/validation.xml</em>. In this case, all the
<code>@ValidateOnExecution</code> annotations are ignored.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that when a method overrides or implements a super-type method, the configuration will be taken
from that overridden or implemented method (as given via <code>@ValidateOnExecution</code> on the method itself
or on the super-type). This protects a client of the super-type method from an unexpected alteration
of the configuration, e.g. disabling validation of an overridden executable in a sub-type.</p>
</div>
<div class="paragraph">
<p>In case a CDI managed bean overrides or implements a super-type method and this super-type method
hosts any constraints, it can happen that the validation interceptor is not properly registered with
the bean, resulting in the bean&#8217;s methods not being validated upon invocation. In this case you can
specify the executable type <code>IMPLICIT</code> on the sub-class as shown in
<a href="#example-using-executabletype-implicit">Using <code>ExecutableType.IMPLICIT</code></a>, which makes sure that all required metadata is discovered
and the validation interceptor kicks in when the methods on <code>ExpressRentalStation</code> are invoked.</p>
</div>
<div id="example-using-executabletype-implicit" class="exampleblock">
<div class="title">Example 8. Using <code>ExecutableType.IMPLICIT</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/methodvalidation/implicit/RentalStation.java[]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/cdi/methodvalidation/implicit/ExpressRentalStation.java[]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java_ee">Java EE</h3>
<div class="paragraph">
<p>When your application runs on a Java EE application server such as <a href="http://wildfly.org/">WildFly</a>,
you also can obtain <code>Validator</code> and <code>ValidatorFactory</code> instances via <code>@Resource</code> injection in
managed objects such as EJBs etc., as shown in <a href="#example-validator-resource-injection">Retrieving <code>Validator</code> and <code>ValidatorFactory</code> via <code>@Resource</code> injection</a>.</p>
</div>
<div id="example-validator-resource-injection" class="exampleblock">
<div class="title">Example 9. Retrieving <code>Validator</code> and <code>ValidatorFactory</code> via <code>@Resource</code> injection</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-JAVA" data-lang="JAVA">link:{sourcedir}/org/hibernate/validator/referenceguide/chapter11/javaee/RentalStationBean.java[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively you can obtain a validator and a validator factory from JNDI under the names
"<em>java:comp/Validator</em>" and "<em>java:comp/ValidatorFactory</em>", respectively.</p>
</div>
<div class="paragraph">
<p>Similar to CDI-based injection via <code>@Inject</code>, these objects represent default validator and validator
factory and thus can be configured using the XML descriptor <em>META-INF/validation.xml</em> (see
<a href="#chapter-xml-configuration">[chapter-xml-configuration]</a>).</p>
</div>
<div class="paragraph">
<p>When your application is CDI-enabled, the injected objects are CDI-aware as well and e.g. support
dependency injection in constraint validators.</p>
</div>
</div>
<div class="sect2">
<h3 id="_javafx">JavaFX</h3>
<div class="paragraph">
<p>Hibernate Validator also provides support for the unwrapping of JavaFX properties. If JavaFX is present
on the classpath, <code>ValueExtractor</code>s for JavaFX properties are automatically registered.
See <a href="#section-valueextraction-javafx">[section-valueextraction-javafx]</a> for examples and further discussion.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-03-19 19:50:05 +0800
</div>
</div>
</body>
</html>