<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Hardy Ferentschik, Gunnar Morling, Guillaume Smet, 余阳 @CNYuYang (中文译)">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<title>Hibernate Validator 7.0.1 - Jakarta Bean Validation 参考实现: 参考指南</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./assets/prettify.min.css">
<style>
    body:before {
        content: url(./hibernate_logo_smaller.png);
        box-shadow: 0 2px 2px #ddd;
        display: block;
        padding: 20px 20px 10px 15px;
    }

    #tocbot a.toc-link.node-name--H1 {
        font-style: italic
    }

    @media screen {
        #tocbot>ul.toc-list {
            margin-bottom: 0.5em;
            margin-left: 0.125em
        }
        #tocbot ul.sectlevel0,
        #tocbot a.toc-link.node-name--H1+ul {
            padding-left: 0
        }
        #tocbot a.toc-link {
            height: 100%
        }
        .is-collapsible {
            max-height: 3000px;
            overflow: hidden;
        }
        .is-collapsed {
            max-height: 0
        }
        .is-active-link {
            font-weight: 700
        }
    }

    @media print {
        #tocbot a.toc-link.node-name--H4 {
            display: none
        }
    }
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Hibernate Validator 7.0.1 - Jakarta Bean Validation 参考实现: 参考指南</h1>
<div class="details">
<span id="author" class="author">Hardy Ferentschik</span><br>
<span id="author2" class="author">Gunnar Morling</span><br>
<span id="author3" class="author">Guillaume Smet</span><br>
<span id="author4" class="author">余阳 @CNYuYang (中文译)</span><br>
<span id="revdate">2021-04-04</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">前言</a></li>
<li><a href="#validator-gettingstarted">1. 快速开始</a>
<ul class="sectlevel2">
<li><a href="#validator-gettingstarted-createproject">1.1. 创建项目</a>
<ul class="sectlevel3">
<li><a href="#validator-gettingstarted-uel">1.1.1. 统一的EL表达式</a></li>
<li><a href="#section-getting-started-cdi">1.1.2. CDI</a></li>
<li><a href="#section-getting-started-security-manager">1.1.3. 与安全管理器一起运行</a></li>
<li><a href="#_在_wildfly_中更新_hibernate_校验器">1.1.4. 在 WildFly 中更新 Hibernate 校验器</a></li>
<li><a href="#validator-gettingstarted-java9">1.1.5. 在 Java 9上运行</a></li>
</ul>
</li>
<li><a href="#validator-gettingstarted-createmodel">1.2. 使用约束</a></li>
<li><a href="#_校验约束">1.3. 校验约束</a></li>
<li><a href="#validator-gettingstarted-whatsnext">1.4. 接下来的是？</a></li>
</ul>
</li>
<li><a href="#chapter-bean-constraints">2. 声明和校验 bean 约束</a>
<ul class="sectlevel2">
<li><a href="#section-declaring-bean-constraints">2.1. 声明 bean 约束</a>
<ul class="sectlevel3">
<li><a href="#_字段级约束">2.1.1. 字段级约束</a></li>
<li><a href="#_属性级约束">2.1.2. 属性级约束</a></li>
<li><a href="#container-element-constraints">2.1.3. 集合元素约束</a></li>
<li><a href="#validator-usingvalidator-classlevel">2.1.4. 类层面的约束</a></li>
<li><a href="#section-constraint-inheritance">2.1.5. 约束继承</a></li>
<li><a href="#section-object-graph-validation">2.1.6. 对象图</a></li>
</ul>
</li>
<li><a href="#section-validating-bean-constraints">2.2. 校验 bean 约束</a>
<ul class="sectlevel3">
<li><a href="#section-obtaining-validator">2.2.1. 获取 <code>Validator</code> 实例</a></li>
<li><a href="#_validator_方法">2.2.2. Validator 方法</a></li>
<li><a href="#section-constraint-violation-methods">2.2.3. <code>ConstraintViolation</code></a></li>
</ul>
</li>
<li><a href="#section-builtin-constraints">2.3. 内置约束</a>
<ul class="sectlevel3">
<li><a href="#validator-defineconstraints-spec">2.3.1. Jakarta Bean Validation 约束</a></li>
<li><a href="#validator-defineconstraints-hv-constraints">2.3.2. 附加约束</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-method-constraints">3. 声明和校验 method 约束</a>
<ul class="sectlevel2">
<li><a href="#section-declaring-method-constraints">3.1. 声明 method 约束</a>
<ul class="sectlevel3">
<li><a href="#_参数约束">3.1.1. 参数约束</a></li>
<li><a href="#_返回值约束">3.1.2. 返回值约束</a></li>
<li><a href="#_级联校验">3.1.3. 级联校验</a></li>
<li><a href="#section-method-constraints-inheritance-hierarchies">3.1.4. 继承层次中的方法约束</a></li>
</ul>
</li>
<li><a href="#section-validating-executable-constraints">3.2. 校验 method 约束</a>
<ul class="sectlevel3">
<li><a href="#section-obtaining-executable-validator">3.2.1. 获取 <code>ExecutableValidator</code> 实例</a></li>
<li><a href="#section-executable-validator-methods">3.2.2. <code>ExecutableValidator</code> 的方法</a></li>
<li><a href="#_校验方法的结果_constraintviolation">3.2.3. 校验方法的结果 <code>ConstraintViolation</code></a></li>
</ul>
</li>
<li><a href="#section-builtin-method-constraints">3.3. 内置 method 约束</a></li>
</ul>
</li>
<li><a href="#chapter-message-interpolation">4. 添加约束错误消息</a>
<ul class="sectlevel2">
<li><a href="#section-message-interpolation">4.1. 默认消息插值</a>
<ul class="sectlevel3">
<li><a href="#section-special-characters">4.1.1. 特殊字符</a></li>
<li><a href="#section-interpolation-with-message-expressions">4.1.2. 带有消息表达式的插值</a></li>
<li><a href="#_示例">4.1.3. 示例</a></li>
</ul>
</li>
<li><a href="#section-custom-message-interpolation">4.2. 自定义消息插值</a>
<ul class="sectlevel3">
<li><a href="#section-resource-bundle-locator">4.2.1. <code>ResourceBundleLocator</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-groups">5. 分组约束</a>
<ul class="sectlevel2">
<li><a href="#_请求分组">5.1. 请求分组</a></li>
<li><a href="#section-group-inheritance">5.2. 分组继承</a></li>
<li><a href="#section-defining-group-sequences">5.3. 定义分组序列</a></li>
<li><a href="#section-default-group-class">5.4. 重新定义默认组序列</a>
<ul class="sectlevel3">
<li><a href="#_groupsequence">5.4.1. <code>@GroupSequence</code></a></li>
<li><a href="#_groupsequenceprovider">5.4.2. <code>@GroupSequenceProvider</code></a></li>
</ul>
</li>
<li><a href="#section-group-conversion">5.5. 分组转化</a></li>
</ul>
</li>
<li><a href="#validator-customconstraints">6. 自定义约束</a>
<ul class="sectlevel2">
<li><a href="#validator-customconstraints-simple">6.1. 创建一个简单的约束</a>
<ul class="sectlevel3">
<li><a href="#validator-customconstraints-constraintannotation">6.1.1. 约束注解</a></li>
<li><a href="#section-constraint-validator">6.1.2. 约束校验器</a></li>
<li><a href="#validator-customconstraints-errormessage">6.1.3. 错误信息</a></li>
<li><a href="#validator-customconstraints-using">6.1.4. 使用约束</a></li>
</ul>
</li>
<li><a href="#section-class-level-constraints">6.2. 类级别的约束</a>
<ul class="sectlevel3">
<li><a href="#section-custom-property-paths">6.2.1. 自定义属性路径</a></li>
</ul>
</li>
<li><a href="#section-cross-parameter-constraints">6.3. 交叉参数约束</a></li>
<li><a href="#section-constraint-composition">6.4. 约束组合</a></li>
</ul>
</li>
<li><a href="#chapter-valueextraction">7. 值提取</a>
<ul class="sectlevel2">
<li><a href="#section-valueextraction-builtinvalueextractors">7.1. 内置值提取器</a></li>
<li><a href="#_实现一个_valueextractor">7.2. 实现一个 <code>ValueExtractor</code></a></li>
<li><a href="#_非通用容器">7.3. 非通用容器</a></li>
<li><a href="#section-valueextraction-javafx">7.4. JavaFX 值提取器</a></li>
<li><a href="#section-valueextraction-registeringvalueextractor">7.5. 注册一个 <code>ValueExtractor</code></a></li>
<li><a href="#_分辨率算法">7.6. 分辨率算法</a></li>
</ul>
</li>
<li><a href="#chapter-xml-configuration">8. 通过 XML 配置</a>
<ul class="sectlevel2">
<li><a href="#section-configuration-validation-xml">8.1. 配置 validator factory 通过 <em>validation.xml</em></a></li>
<li><a href="#section-mapping-xml-constraints">8.2. 通过 <code>constraint-mappings</code> 映射约束</a></li>
</ul>
</li>
<li><a href="#chapter-bootstrapping">9. Bootstrapping</a>
<ul class="sectlevel2">
<li><a href="#section-retrieving-validator-factory-validator">9.1. 获取 <code>ValidatorFactory</code> 和 <code>Validator</code></a>
<ul class="sectlevel3">
<li><a href="#section-validation-provider-resolver">9.1.1. <code>ValidationProviderResolver</code></a></li>
</ul>
</li>
<li><a href="#section-configuring-validator-factory">9.2. 配置 <code>ValidatorFactory</code></a>
<ul class="sectlevel3">
<li><a href="#section-validator-factory-message-interpolator">9.2.1. <code>MessageInterpolator</code></a></li>
<li><a href="#section-validator-factory-traversable-resolver">9.2.2. <code>TraversableResolver</code></a></li>
<li><a href="#_constraintvalidatorfactory">9.2.3. <code>ConstraintValidatorFactory</code></a></li>
<li><a href="#section-parameter-name-provider">9.2.4. <code>ParameterNameProvider</code></a></li>
<li><a href="#section-clock-provider">9.2.5. <code>ClockProvider</code> 和时间校验容忍度</a></li>
<li><a href="#section-bootstrapping-valueextractors">9.2.6. 注册 <code>ValueExtractor</code>s</a></li>
<li><a href="#_添加映射流">9.2.7. 添加映射流</a></li>
<li><a href="#section-provider-specific-settings">9.2.8. Provider-specific 配置</a></li>
<li><a href="#section-script-evaluator-factory">9.2.9. 配置 <code>ScriptEvaluatorFactory</code></a></li>
</ul>
</li>
<li><a href="#section-configuring-validator">9.3. 配置Validator</a></li>
</ul>
</li>
<li><a href="#validator-metadata-api">10. 使用约束元数据</a>
<ul class="sectlevel2">
<li><a href="#_beandescriptor">10.1. <code>BeanDescriptor</code></a></li>
<li><a href="#section-property-descriptor">10.2. <code>PropertyDescriptor</code></a></li>
<li><a href="#_methoddescriptor_和_constructordescriptor">10.3. <code>MethodDescriptor</code> 和 <code>ConstructorDescriptor</code></a></li>
<li><a href="#validator-metadata-api-elementdescriptor">10.4. <code>ElementDescriptor</code></a></li>
<li><a href="#_containerdescriptor_和_containerelementtypedescriptor">10.5. <code>ContainerDescriptor</code> 和 <code>ContainerElementTypeDescriptor</code></a></li>
<li><a href="#section-group-conversion-descriptor">10.6. <code>GroupConversionDescriptor</code></a></li>
<li><a href="#section-constraint-descriptor">10.7. <code>ConstraintDescriptor</code></a></li>
</ul>
</li>
<li><a href="#validator-integration">11. 与其他框架集成</a>
<ul class="sectlevel2">
<li><a href="#validator-checkconstraints-orm">11.1. ORM 集成</a>
<ul class="sectlevel3">
<li><a href="#validator-checkconstraints-db">11.1.1. 数据库schema级别校验</a></li>
<li><a href="#validator-checkconstraints-orm-hibernateevent">11.1.2. Hibernate ORM 事件校验</a></li>
<li><a href="#_jpa">11.1.3. JPA</a></li>
</ul>
</li>
<li><a href="#section-presentation-layer">11.2. JSF &amp; Seam</a></li>
<li><a href="#section-integration-with-cdi">11.3. CDI</a>
<ul class="sectlevel3">
<li><a href="#_依赖注入">11.3.1. 依赖注入</a></li>
<li><a href="#_方法校验">11.3.2. 方法校验</a></li>
</ul>
</li>
<li><a href="#_java_ee">11.4. Java EE</a></li>
<li><a href="#_javafx">11.5. JavaFX</a></li>
</ul>
</li>
<li><a href="#validator-specifics">12. Hibernate Validator 特性</a>
<ul class="sectlevel2">
<li><a href="#_公共_api">12.1. 公共 API</a></li>
<li><a href="#section-fail-fast">12.2. 快速失败模式</a></li>
<li><a href="#section-method-validation-prerequisite-relaxation">12.3. 放宽类层次中方法校验的要求</a></li>
<li><a href="#section-programmatic-api">12.4. 可编程约束的定义和声明</a></li>
<li><a href="#section-programmatic-api-contributor">12.5. 将程序化的约束声明应用到默认的验证器工厂</a></li>
<li><a href="#section-advanced-constraint-composition">12.6. 高级约束组合特性</a>
<ul class="sectlevel3">
<li><a href="#_纯组合约束的验证目标规范">12.6.1. 纯组合约束的验证目标规范</a></li>
<li><a href="#section-boolean-constraint-composition">12.6.2. 布尔约束组合</a></li>
</ul>
</li>
<li><a href="#section-extensions-path-api">12.7. 拓展 Path API</a></li>
<li><a href="#section-dynamic-payload">12.8. 动态有效载荷作为 <code>ConstraintViolation</code></a></li>
<li><a href="#el-features">12.9. 启用EL表达式语言功能</a></li>
<li><a href="#non-el-message-interpolator">12.10. <code>ParameterMessageInterpolator</code></a></li>
<li><a href="#_resourcebundlelocator">12.11. <code>ResourceBundleLocator</code></a></li>
<li><a href="#section-locale-resolver">12.12. 自定义语言环境解析</a></li>
<li><a href="#_自定义上下文">12.13. 自定义上下文</a>
<ul class="sectlevel3">
<li><a href="#section-hibernateconstraintvalidatorcontext">12.13.1. <code>HibernateConstraintValidatorContext</code></a></li>
<li><a href="#_hibernatemessageinterpolatorcontext">12.13.2. <code>HibernateMessageInterpolatorContext</code></a></li>
</ul>
</li>
<li><a href="#section-paranamer-parameternameprovider">12.14. 基于 Paranamer 的 <code>ParameterNameProvider</code></a></li>
<li><a href="#section-constraint-definition-contribution">12.15. 提供约束定义</a>
<ul class="sectlevel3">
<li><a href="#_通过_serviceloader_实现约束的定义">12.15.1. 通过 <code>ServiceLoader</code> 实现约束的定义</a></li>
<li><a href="#section-programmatic-constraint-definition">12.15.2. 以编程方式添加约束定义</a></li>
</ul>
</li>
<li><a href="#section-constraint-customizing-class-loading">12.16. 自定义类加载</a></li>
<li><a href="#section-getter-property-selection-strategy">12.17. 自定义 getter 属性选择策略</a></li>
<li><a href="#section-property-node-name-provider">12.18. 自定义违反约束的属性名解析</a></li>
</ul>
</li>
<li><a href="#validator-annotation-processor">13. 注释处理器</a>
<ul class="sectlevel2">
<li><a href="#validator-annotationprocessor-prerequisites">13.1. 先决条件</a></li>
<li><a href="#validator-annotationprocessor-features">13.2. 功能</a></li>
<li><a href="#validator-annotationprocessor-options">13.3. 选项</a></li>
<li><a href="#validator-annotationprocessor-usage">13.4. 使用注释处理器</a>
<ul class="sectlevel3">
<li><a href="#validator-annotationprocessor-commandline">13.4.1. 命令行构建</a></li>
<li><a href="#validator-annotationprocessor-ide">13.4.2. IDE builds</a></li>
</ul>
</li>
<li><a href="#validator-annotationprocessor-known-issues">13.5. Known issues</a></li>
</ul>
</li>
<li><a href="#validator-further-reading">14. 进一步阅读</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数据校验是一项常见任务，从表示层到持久层的所有应用都会用到。通常，在每个层中都各自实现其验证逻辑，这既耗时又容易出错。为了避免重复进行校验操作，开发人员通常将校验逻辑直接捆绑到域模型中，从而使域类与校验相关代码杂乱无章，而校验相关代码实际上是有关类本身的元数据。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="application-layers.png" alt="application layers">
</div>
</div>
<div class="paragraph">
<p>Jakarta Bean Validation 2.0-定义了用于实体和方法校验的元数据模型和API。默认的元数据源是注解，也能够通过使用XML方式来覆盖或扩展元数据。该API不受特定应用程序层或编程模型的束缚。它不与Web层或持久层绑定，并且可被用于服务器端应用程序编程以及客户端Swing应用程序开发。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="application-layers2.png" alt="application layers2">
</div>
</div>
<div class="paragraph">
<p>Hibernate Validator是Jakarta Bean Validation的参考实现。该实现本身以及Jakarta Bean验证API和TCK均在 <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache Software License 2.0</a> 下提供和分发。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 6 和 Jakarta Bean Validation 2.0 均需要Java 8及以上版本。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-gettingstarted"><a class="anchor" href="#validator-gettingstarted"></a>1. 快速开始</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将向您展示如何开始使用Hibernate Validator，它是Jakarta Bean Validation的参考实现(reference implementation RI)。您需要准备：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDK 8</p>
</li>
<li>
<p><a href="http://maven.apache.org/">Apache Maven</a></p>
</li>
<li>
<p>互联网 (Maven需要下载相关依赖库)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="validator-gettingstarted-createproject"><a class="anchor" href="#validator-gettingstarted-createproject"></a>1.1. 创建项目</h3>
<div class="paragraph">
<p>为了在Maven项目中使用Hibernate Validator，只需将以下依赖项添加到 <em>pom.xml</em> 中:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Hibernate Validator Maven 依赖项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;7.0.1.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样也会同时引入依赖 Jakarta Bean Validation API (<code>jakarta.validation:jakarta.validation-api:3.0.0</code>)。</p>
</div>
<div class="paragraph">
<p><mark>( 译者注：hibernate-validator 依赖了 jakarta.validation-api ，所以引入 hibernate-validator 同时也会引入 jakarta.validation-api )</mark></p>
</div>
<div class="sect3">
<h4 id="validator-gettingstarted-uel"><a class="anchor" href="#validator-gettingstarted-uel"></a>1.1.1. 统一的EL表达式</h4>
<div class="paragraph">
<p>Hibernate Validator 需要一个 <a href="https://projects.eclipse.org/projects/ee4j.el">Jakarta Expression Language</a> 的实现，能够使用表达式动态计算校验结果 ( <a href="#section-message-interpolation">Section 4.1, &#8220;默认消息插值&#8221;</a>)。当您的应用程序在 Java EE 容器(如 JOSS AS )中运行时，相关容器已经提供了EL实现。 但是，在Java SE环境中，您必须将一个实现作为依赖项添加到您的POM文件。例如，您可以添加以下依赖项来使用 Jakarta EL <a href="https://github.com/eclipse-ee4j/el-ri">reference
implementation</a>引用:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Maven引入EL的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于那些不能提供EL的环境，Hibernate Validator 提供了一个<a href="#non-el-message-interpolator">Section 12.10, &#8220;<code>ParameterMessageInterpolator</code>&#8221;</a>。但是，使用这个插值器不符合 Jakarta Bean Validation规范。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-getting-started-cdi"><a class="anchor" href="#section-getting-started-cdi"></a>1.1.2. CDI</h4>
<div class="paragraph">
<p>Jakarta Bean Validation 定义了与 CDI
(<a href="https://projects.eclipse.org/projects/ee4j.cdi">Contexts and Dependency Injection for Jakarta EE</a>)的集成点。
如果你的应用运行在一个没有提供这种集成的环境中，你可以使用 Hibernate Validator CDI 可移植扩展，方法是在你的 POM 中添加下面的 Maven 依赖项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Hibernate Validator CDI 可移植扩展 Maven 依赖项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator-cdi&lt;/artifactId&gt;
    &lt;version&gt;7.0.1.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意，在 Java EE 应用程序服务器上运行的应用程序通常不需要添加此依赖项。您可以在<a href="#section-integration-with-cdi">Section 11.3, &#8220;CDI&#8221;</a>中了解关于 Jakarta Bean Validation和 CDI 集成的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-getting-started-security-manager"><a class="anchor" href="#section-getting-started-security-manager"></a>1.1.3. 与安全管理器一起运行</h4>
<div class="paragraph">
<p>Hibernate Validator 支持在启用安全管理器(<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html">security manager</a> )的情况下运行。为此，您必须为 Hibernate Validator、 Jakarta Bean Validation API、 Classmate 和 JBoss Logging 的代码库以及调用 Jakarta Bean Validation 的代码库分配多个权限。 <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html">policy file</a> 展示了如何通过由 Java 默认策略实现处理的策略文件来实现这一点:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. 使用 Hibernate Validator 和安全管理器的策略文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">grant codeBase "file:path/to/hibernate-validator-7.0.1.Final.jar" {
    permission java.lang.reflect.ReflectPermission "suppressAccessChecks";
    permission java.lang.RuntimePermission "accessDeclaredMembers";
    permission java.lang.RuntimePermission "setContextClassLoader";

    permission org.hibernate.validator.HibernateValidatorPermission "accessPrivateMembers";

    // Only needed when working with XML descriptors (validation.xml or XML constraint mappings)
    permission java.util.PropertyPermission "mapAnyUriToUri", "read";
};

grant codeBase "file:path/to/jakarta.validation-api-3.0.0.jar" {
    permission java.io.FilePermission "path/to/hibernate-validator-7.0.1.Final.jar", "read";
};

grant codeBase "file:path/to/jboss-logging-3.4.1.Final.jar" {
    permission java.util.PropertyPermission "org.jboss.logging.provider", "read";
    permission java.util.PropertyPermission "org.jboss.logging.locale", "read";
};

grant codeBase "file:path/to/classmate-1.5.1.jar" {
    permission java.lang.RuntimePermission "accessDeclaredMembers";
};

grant codeBase "file:path/to/validation-caller-x.y.z.jar" {
    permission org.hibernate.validator.HibernateValidatorPermission "accessPrivateMembers";
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在_wildfly_中更新_hibernate_校验器"><a class="anchor" href="#_在_wildfly_中更新_hibernate_校验器"></a>1.1.4. 在 WildFly 中更新 Hibernate 校验器</h4>
<div class="paragraph">
<p><a href="http://wildfly.org/">WildFly 应用程序服务器</a>包含开箱即用的 Hibernate Validator。为了将 Jakarta Bean Validation API 和 Hibernate Validator 的服务器模块更新为最新和最大的模块，可以使用 WildFly 的补丁机制。</p>
</div>
<div class="paragraph">
<p>你可以从 <a href="http://sourceforge.net/projects/hibernate/files/hibernate-validator">SourceForge</a> 或者 使用以下依赖项从 Maven Central 下载修补程序文件:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. WildFly 22.0.0.Final 补丁文件的 Maven 依赖项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator-modules&lt;/artifactId&gt;
    &lt;version&gt;7.0.1.Final&lt;/version&gt;
    &lt;classifier&gt;wildfly-22.0.0.Final-patch&lt;/classifier&gt;
    &lt;type&gt;zip&lt;/type&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还为 WildFly 提供了一个补丁:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Maven 对 WildFly 补丁文件的依赖关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator-modules&lt;/artifactId&gt;
    &lt;version&gt;7.0.1.Final&lt;/version&gt;
    &lt;classifier&gt;wildfly-patch&lt;/classifier&gt;
    &lt;type&gt;zip&lt;/type&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下载了补丁文件后，你可以通过运行以下命令将它应用到 WildFly:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. 应用 WildFly 补丁</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$JBOSS_HOME/bin/jboss-cli.sh patch apply hibernate-validator-modules-7.0.1.Final-wildfly-22.0.0.Final-patch.zip</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你想撤销补丁并返回到服务器最初提供的 Hibernate Validator 版本，请运行以下命令:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. 回滚 WildFly 补丁</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$JBOSS_HOME/bin/jboss-cli.sh patch rollback --reset-configuration=true</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在 <a href="https://developer.jboss.org/wiki/SingleInstallationPatching/">这里</a> 和 <a href="http://www.mastertheboss.com/jboss-server/jboss-configuration/managing-wildfly-and-eap-patches">这里</a>了解有关 WildFly 补丁基础信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="validator-gettingstarted-java9"><a class="anchor" href="#validator-gettingstarted-java9"></a>1.1.5. 在 Java 9上运行</h4>
<div class="paragraph">
<p>从 Hibernate Validator 7.0.1.Final开始。最后，对 Java 9和 Java 平台模块系统(JPMS)的支持是实验性的。目前还没有提供 JPMS 模块描述符，但 Hibernate Validator 可以用作自动模块。</p>
</div>
<div class="paragraph">
<p>这些是使用 <code>Automatic-Module-Name</code> 头声明的模块名称:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jakarta Bean Validation API: <code>java.validation</code></p>
</li>
<li>
<p>Hibernate Validator core: <code>org.hibernate.validator</code></p>
</li>
<li>
<p>Hibernate Validator CDI extension: <code>org.hibernate.validator.cdi</code></p>
</li>
<li>
<p>Hibernate Validator test utilities: <code>org.hibernate.validator.testutils</code></p>
</li>
<li>
<p>Hibernate Validator annotation processor: <code>org.hibernate.validator.annotationprocessor</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些模块名称是暂时的，在将来的版本中提供真正的模块描述符时可能会改变。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="validator-gettingstarted-createmodel"><a class="anchor" href="#validator-gettingstarted-createmodel"></a>1.2. 使用约束</h3>
<div class="paragraph">
<p>让我们直接深入到一个示例中，看看如何使用约束注解。</p>
</div>
<div id="example-class-car" class="exampleblock">
<div class="title">Example 9. 使用约束注解的Car类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter01;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	public Car(String manufacturer, String licencePlate, int seatCount) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	//getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@NotNull</code>, <code>@Size</code> 和 <code>@Min</code> 注解用于声明应该应用于 Car 实例字段的校验:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>manufacturer</code> 字段必须永远不能为 <code>null</code></p>
</li>
<li>
<p><code>licensePlate</code> 字段不能为 <code>null</code> ，并且必须在2到14个字符之间</p>
</li>
<li>
<p><code>seatCount</code> 字段必须至少是2</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以在 GitHub 上的 Hibernate Validator
<a href="https://github.com/hibernate/hibernate-validator/tree/master/documentation/src/test">源代码库</a>
中找到本参考指南中所有示例的完整源代码。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_校验约束"><a class="anchor" href="#_校验约束"></a>1.3. 校验约束</h3>
<div class="paragraph">
<p>若要对这些约束执行校验，请使用 <code>Validator</code> 实例。让我们看一下 <code>Car</code> 的单元测试:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. CarTest展示校验的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter01;

import java.util.Set;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;

import org.junit.BeforeClass;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CarTest {

	private static Validator validator;

	@BeforeClass
	public static void setUpValidator() {
		ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
		validator = factory.getValidator();
	}

	@Test
	public void manufacturerIsNull() {
		Car car = new Car( null, "DD-AB-123", 4 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
				validator.validate( car );

		assertEquals( 1, constraintViolations.size() );
		assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
	}

	@Test
	public void licensePlateTooShort() {
		Car car = new Car( "Morris", "D", 4 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
				validator.validate( car );

		assertEquals( 1, constraintViolations.size() );
		assertEquals(
				"size must be between 2 and 14",
				constraintViolations.iterator().next().getMessage()
		);
	}

	@Test
	public void seatCountTooLow() {
		Car car = new Car( "Morris", "DD-AB-123", 1 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
				validator.validate( car );

		assertEquals( 1, constraintViolations.size() );
		assertEquals(
				"must be greater than or equal to 2",
				constraintViolations.iterator().next().getMessage()
		);
	}

	@Test
	public void carIsValid() {
		Car car = new Car( "Morris", "DD-AB-123", 2 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
				validator.validate( car );

		assertEquals( 0, constraintViolations.size() );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><mark>(译者注：大家在跑单元测试的时候可能会出错，因为做了本地化的处理。错误信息为中文字符与单元测试中的英文不匹配。后面的案例都可能出现类似情况，不再赘述。)</mark></p>
</div>
<div class="paragraph">
<p>在 <code>setUp()</code> 方法中，使用 <code>ValidatorFactory</code> 获取一个 <code>Validator</code> 对象。 <code>Validator</code>
实例是线程安全的，可以多次重用。因此，它可以安全地存储在一个静态变量中，并用于测试方法，以校验不同的 <code>Car</code> 实例.</p>
</div>
<div class="paragraph">
<p><code>validate()</code> 方法返回 <code>ConstraintViolation</code> 对象的 <code>Set</code> 集合, 您可以对其进行迭代操作，以查看发生了哪些校验错误。前三个测试方法显示了一些预期的违反约束的情况:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>manufacturerIsNull()</code> 方法中，违反了 <code>manufacturer</code> 字段的 <code>@NotNull</code> 约束</p>
</li>
<li>
<p>在 <code>licensePlateTooShort()</code> 方法中，违反了 <code>licensePlate</code> 字段的 <code>@Size</code> 约束</p>
</li>
<li>
<p>在 <code>seatCountTooLow()</code> 方法中，违反了 <code>seatCount</code> 字段的 <code>@Min</code> 约束</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果对象成功校验，<code>validate()</code> 方法将返回一个空集，正如您在 <code>carIsValid()</code> 方法中看到的那样。</p>
</div>
<div class="paragraph">
<p>注意，只使用 Bean Validation API中 <code>jakarta.validation</code> 里面的类。没有直接引用来自 Hibernate Validator 的类，可以增强代码的可移植性。</p>
</div>
</div>
<div class="sect2">
<h3 id="validator-gettingstarted-whatsnext"><a class="anchor" href="#validator-gettingstarted-whatsnext"></a>1.4. 接下来的是？</h3>
<div class="paragraph">
<p>以上是对 Hibernate Validator 和 Jakarta Bean Validation 的5分钟快速入门。继续探索代码示例或者进一步阅读 <a href="#validator-further-reading">Chapter 14, <em>进一步阅读</em></a>。</p>
</div>
<div class="paragraph">
<p>要了解关于 bean 和属性校验的更多信息，请继续阅读 <a href="#chapter-bean-constraints">Chapter 2, <em>声明和校验 bean 约束</em></a>。如果您对使用 Jakarta Bean Validation 来校验方法前置和后置条件感兴趣，请参阅<a href="#chapter-method-constraints">Chapter 3, <em>声明和校验 method 约束</em></a> 。如果您的应用程序有特定的校验要求，请参阅<a href="#validator-customconstraints">Chapter 6, <em>自定义约束</em></a>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-bean-constraints"><a class="anchor" href="#chapter-bean-constraints"></a>2. 声明和校验 bean 约束</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，您将学习如何声明 (see <a href="#section-declaring-bean-constraints">Section 2.1, &#8220;声明 bean 约束&#8221;</a>) 以及
校验 (see <a href="#section-validating-bean-constraints">Section 2.2, &#8220;校验 bean 约束&#8221;</a>) bean 约束。
<a href="#section-builtin-constraints">Section 2.3, &#8220;内置约束&#8221;</a> 概述了 Hibernate Validator提供的所有内置约束。</p>
</div>
<div class="paragraph">
<p>如果您对方法参数和返回值的约束校验感兴趣，请参阅 <a href="#chapter-method-constraints">Chapter 3, <em>声明和校验 method 约束</em></a>.</p>
</div>
<div class="sect2">
<h3 id="section-declaring-bean-constraints"><a class="anchor" href="#section-declaring-bean-constraints"></a>2.1. 声明 bean 约束</h3>
<div class="paragraph">
<p>Jakarta Bean Validation 中的约束通过 Java 注解表示。在本节中，您将了解如何使用这些注解增强对象模型。有四种类型的 bean 约束:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>字段约束</p>
</li>
<li>
<p>属性约束</p>
</li>
<li>
<p>集合元素约束</p>
</li>
<li>
<p>类约束</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>并非所有的约束都可以放在所有这些级别上。事实上，Jakarta Bean Validation 定义的约束都不能放在类级别上。约束注解的元注解 <code>java.lang.annotation.Target</code> 表明该注解可以在哪些类型上使用。 请参见 <a href="#validator-customconstraints">Chapter 6, <em>自定义约束</em></a> 获取更多信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_字段级约束"><a class="anchor" href="#_字段级约束"></a>2.1.1. 字段级约束</h4>
<div class="paragraph">
<p>约束可以通过在字段上添加注解来表示。 <a href="#example-field-level">Example 11, &#8220;字段级约束&#8221;</a> 显示了一个字段级别的配置例子:</p>
</div>
<div id="example-field-level" class="exampleblock">
<div class="title">Example 11. 字段级约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.fieldlevel;

public class Car {

	@NotNull
	private String manufacturer;

	@AssertTrue
	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	//getters and setters...
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当使用字段级约束时，就是使用字段的值作为校验的对象。这意味着校验引擎将直接访问实例中的变量，而不是通过调用属性访问器方法，即使存在属性访问器(Getter方法)。</p>
</div>
<div class="paragraph">
<p>字段约束可以应用于任何访问类型(公共、私有等)的字段。但是，不支持对静态字段的约束。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当校验字节码增强对象时，应该使用属性级约束，因为字节码增强库不能通过反射确定要访问的字段。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_属性级约束"><a class="anchor" href="#_属性级约束"></a>2.1.2. 属性级约束</h4>
<div class="paragraph">
<p>如果您的类遵循
<a href="http://www.oracle.com/technetwork/articles/javaee/spec-136004.html">JavaBeans</a> 标准， 那么也可以对 bean 的属性而不是字段进行注解。
<a href="#example-property-level">Example 12, &#8220;属性级约束&#8221;</a> 使用与 <a href="#example-field-level">Example 11, &#8220;字段级约束&#8221;</a> 相同的实体，但是使用了属性级别的约束。</p>
</div>
<div id="example-property-level" class="exampleblock">
<div class="title">Example 12. 属性级约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.propertylevel;

public class Car {

	private String manufacturer;

	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	@NotNull
	public String getManufacturer() {
		return manufacturer;
	}

	public void setManufacturer(String manufacturer) {
		this.manufacturer = manufacturer;
	}

	@AssertTrue
	public boolean isRegistered() {
		return isRegistered;
	}

	public void setRegistered(boolean isRegistered) {
		this.isRegistered = isRegistered;
	}
}</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>属性的 getter 方法需要被使用注解，setter方法则不用。这样就可以约束没有 setter 方法的只读属性。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当使用属性级约束时，校验引擎通过属性访问器方法访问的值作为校验的对象。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>建议在一个类中对某个字段只使用字段 <em>或</em> 属性注解。不建议重复使用字段 <em>和</em> 附带的 getter 方法同时进行注解，因为这会导致对字段进行两次重复的校验。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="container-element-constraints"><a class="anchor" href="#container-element-constraints"></a>2.1.3. 集合元素约束</h4>
<div class="paragraph">
<p>可以直接在参数化类型的类型参数上指定约束: 这些约束称为集合元素约束。</p>
</div>
<div class="paragraph">
<p>这要求在约束定义中通过 <code>@Target</code> 指定 <code>ElementType.TYPE_USE</code> 。在 Jakarta Bean Validation 2.0 中，Jakarta Bean Validation 规定的约束和 Hibernate Validator 特殊实现约束都指定 <code>ElementType.TYPE_USE</code> ，可以直接使用。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 校验下列标准 Java 集合上指定的集合元素约束:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Iterable</code> 的实现 (例如： <code>List</code>s， <code>Set</code>s)，</p>
</li>
<li>
<p><code>java.util.Map</code> 的实现， 支持keys和values方法，</p>
</li>
<li>
<p><code>java.util.Optional</code>， <code>java.util.OptionalInt</code>， <code>java.util.OptionalDouble</code>， <code>java.util.OptionalLong</code>，</p>
</li>
<li>
<p>JavaFX 中的 <code>javafx.beans.observable.ObservableValue</code> 各类实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它还支持自定义集合类型上使用集合元素约束(参见 <a href="#chapter-valueextraction">Chapter 7, <em>值提取</em></a> )。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在6之前的版本中，支持集合元素约束的子集。但在集合级别需要 @valid 注解来启用它们。从 Hibernate Validator 6开始就不再需要这个了。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们将在下面提供两个示例，展示在不同 Java 集合类型上使用集合元素约束。</p>
</div>
<div class="paragraph">
<p>在这些示例中， <code>@ValidPart</code> 是设置了 <code>TYPE_USE</code> 的自定义约束。</p>
</div>
<div class="sect4">
<h5 id="_iterable"><a class="anchor" href="#_iterable"></a>2.1.3.1. <code>Iterable</code></h5>
<div class="paragraph">
<p>在对 <code>Iterable</code> 类型参数应用约束时，Hibernate Validator 将校验其中的每个元素。 <a href="#example-container-element-constraints-iterable">Example 13, &#8220;集合元素约束 <code>Set</code>&#8221;</a> 展示了对有一个元素的 Set 进行约束的示例。</p>
</div>
<div id="example-container-element-constraints-iterable" class="exampleblock">
<div class="title">Example 13. 集合元素约束 <code>Set</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.set;

import java.util.HashSet;
import java.util.Set;

public class Car {

	private Set&lt;@ValidPart String&gt; parts = new HashSet&lt;&gt;();

	public void addPart(String part) {
		parts.add( part );
	}

	//...

}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car();
		car.addPart( "Wheel" );
		car.addPart( null );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

		assertEquals( 1, constraintViolations.size() );

		ConstraintViolation&lt;Car&gt; constraintViolation =
				constraintViolations.iterator().next();
		assertEquals(
				"'null' is not a valid car part.",
				constraintViolation.getMessage()
		);
		assertEquals( "parts[].&lt;iterable element&gt;",
				constraintViolation.getPropertyPath().toString() );</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，属性路径如何清楚地表明违规来自迭代器的元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="_list"><a class="anchor" href="#_list"></a>2.1.3.2. <code>List</code></h5>
<div class="paragraph">
<p>当对 <code>List</code> 类型参数校验约束时， Hibernate Validator 将校验每个元素。 <a href="#example-container-element-constraints-list">Example 14, &#8220;集合元素约束 <code>List</code>&#8221;</a> 展示了对有一个元素的 List 进行约束的示例。</p>
</div>
<div id="example-container-element-constraints-list" class="exampleblock">
<div class="title">Example 14. 集合元素约束 <code>List</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.list;

public class Car {

	private List&lt;@ValidPart String&gt; parts = new ArrayList&lt;&gt;();

	public void addPart(String part) {
		parts.add( part );
	}

	//...

}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car();
		car.addPart( "Wheel" );
		car.addPart( null );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

		assertEquals( 1, constraintViolations.size() );

		ConstraintViolation&lt;Car&gt; constraintViolation =
				constraintViolations.iterator().next();
		assertEquals(
				"'null' is not a valid car part.",
				constraintViolation.getMessage()
		);
		assertEquals( "parts[1].&lt;list element&gt;",
				constraintViolation.getPropertyPath().toString() );</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，属性路径还包含无效元素的索引。</p>
</div>
</div>
<div class="sect4">
<h5 id="_map"><a class="anchor" href="#_map"></a>2.1.3.3. <code>Map</code></h5>
<div class="paragraph">
<p>集合元素约束也在映射键和值上进行校验。
<a href="#example-container-element-constraints-map">Example 15, &#8220;映射键和值上的集合元素约束&#8221;</a> 展示了一个 <code>Map</code> 的例子，对 key 和 value都进行校验。</p>
</div>
<div id="example-container-element-constraints-map" class="exampleblock">
<div class="title">Example 15. 映射键和值上的集合元素约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.map;

import java.util.HashMap;
import java.util.Map;

import jakarta.validation.constraints.NotNull;

public class Car {

	public enum FuelConsumption {
		CITY,
		HIGHWAY
	}

	private Map&lt;@NotNull FuelConsumption, @MaxAllowedFuelConsumption Integer&gt; fuelConsumption = new HashMap&lt;&gt;();

	public void setFuelConsumption(FuelConsumption consumption, int value) {
		fuelConsumption.put( consumption, value );
	}

	//...

}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car();
		car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, 20 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

		assertEquals( 1, constraintViolations.size() );

		ConstraintViolation&lt;Car&gt; constraintViolation =
				constraintViolations.iterator().next();
		assertEquals(
				"20 is outside the max fuel consumption.",
				constraintViolation.getMessage()
		);
		assertEquals(
				"fuelConsumption[HIGHWAY].&lt;map value&gt;",
				constraintViolation.getPropertyPath().toString()
		);</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car();
		car.setFuelConsumption( null, 5 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

		assertEquals( 1, constraintViolations.size() );

		ConstraintViolation&lt;Car&gt; constraintViolation =
				constraintViolations.iterator().next();
		assertEquals(
				"must not be null",
				constraintViolation.getMessage()
		);
		assertEquals(
				"fuelConsumption&lt;K&gt;[].&lt;map key&gt;",
				constraintViolation.getPropertyPath().toString()
		);</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>校验产生的错误信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无效的元素 (在第二个示例中， key为 <code>null</code>)。</p>
</li>
<li>
<p>在第一个示例中， <code>&lt;map value&gt;</code> 不符合约束， 在第二个示例中，<code>&lt;map key&gt;</code> 不符合约束。</p>
</li>
<li>
<p>在第二个示例中，您可能已经注意到类型参数 <code>&lt;k&gt;</code> 的出现，稍后将详细讨论。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_java_util_optional"><a class="anchor" href="#_java_util_optional"></a>2.1.3.4. <code>java.util.Optional</code></h5>
<div class="paragraph">
<p>当对 <code>Optional</code>  参数应用约束时， Hibernate Validator 将自动打开类型并校验内部值。<a href="#example-container-element-constraints-optional">Example 16, &#8220;集合元素约束 Optional&#8221;</a> 展示了一个对 <code>Optional</code> 进行约束的例子。</p>
</div>
<div id="example-container-element-constraints-optional" class="exampleblock">
<div class="title">Example 16. 集合元素约束 Optional</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.optional;

public class Car {

	private Optional&lt;@MinTowingCapacity(1000) Integer&gt; towingCapacity = Optional.empty();

	public void setTowingCapacity(Integer alias) {
		towingCapacity = Optional.of( alias );
	}

	//...

}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car();
		car.setTowingCapacity( 100 );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

		assertEquals( 1, constraintViolations.size() );

		ConstraintViolation&lt;Car&gt; constraintViolation = constraintViolations.iterator().next();
		assertEquals(
				"Not enough towing capacity.",
				constraintViolation.getMessage()
		);
		assertEquals(
				"towingCapacity",
				constraintViolation.getPropertyPath().toString()
		);</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，属性路径只包含属性的名称，因为我们认为 <code>Optional</code> 是一个“透明”集合。</p>
</div>
</div>
<div class="sect4">
<h5 id="_使用自定义集合类型"><a class="anchor" href="#_使用自定义集合类型"></a>2.1.3.5. 使用自定义集合类型</h5>
<div class="paragraph">
<p>集合元素约束也可以用于自定义集合。</p>
</div>
<div class="paragraph">
<p>必须为自定义类型注册 <code>ValueExtractor</code> ，以允许检索要校验的值 (see <a href="#chapter-valueextraction">Chapter 7, <em>值提取</em></a> 以获得关于如何实现自己的 <code>ValueExtractor</code> 以及如何注册它的更多信息)。</p>
</div>
<div class="paragraph">
<p><a href="#example-container-element-constraints-custom-container-type">Example 17, &#8220;自定义集合类型上的集合元素约束&#8221;</a> 展示了一个具有类型参数约束的自定义参数化类型的示例。</p>
</div>
<div id="example-container-element-constraints-custom-container-type" class="exampleblock">
<div class="title">Example 17. 自定义集合类型上的集合元素约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class Car {

	private GearBox&lt;@MinTorque(100) Gear&gt; gearBox;

	public void setGearBox(GearBox&lt;Gear&gt; gearBox) {
		this.gearBox = gearBox;
	}

	//...

}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class GearBox&lt;T extends Gear&gt; {

	private final T gear;

	public GearBox(T gear) {
		this.gear = gear;
	}

	public Gear getGear() {
		return this.gear;
	}
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class Gear {
	private final Integer torque;

	public Gear(Integer torque) {
		this.torque = torque;
	}

	public Integer getTorque() {
		return torque;
	}

	public static class AcmeGear extends Gear {
		public AcmeGear() {
			super( 60 );
		}
	}
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class GearBoxValueExtractor implements ValueExtractor&lt;GearBox&lt;@ExtractedValue ?&gt;&gt; {

	@Override
	public void extractValues(GearBox&lt;@ExtractedValue ?&gt; originalValue, ValueExtractor.ValueReceiver receiver) {
		receiver.value( null, originalValue.getGear() );
	}
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car();
		car.setGearBox( new GearBox&lt;&gt;( new Gear.AcmeGear() ) );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
		assertEquals( 1, constraintViolations.size() );

		ConstraintViolation&lt;Car&gt; constraintViolation =
				constraintViolations.iterator().next();
		assertEquals(
				"Gear is not providing enough torque.",
				constraintViolation.getMessage()
		);
		assertEquals(
				"gearBox",
				constraintViolation.getPropertyPath().toString()
		);</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_嵌套集合元素"><a class="anchor" href="#_嵌套集合元素"></a>2.1.3.6. 嵌套集合元素</h5>
<div class="paragraph">
<p>嵌套集合元素也支持约束。</p>
</div>
<div class="paragraph">
<p>当校验 <a href="#example-container-element-nested">Example 18, &#8220;嵌套集合元素的约束&#8221;</a> 中的 <code>Car</code> 类， 集合中的 <code>Part</code> 和 <code>Manufacturer</code> 都会执行 <code>@NotNull</code> 的校验。</p>
</div>
<div id="example-container-element-nested" class="exampleblock">
<div class="title">Example 18. 嵌套集合元素的约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.containerelement.nested;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jakarta.validation.constraints.NotNull;

public class Car {

	private Map&lt;@NotNull Part, List&lt;@NotNull Manufacturer&gt;&gt; partManufacturers =
			new HashMap&lt;&gt;();

	//...
}</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validator-usingvalidator-classlevel"><a class="anchor" href="#validator-usingvalidator-classlevel"></a>2.1.4. 类层面的约束</h4>
<div class="paragraph">
<p>最后但并非最不重要的一点是，还可以在类级别上放置约束。在这种情况下，校验的对象不是单个属性，而是完整的对象。如果校验依赖于对象的几个属性之间的相关性，则类级别约束非常有用。</p>
</div>
<div class="paragraph">
<p><a href="#example-class-level">Example 19, &#8220;类级别约束&#8221;</a> 中的 <code>Car</code> 具有两个属性 <code>seatCount</code> 和 <code>passengers</code> 的约束，应确保乘客名单中的登记项不超过可用座位。为此，在类级别上添加 <code>@ValidPassengerCount</code> 约束。该约束的校验器可以访问完整的 <code>Car</code> 对象，允许比较座位和乘客的数量。</p>
</div>
<div class="paragraph">
<p>请参阅 <a href="#section-class-level-constraints">Section 6.2, &#8220;类级别的约束&#8221;</a> ，详细了解如何实现这个自定义约束。</p>
</div>
<div id="example-class-level" class="exampleblock">
<div class="title">Example 19. 类级别约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.classlevel;

@ValidPassengerCount
public class Car {

	private int seatCount;

	private List&lt;Person&gt; passengers;

	//...
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-constraint-inheritance"><a class="anchor" href="#section-constraint-inheritance"></a>2.1.5. 约束继承</h4>
<div class="paragraph">
<p>当一个类实现一个接口或扩展另一个类时，在父类型上声明的所有约束注解以与在类本身上指定的约束相同的方式应用。为了让事情更清楚，让我们看看下面的例子:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. 约束继承</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.inheritance;

public class Car {

	private String manufacturer;

	@NotNull
	public String getManufacturer() {
		return manufacturer;
	}

	//...
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.inheritance;

public class RentalCar extends Car {

	private String rentalStation;

	@NotNull
	public String getRentalStation() {
		return rentalStation;
	}

	//...
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里 <code>RentalCar</code> 是 <code>Car</code> 的一个子类，并添加了属性 <code>rentalStation</code>。如果对
<code>RentalCar</code> 的实例进行了校验， 不仅会校验 <code>rentalStation</code> 上的 <code>@NotNull</code> 注解， 还会计算来自父类的 <code>manufacturer</code> 约束。</p>
</div>
<div class="paragraph">
<p>如果 <code>Car</code> 不是一个超类，而是由 <code>RentalCar</code> 实现的接口，情况也是如此。</p>
</div>
<div class="paragraph">
<p>如果方法被重写，则约束注解将被聚合。因此，如果 <code>RentalCar</code> 覆盖了 <code>Car</code> 中的
<code>getManufacturer()</code> 方法， 那么除了超类中的 <code>@NotNull</code> 约束之外，还将校验覆盖方法中注解的任何约束。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-object-graph-validation"><a class="anchor" href="#section-object-graph-validation"></a>2.1.6. 对象图</h4>
<div class="paragraph">
<p>Jakarta Bean Validation API 不仅允许校验单个类实例，还允许校验完整的对象图(级联校验)。 要做到这一点，只需使用 <code>@Valid</code> 对表示对另一个对象的引用的字段或属性进行校验，如<a href="#example-cascaded-validation">Example 21, &#8220;级联校验&#8221;</a>。</p>
</div>
<div id="example-cascaded-validation" class="exampleblock">
<div class="title">Example 21. 级联校验</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.objectgraph;

public class Car {

	@NotNull
	@Valid
	private Person driver;

	//...
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.objectgraph;

public class Person {

	@NotNull
	private String name;

	//...
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果校验了 <code>Car</code> ， 那么引用的 <code>Person</code> 对象也会被校验， 因为
<code>driver</code> 字段使用了 <code>@Valid</code> 注解，。因此，如果引用的 <code>Person</code> 实例的 <code>name</code> 字段为 <code>null</code>，则 <code>Car</code> 的校验将失败。</p>
</div>
<div class="paragraph">
<p>对象图的校验是递归的，也就是说，如果一个标记为级联校验的引用指向一个对象，该对象本身具有带 <code>@valid</code> 注解的属性，校验引擎也会跟踪这些引用。校验引擎将确保在级联校验期间不会发生无限循环，例如，如果两个对象彼此保持引用。</p>
</div>
<div class="paragraph">
<p>注意，在级联校验过程中忽略 <code>null</code> 。</p>
</div>
<div class="paragraph">
<p>作为约束，对象图校验也适用于集合元素。这意味着集合的任何类型参数都可以用 <code>@valid</code> 注解，这将导致在校验父对象时校验每个包含的元素。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>嵌套集合元素也支持级联校验。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-cascaded-validation-list" class="exampleblock">
<div class="title">Example 22. 集合级联校验</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;

public class Car {

	private List&lt;@NotNull @Valid Person&gt; passengers = new ArrayList&lt;Person&gt;();

	private Map&lt;@Valid Part, List&lt;@Valid Manufacturer&gt;&gt; partManufacturers = new HashMap&lt;&gt;();

	//...
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;

public class Part {

	@NotNull
	private String name;

	//...
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;

public class Manufacturer {

	@NotNull
	private String name;

	//...
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当校验 <a href="#example-cascaded-validation-list">Example 22, &#8220;集合级联校验&#8221;</a> 中的 <code>Car</code> 类的实例时 ， 以下情况 <code>ConstraintViolation</code> 将被创建：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果 passengers 链表中的任何 <code>Person</code> 对象的name字段为 <code>null</code> ;</p>
</li>
<li>
<p>如果 map keys 中的 <code>Part</code> 对象具有 <code>null</code> 的 name字段;</p>
</li>
<li>
<p>如果 map values 中的 <code>Manufacturer</code> 对象具有 <code>null</code> 的 name字段;</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在6之前的版本中，Hibernate Validator 支持对集合元素子集进行级联校验，并且在集合级别实现(例如，您可以使用 <code>@Valid private List&lt;Person&gt;</code> 对 <code>Person</code> 对象启用级联校验).</p>
</div>
<div class="paragraph">
<p>这仍然受到支持，但不建议这样做。请使用集合元素级别 <code>@Valid</code> 注解，因为它更具表达性。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-validating-bean-constraints"><a class="anchor" href="#section-validating-bean-constraints"></a>2.2. 校验 bean 约束</h3>
<div class="paragraph">
<p><code>Validator</code> 接口是 Jakarta Bean Validation中最重要的对象。下一节将展示如何获取  <code>Validator</code> 实例。之后，您将学习如何使用 <code>Validator</code> 接口定义的不同方法。</p>
</div>
<div class="sect3">
<h4 id="section-obtaining-validator"><a class="anchor" href="#section-obtaining-validator"></a>2.2.1. 获取 <code>Validator</code> 实例</h4>
<div class="paragraph">
<p>校验实例的第一步是获得 <code>Validator</code> 实例。为获取这个实例的需要通过 <code>Validation</code> 类和  <code>ValidatorFactory</code> 。最简单的方法是使用静态方法 <code>Validation # builddefaultvalidatorfactory()</code> :</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. <code>Validation#buildDefaultValidatorFactory()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>		ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
		validator = factory.getValidator();</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将使用默认配置启动校验程序。请参阅 <a href="#chapter-bootstrapping">Chapter 9, <em>Bootstrapping</em></a> 以了解更多关于不同的 Bootstrapping 方法以及如何获得特定配置的 <code>Validator</code> 实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_validator_方法"><a class="anchor" href="#_validator_方法"></a>2.2.2. Validator 方法</h4>
<div class="paragraph">
<p><code>Validator</code> 接口定义了三个方法，可用于校验整个实体或仅校验实体的单个属性。</p>
</div>
<div class="paragraph">
<p>这三个方法都返回一个 <code>Set&lt;ConstraintViolation&gt;</code>。如果校验成功，集合是空的。否则，将为每个违反的约束添加一个 <code>ConstraintViolation</code> 实例。</p>
</div>
<div class="paragraph">
<p>所有的校验方法都有一个可变参数，可以用来指定在执行校验时应该考虑哪些校验组。如果未指定参数，则默认校验组( <code>jakarta.validation.groups.Default</code>) 。 分组将在 <a href="#chapter-groups">Chapter 5, <em>分组约束</em></a> 中详细讨论 。</p>
</div>
<div class="sect4">
<h5 id="_validatorvalidate"><a class="anchor" href="#_validatorvalidate"></a>2.2.2.1. <code>Validator#validate()</code></h5>
<div class="paragraph">
<p>使用 <code>validate()</code> 方法对给定 bean 的所有约束执行校验。
<a href="#example-validator-validate">Example 24, &#8220;使用 <code>Validator#validate()</code>&#8221;</a> 中的 <code>Car</code> 类来自
<a href="#example-property-level">Example 12, &#8220;属性级约束&#8221;</a> 该实例未能满足 <code>manufacturer</code> 字段上的 <code>@NotNull</code> 约束。因此，校验调用返回一个 <code>ConstraintViolation</code> 对象。</p>
</div>
<div id="example-validator-validate" class="exampleblock">
<div class="title">Example 24. 使用 <code>Validator#validate()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car( null, true );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

		assertEquals( 1, constraintViolations.size() );
		assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_validatorvalidateproperty"><a class="anchor" href="#_validatorvalidateproperty"></a>2.2.2.2. <code>Validator#validateProperty()</code></h5>
<div class="paragraph">
<p>借助 <code>validateProperty()</code> 您可以校验给定对象的单个属性。</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 使用 <code>Validator#validateProperty()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>		Car car = new Car( null, true );

		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(
				car,
				"manufacturer"
		);

		assertEquals( 1, constraintViolations.size() );
		assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_validatorvalidatevalue"><a class="anchor" href="#_validatorvalidatevalue"></a>2.2.2.3. <code>Validator#validateValue()</code></h5>
<div class="paragraph">
<p>通过使用  <code>validateValue()</code> 方法，您可以检查某值对给定类的单个属性是否可以成功校验：</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. 使用 <code>Validator#validateValue()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>		Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(
				Car.class,
				"manufacturer",
				null
		);

		assertEquals( 1, constraintViolations.size() );
		assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Valid</code> 不在 <code>validateProperty()</code> 或 <code>validateValue()</code> 方法里生效。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，<code>Validator#validateProperty()</code> 用于将 Jakarta Bean Validation 集成到 JSF 2中(see <a href="#section-presentation-layer">Section 11.2, &#8220;JSF &amp; Seam&#8221;</a>) ，以便对输入到表单中的值执行校验，然后将它们传播到模型中。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-constraint-violation-methods"><a class="anchor" href="#section-constraint-violation-methods"></a>2.2.3. <code>ConstraintViolation</code></h4>
<div class="sect4">
<h5 id="_constraintviolation_的方法"><a class="anchor" href="#_constraintviolation_的方法"></a>2.2.3.1. <code>ConstraintViolation</code> 的方法</h5>
<div class="paragraph">
<p>现在是时候仔细研究一下什么是 <code>ConstraintViolation</code> 了。使用 <code>ConstraintViolation</code> 中不同的方法可以获取校验失败原因的许多有用信息。以下是这些方法的概述。
列下的案例值引用了 <a href="#example-validator-validate">Example 24, &#8220;使用 <code>Validator#validate()</code>&#8221;</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getMessage()</code></dt>
<dd>
<p>The interpolated error message</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p>"must not be null"</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getMessageTemplate()</code></dt>
<dd>
<p>The non-interpolated error message</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p>"{&#8230;&#8203; NotNull.message}"</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getRootBean()</code></dt>
<dd>
<p>The root bean being validated</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p>car</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getRootBeanClass()</code></dt>
<dd>
<p>The class of the root bean being validated</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p><code>Car.class</code></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getLeafBean()</code></dt>
<dd>
<p>If a bean constraint， the bean instance the constraint is
applied on; if a property constraint， the bean instance hosting
the property the constraint is applied on</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p><code>car</code></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getPropertyPath()</code></dt>
<dd>
<p>The property path to the validated value from root bean</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p>contains one node with kind <code>PROPERTY</code> and name "manufacturer"</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getInvalidValue()</code></dt>
<dd>
<p>The value failing to pass the constraint</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p><code>null</code></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>getConstraintDescriptor()</code></dt>
<dd>
<p>Constraint metadata reported to fail</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Example</dt>
<dd>
<p>descriptor for <code>@NotNull</code></p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_利用_property_path"><a class="anchor" href="#_利用_property_path"></a>2.2.3.2. 利用 property path</h5>
<div class="paragraph">
<p>要确定触发冲突的原因，需要利用 <code>getPropertyPath()</code> 方法的返回值。</p>
</div>
<div class="paragraph">
<p>返回的 <code>Path</code> 由描述元素路径的 <code>Node</code>s 组成</p>
</div>
<div class="paragraph">
<p>关于 <code>Path</code> 的结构和各种类型的 <code>Node</code>s 的更多信息可以在 Jakarta Bean Validation 规范中的 <code>ConstraintViolation</code> 章节找到.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-builtin-constraints"><a class="anchor" href="#section-builtin-constraints"></a>2.3. 内置约束</h3>
<div class="paragraph">
<p>Hibernate Validator 包含一组常用的约束。这些都是 Jakarta Bean Validation 规范定义 (see <a href="#validator-defineconstraints-spec">Section 2.3.1, &#8220;Jakarta Bean Validation 约束&#8221;</a>)。
此外，Hibernate Validator 还提供了在某些场景十分有用的自定义约束 (see
<a href="#validator-defineconstraints-hv-constraints">Section 2.3.2, &#8220;附加约束&#8221;</a>)。</p>
</div>
<div class="sect3">
<h4 id="validator-defineconstraints-spec"><a class="anchor" href="#validator-defineconstraints-spec"></a>2.3.1. Jakarta Bean Validation 约束</h4>
<div class="paragraph">
<p>下面是 Jakarta Bean Validation API 中指定的所有约束的列表。
所有这些约束都适用于字段/属性级别，在 Jakarta Bean Validation规范中没有定义类级别约束。如果您使用 Hibernate ORM , 那么在为您的实体类创建 DDL 语句时会考虑到一些约束 (在下面的列表的 "Hibernate 元数据影响")。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Validator 允许将一些约束应用于更多的数据类型，而不是  Jakarta Bean Validation 规范所要求的数据类型 (例如  <code>@Max</code> 可以应用于字符串)。但是，如果你在程序中依赖此特性，可能会影响应用程序在 Jakarta Bean Validation 提供程序之间的可移植性。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@AssertFalse</code></dt>
<dd>
<p>检查带注解的元素是否为false</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>Boolean</code>， <code>boolean</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@AssertTrue</code></dt>
<dd>
<p>检查带注解的元素是否为true</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>Boolean</code>， <code>boolean</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@DecimalMax(value=， inclusive=)</code></dt>
<dd>
<p>当 <code>inclusive</code> = false 时，检查带注解的值是否小于指定的最大值。否则，该值是否小于或等于指定的最大值。参数值是根据 <code>BigDecimal</code> 字符串表示形式的值。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>CharSequence</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 以及各自的基本类型包装器; Hibernate Validator还支持 <a href="https://jcp.org/en/jsr/detail?id=354">JSR 354 API</a> 中的 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的实现。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@DecimalMin(value=， inclusive=)</code></dt>
<dd>
<p>当 <code>inclusive</code> = false 时，检查带注解的值是否大于指定的最小值。否则，该值是否大于或等于指定的最小值。参数值是根据 <code>BigDecimal</code> 字符串表示形式的值。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>CharSequence</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 以及各自的基本类型包装器; Hibernate Validator还支持 <a href="https://jcp.org/en/jsr/detail?id=354">JSR 354 API</a> 中的 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的实现。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Digits(integer=， fraction=)</code></dt>
<dd>
<p>检查被注解的值是否最多有 <code>integer</code> 位整数和 <code>fraction</code> 位小数</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p>BigDecimal， <code>BigInteger</code>， <code>CharSequence</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> a以及各自的基本类型包装器; Hibernate Validator还支持 <a href="https://jcp.org/en/jsr/detail?id=354">JSR 354 API</a> 中的 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的实现。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>定义数据的精度和规模</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Email</code></dt>
<dd>
<p>检查指定的字符序列是否为有效的电子邮件地址。可选参数 regexp 和 flag 允许指定电子邮件必须匹配的附加正则表达式(包括正则表达式标志)。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Future</code></dt>
<dd>
<p>检查注解的日期是否在将来</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>java.util.Date</code>， <code>java.util.Calendar</code>， <code>java.time.Instant</code>， <code>java.time.LocalDate</code>， <code>java.time.LocalDateTime</code>， <code>java.time.LocalTime</code>， <code>java.time.MonthDay</code>， <code>java.time.OffsetDateTime</code>， <code>java.time.OffsetTime</code>， <code>java.time.Year</code>， <code>java.time.YearMonth</code>， <code>java.time.ZonedDateTime</code>， <code>java.time.chrono.HijrahDate</code>， <code>java.time.chrono.JapaneseDate</code>， <code>java.time.chrono.MinguoDate</code>， <code>java.time.chrono.ThaiBuddhistDate</code>; Hibernate Validator还支持 <a href="http://www.joda.org/joda-time/">Joda Time</a> 中的 <code>ReadablePartial</code> 和 <code>ReadableInstant</code> 实现</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@FutureOrPresent</code></dt>
<dd>
<p>检查注解的日期是现在或者将来</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>java.util.Date</code>， <code>java.util.Calendar</code>， <code>java.time.Instant</code>， <code>java.time.LocalDate</code>， <code>java.time.LocalDateTime</code>， <code>java.time.LocalTime</code>， <code>java.time.MonthDay</code>， <code>java.time.OffsetDateTime</code>， <code>java.time.OffsetTime</code>， <code>java.time.Year</code>， <code>java.time.YearMonth</code>， <code>java.time.ZonedDateTime</code>， <code>java.time.chrono.HijrahDate</code>， <code>java.time.chrono.JapaneseDate</code>， <code>java.time.chrono.MinguoDate</code>， <code>java.time.chrono.ThaiBuddhistDate</code>; Hibernate Validator还支持 <a href="http://www.joda.org/joda-time/">Joda Time</a> 中的 <code>ReadablePartial</code> 和 <code>ReadableInstant</code> 实现</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Max(value=)</code></dt>
<dd>
<p>检查注解的值是否小于或等于指定的最大值</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 以及原始类型的各个包装器; Hibernate Validator还支持  <code>CharSequence</code> 的子类 (字符序列表示的数值被求值)，以及 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的子类。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>在列上添加检查约束</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Min(value=)</code></dt>
<dd>
<p>检查注解的值是否高于或等于指定的最小值</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 以及原始类型的各个包装器; Hibernate Validator还支持  <code>CharSequence</code> 的子类 (字符序列表示的数值被求值)，以及 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的子类。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>在列上添加检查约束</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@NotBlank</code></dt>
<dd>
<p>检查带注解的字符序列是否为空，去除首尾的空格后的长度是否大于0。 与 <code>@NotEmpty</code> 的不同之处在于，这个约束只能应用于字符序列，并且尾随的空格被忽略。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@NotEmpty</code></dt>
<dd>
<p>检查带注解的元素是否为 <code>null</code> 或 ""</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code>， <code>Collection</code>， <code>Map</code> and arrays</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@NotNull</code></dt>
<dd>
<p>检查注解的值是否为 <code>null</code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p>Any type</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>Column(s) are not nullable</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Negative</code></dt>
<dd>
<p>检查元素是否严格为负。零值无效。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 和各自的基本类型包装器;Hibernate Validator还支持  <code>CharSequence</code> 的子类 (字符序列表示的数值被求值)，以及 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的子类。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@NegativeOrZero</code></dt>
<dd>
<p>检查元素是否为负数或零。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 和各自的基本类型包装器;Hibernate Validator还支持  <code>CharSequence</code> 的子类 (字符序列表示的数值被求值)，以及 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的子类。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Null</code></dt>
<dd>
<p>检查注解的值是否为 <code>null</code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p>Any type</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Past</code></dt>
<dd>
<p>检查注解的日期是否在过去</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>java.util.Date</code>，<code>java.util.Calendar</code>， <code>java.time.Instant</code>， <code>java.time.LocalDate</code>， <code>java.time.LocalDateTime</code>， <code>java.time.LocalTime</code>， <code>java.time.MonthDay</code>， <code>java.time.OffsetDateTime</code>， <code>java.time.OffsetTime</code>， <code>java.time.Year</code>， <code>java.time.YearMonth</code>， <code>java.time.ZonedDateTime</code>， <code>java.time.chrono.HijrahDate</code>， <code>java.time.chrono.JapaneseDate</code>， <code>java.time.chrono.MinguoDate</code>， <code>java.time.chrono.ThaiBuddhistDate</code>; Hibernate Validator还支持 <a href="http://www.joda.org/joda-time/">Joda Time</a> 中的 <code>ReadablePartial</code> 和 <code>ReadableInstant</code> 实现</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@PastOrPresent</code></dt>
<dd>
<p>检查注解的日期是过去或者现在</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>java.util.Date</code>，<code>java.util.Calendar</code>， <code>java.time.Instant</code>， <code>java.time.LocalDate</code>， <code>java.time.LocalDateTime</code>， <code>java.time.LocalTime</code>， <code>java.time.MonthDay</code>， <code>java.time.OffsetDateTime</code>， <code>java.time.OffsetTime</code>， <code>java.time.Year</code>， <code>java.time.YearMonth</code>， <code>java.time.ZonedDateTime</code>， <code>java.time.chrono.HijrahDate</code>， <code>java.time.chrono.JapaneseDate</code>， <code>java.time.chrono.MinguoDate</code>， <code>java.time.chrono.ThaiBuddhistDate</code>; Hibernate Validator还支持 <a href="http://www.joda.org/joda-time/">Joda Time</a> 中的 <code>ReadablePartial</code> 和 <code>ReadableInstant</code> 实现</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Pattern(regex=， flags=)</code></dt>
<dd>
<p>考虑给定的标志匹配，检查带注解的字符串是否与正则表达式 <code>regex</code> 匹配</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Positive</code></dt>
<dd>
<p>检查元素是否为严格正数。零值无效。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 和各自的基本类型包装器;Hibernate Validator还支持  <code>CharSequence</code> 的子类 (字符序列表示的数值被求值)，以及 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的子类。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@PositiveOrZero</code></dt>
<dd>
<p>检查元素是正数或者零。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code> 和各自的基本类型包装器;Hibernate Validator还支持  <code>CharSequence</code> 的子类 (字符序列表示的数值被求值)，以及 <code>Number</code> 和 <code>javax.money.MonetaryAmount</code> 的子类。</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Size(min=， max=)</code></dt>
<dd>
<p>检查带注解的元素的大小是否介于最小和最大(包括)之间</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code>， <code>Collection</code>， <code>Map</code> and arrays</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>Column length will be set to <code>max</code></p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在上面列出的参数之上，每个约束都有参数消息、组和有效负载。这是 Jakarta Bean Validation 规范的一个要求。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="validator-defineconstraints-hv-constraints"><a class="anchor" href="#validator-defineconstraints-hv-constraints"></a>2.3.2. 附加约束</h4>
<div class="paragraph">
<p>除了 Jakarta Bean Validation API 定义的约束之外，Hibernate Validator 还提供了下面列出的几个有用的自定义约束。除了一个 <code>@ScriptAssert</code> 例外可以用于类级别的约束，这些约束只适用于字段/属性级别。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@CreditCardNumber(ignoreNonDigitCharacters=)</code></dt>
<dd>
<p>检查带注解的字符序列是否通过 Luhn 校验和测试。注意，此校验旨在检查用户错误，而不是信用卡的有效性！参见 <a href="http://www.dirigodev.com/blog/ecommerce/anatomy-of-a-credit-card-number/">Anatomy of a credit card number</a>. <code>ignoreNonDigitCharacters</code> 允许忽略非数字字符。默认值为 <code>false</code>。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Currency(value=)</code></dt>
<dd>
<p>检查带注解的 <code>javax.money.MonetaryAmount</code> 的货币单位是否是指定货币单位的一部分。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>javax.money.MonetaryAmount</code> <a href="https://jcp.org/en/jsr/detail?id=354">JSR 354 API</a> 的实现类</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@DurationMax(days=， hours=， minutes=， seconds=， millis=， nanos=， inclusive=)</code></dt>
<dd>
<p>注解了 <code>java.time.Duration</code> 元素不大于由注解参数构造的元素。如果将 <code>inclusive</code> 标志设置为 <code>true</code>，则允许相等。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>java.time.Duration</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@DurationMin(days=， hours=， minutes=， seconds=， millis=， nanos=， inclusive=)</code></dt>
<dd>
<p>注解了 <code>java.time.Duration</code> 元素不小于由注解参数构造的元素。如果将 <code>inclusive</code> 标志设置为 <code>true</code>，则允许相等。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>java.time.Duration</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@EAN</code></dt>
<dd>
<p>检查带注解的字符序列是否为有效的 <a href="http://en.wikipedia.org/wiki/International_Article_Number_%28EAN%29">EAN</a> 条形码。类型决定了条形码的类型。默认值是 EAN-13。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@ISBN</code></dt>
<dd>
<p>检查带注解的字符序列是否为有效的 <a href="https://en.wikipedia.org/wiki/International_Standard_Book_Number">ISBN</a> 条形码。类型决定了条形码的类型。默认值是 ISBN-13。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Length(min=， max=)</code></dt>
<dd>
<p>校验带注解的字符序列长度是否在 <code>min</code> 和 <code>max</code> 之间</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>Column length will be set to max</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@CodePointLength(min=， max=， normalizationStrategy=)</code></dt>
<dd>
<p>校验带注解的字符序列的代码点长度是否在最小值和最大值之间。如果设置了 <code>normalizationStrategy</code> ，则校验规范化值。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@LuhnCheck(startIndex= ， endIndex=， checkDigitIndex=， ignoreNonDigitCharacters=)</code></dt>
<dd>
<p>检查带注解的字符序列中的数字是否通过 Luhn 校验和算法 (see also <a href="http://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a>). <code>startIndex</code> 和 <code>endIndex</code> 只允许在指定的子字符串上运行算法。 <code>checkDigitIndex</code> 允许使用字符序列中的任意数字作为校验数字。如果未指定，则假定检查数字是指定范围的一部分。最后但并非最不重要的是，<code>ignoreNonDigitCharacters</code> 允许忽略非数字字符。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Mod10Check(multiplier=， weight=， startIndex=， endIndex=， checkDigitIndex=， ignoreNonDigitCharacters=)</code></dt>
<dd>
<p>检查带注解的字符序列中的数字是否通过了通用的 mod 10校验和算法。 <code>multiplier</code> 决定奇数的乘数(缺省为3) ，加权为偶数(缺省为1)。 <code>startIndex</code> 和 <code>endIndex</code> 只允许在指定的子字符串上运行算法。 <code>checkDigitIndex</code> 允许使用字符序列中的任意数字作为校验数字。如果未指定，则假定检查数字是指定范围的一部分。最后但并非最不重要的是，<code>ignoreNonDigitCharacters</code> 允许忽略非数字字符。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Mod11Check(threshold=， startIndex=， endIndex=， checkDigitIndex=， ignoreNonDigitCharacters=， treatCheck10As=， treatCheck11As=)</code></dt>
<dd>
<p>C检查带注解的字符序列中的数字是否通过 mod 11校验和算法。 <code>threshold`指定 mod11乘数增长的阈值; 如果没有指定值，乘数将无限增长。 `treatCheck10As</code> 和 <code>treatCheck11As</code> 分别指定当 mod 11校验和等于10或11时使用的校验数字。默认值分别为 x 和0。  <code>startIndex</code>， <code>endIndex</code> <code>checkDigitIndex</code> and <code>ignoreNonDigitCharacters</code>  的语义与 `@Mod10Check`中的相同。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Normalized(form=)</code></dt>
<dd>
<p>校验注解的字符序列是否根据给定的 <code>form</code> 进行了规范化。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@Range(min=， max=)</code></dt>
<dd>
<p>检查注解值是否位于指定的最小值和最大值之间</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>BigDecimal</code>， <code>BigInteger</code>， <code>CharSequence</code>， <code>byte</code>， <code>short</code>， <code>int</code>， <code>long</code>  以及基元类型的相应包装器</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@ScriptAssert(lang=， script=， alias=， reportOn=)</code></dt>
<dd>
<p>检查是否可以根据带注解的元素成功地计算给定的脚本。为了使用这个约束，JSR 223(“ Java <sup>TM</sup> 平台的脚本编程”)定义的 Java 脚本 API 的实现必须是类路径的一部分。要求值的表达式可以使用任何脚本或表达式语言编写，在类路径中可以找到与 JSR 223兼容的引擎。即使这是一个类级别的约束，也可以使用 <code>reportOn</code> 属性报告特定属性(而不是整个对象)上的约束冲突。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p>Any type</p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@UniqueElements</code></dt>
<dd>
<p>检查带注解的集合是否只包含唯一元素。相等是使用 <code>equals()</code> 方法确定的。默认消息不包含重复元素的列表，但是可以通过重写消息并使用{ <code>duplicates</code> }消息参数来包含它。重复元素列表也包含在约束违反的动态有效负载中。</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>Collection</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@URL(protocol=， host=， port=， regexp=， flags=)</code></dt>
<dd>
<p>根据 RFC2396检查带注解的字符序列是否为有效的 URL。如果指定了任何可选参数 <code>protocol</code>， <code>host</code> or <code>port</code> ，则相应的 URL 片段必须匹配指定的值。可选参数 <code>regexp</code> 和 <code>flags</code> 允许指定 URL 必须匹配的附加正则表达式(包括正则表达式标志)。根据默认情况，此约束使用 <code>java. net. URL</code> 构造函数校验给定字符串是否表示有效 URL。还有一个基于正则表达式的版本—— <code>RegexpURLValidator</code> ——可以通过 XML ( see <a href="#section-mapping-xml-constraints">Section 8.2, &#8220;通过 <code>constraint-mappings</code> 映射约束&#8221;</a>) 或 (see <a href="#section-programmatic-constraint-definition">Section 12.15.2, &#8220;以编程方式添加约束定义&#8221;</a>).</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="_特殊国家约束"><a class="anchor" href="#_特殊国家约束"></a>2.3.2.1. 特殊国家约束</h5>
<div class="paragraph">
<p>Hibernate Validator 还提供了一些国家特有的约束，例如用于校验社会安全号码。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您必须实现一个国家特定的约束，可以考虑将其作为 Hibernate Validator 的一个贡献！</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@CNPJ</code></dt>
<dd>
<p>检查带注解的字符序列是否代表巴西公司纳税人注册号(Cadastro de Pessoa Jurídica)</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Brazil</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@CPF</code></dt>
<dd>
<p>检查带注解的字符序列是否代表巴西个人纳税人登记号(Cadastro de Pessoa Física)</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Brazil</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@TituloEleitoral</code></dt>
<dd>
<p>检查带注解的字符序列是否代表巴西选民身份证号码 (<a href="http://www.exceldoseujeito.com.br/2008/12/19/validar-cpf-cnpj-e-titulo-de-eleitor-parte-ii/">Título Eleitoral</a>)</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Brazil</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@NIP</code></dt>
<dd>
<p>检查带注解的字符序列是否表示波兰 VAT 标识号 (<a href="https://pl.wikipedia.org/wiki/NIP">NIP</a>)</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Poland</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@PESEL</code></dt>
<dd>
<p>检查带注解的字符序列是否表示波兰国家标识号 (<a href="https://pl.wikipedia.org/wiki/PESEL">PESEL</a>)</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Poland</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@REGON</code></dt>
<dd>
<p>检查带注解的字符序列是否表示波兰纳税人识别号 (<a href="https://pl.wikipedia.org/wiki/REGON">REGON</a>). 。可同时应用于9位和14位数字版本的 REGON</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Poland</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>@INN</code></dt>
<dd>
<p>检查带注解的字符序列是否表示一个俄罗斯纳税人识别号 (<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BC%D0%B5%D1%80_%D0%BD%D0%B0%D0%BB%D0%BE%D0%B3%D0%BE%D0%BF%D0%BB%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%89%D0%B8%D0%BA%D0%B0">INN</a>). 可以适用于国际旅馆的个人和法律版本</p>
<div class="dlist">
<dl>
<dt class="hdlist1">支持的数据类型</dt>
<dd>
<p><code>CharSequence</code></p>
</dd>
<dt class="hdlist1">Hibernate 元数据影响</dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">Country</dt>
<dd>
<p>Russia</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在某些情况下，Jakarta Bean Validation 约束和 Hibernate Validator提供的自定义约束都不能满足您的需求。在这种情况下，您可以很容易地编写自己的约束。你可以 <a href="#validator-customconstraints">Chapter 6, <em>自定义约束</em></a> 中找到更多信息。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-method-constraints"><a class="anchor" href="#chapter-method-constraints"></a>3. 声明和校验 method 约束</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从 Bean Validation 1.1 开始，约束不仅应用于 JavaBeans 中的变量及其 Getter 方法 ,还可以应用于 Java 方法的返回值和构造函数的参数。同样也是使用 Jakarta Bean Validation 约束来指定。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在调用方法或构造函数之前（对可执行方法的输入参数施加约束），可以保证调用者必须满足的前提条件</p>
</li>
<li>
<p>在方法或构造函数调用返回后（通过将约束应用于可执行方法的返回值），可以保证调用方可以保证的后置条件</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于本参考指南，<em>method constraint(方法约束)</em> 既指方法约束，也指构造函数约束，如果没有另行说明的话。有时，在引用方法和构造函数时会使用术语 <em>executable(可执行方法)</em>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与传统的检查参数和返回值正确性的方法相比，这种方法有几个优点:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>检查不必手动执行(例如通过引发 <code>IllegalArgumentException</code> 或类似的异常) ，从而减少了需要编写和维护的代码</p>
</li>
<li>
<p>可执行方法的输入、返回约束不必在其文档中重新表示，因为约束注解将自动包含在生成的 JavaDoc 中。这样可以避免冗余，并减少实现和文档之间不一致的可能性</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了使注解显示在被注解元素的 JavaDoc 中，注解类型本身必须使用元注解 @Documented 来注解。所有内置约束都标注了该注解，并且被认为是任何自定义约束的最佳实践。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在本章剩下的部分中，您将学习如何声明输入参数和返回值约束，以及如何使用 <code>ExecutableValidator</code> API 校验它们。</p>
</div>
<div class="sect2">
<h3 id="section-declaring-method-constraints"><a class="anchor" href="#section-declaring-method-constraints"></a>3.1. 声明 method 约束</h3>
<div class="sect3">
<h4 id="_参数约束"><a class="anchor" href="#_参数约束"></a>3.1.1. 参数约束</h4>
<div class="paragraph">
<p>您可以通过向方法或构造函数的输入参数添加约束注解来指定方法或构造函数的前置条件，如 <a href="#example-declaring-parameter-constraints">Example 27, &#8220;声明方法和构造函数参数约束&#8221;</a>。</p>
</div>
<div id="example-declaring-parameter-constraints" class="exampleblock">
<div class="title">Example 27. 声明方法和构造函数参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.parameter;

public class RentalStation {

	public RentalStation(@NotNull String name) {
		//...
	}

	public void rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里表示了以下先决条件:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RentalCar</code> 构造函数中 <code>name</code> 字段不能为 <code>null</code></p>
</li>
<li>
<p>当调用 <code>rentCar()</code> 方法时,  <code>customer</code> 字段不能为 <code>null</code>, <code>startDate</code> 字段不能为 <code>null</code> 且为将来的时间， <code>durationInDays</code> 字段的最小值为1。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，声明方法或构造函数约束本身并不会在调用该方法时自动导致它们的进行校验。相反，必须使用 <code>ExecutableValidator</code> API (see
<a href="#section-validating-executable-constraints">Section 3.2, &#8220;校验 method 约束&#8221;</a>) 来执行校验，底层的实现方法通常使用方法拦截工具(如 AOP、代理对象等)来完成。</p>
</div>
<div class="paragraph">
<p>约束只能应用于实例方法，即不支持在静态方法上声明约束。根据您用于触发方法校验的拦截技术，可能会适用其他限制，例如，关于被支持作为拦截目标的方法的可见性。请参阅拦截技术的文档以查明是否存在任何此类限制。</p>
</div>
<div class="sect4">
<h5 id="_交叉参数约束"><a class="anchor" href="#_交叉参数约束"></a>3.1.1.1. 交叉参数约束</h5>
<div class="paragraph">
<p>有时，一次校验不仅依赖于单个参数，而是依赖于方法或构造函数的多个甚至全部参数。这种需求可以通过交叉参数约束来实现。</p>
</div>
<div class="paragraph">
<p>交叉参数约束可视为等价于类级约束的方法校验。两者都可用于实现基于几个元素的校验需求。不同之处在于类级别约束适用于 bean 的多个属性，但交叉参数约束适用于可执行方法的多个参数。</p>
</div>
<div class="paragraph">
<p>与单参数约束不同，交叉参数约束是在方法或构造函数上声明的，如 <a href="#example-using-cross-parameter-constraint">Example 28, &#8220;声明交叉参数约束&#8221;</a> 。这里使用了 <code>load()</code> 方法中声明的交叉参数约束 <code>@LuggageCountMatchesPassengerCount</code> ，以确保旅客的行李不超过两件。</p>
</div>
<div id="example-using-cross-parameter-constraint" class="exampleblock">
<div class="title">Example 28. 声明交叉参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.crossparameter;

public class Car {

	@LuggageCountMatchesPassengerCount(piecesOfLuggagePerPassenger = 2)
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正如您将在下一节中了解到的，返回值约束也是在方法级别声明的。为了区分跨参数约束和返回值约束，在自定义约束注解的实现校验器 <code>ConstraintValidator</code> 上，标注 <code>@SupportedValidationTarget</code> 注解。您可以参阅
<a href="#section-cross-parameter-constraints">Section 6.3, &#8220;交叉参数约束&#8221;</a> ，该节展示了如何实现自己的交叉参数约束。</p>
</div>
<div class="paragraph">
<p>在某些情况下，约束即可以应用于可执行方法的参数(即它是一个交叉参数约束) ，也可以应用于返回值。例如，允许使用表达式或脚本语言指定校验规则的自定义约束。</p>
</div>
<div class="paragraph">
<p>这样的约束必须定义一个成员 <code>validationAppliesTo()</code> ，它可以在声明时用于指定约束目标。如<a href="#example-specifying-constraint-target">Example 29, &#8220;指定约束的目标&#8221;</a> 通过指定
<code>validationAppliesTo = ConstraintTarget.PARAMETERS</code>, 将约束应用于可执行方法的输入参数校验，而 <code>ConstraintTarget.RETURN_VALUE</code>  用于将约束应用于可执行方法的返回值校验。</p>
</div>
<div id="example-specifying-constraint-target" class="exampleblock">
<div class="title">Example 29. 指定约束的目标</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.crossparameter.constrainttarget;

public class Garage {

	@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
	public Car buildCar(List&lt;Part&gt; parts) {
		//...
		return null;
	}

	@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.RETURN_VALUE)
	public Car paintCar(int color) {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管这种约束既适用于可执行方法的参数和返回值，但目标方法通常可以自动推断。如果出现下面几种情况，就可以确定作用对象</p>
</div>
<div class="ulist">
<ul>
<li>
<p>带输入参数，但无返回值函数 (约束作用于输入参数上)</p>
</li>
<li>
<p>无输入参数，但有返回值的函数 (约束作用于返回参数上)</p>
</li>
<li>
<p>既不是方法也不是构造函数，而是字段、参数等 (约束作用于带注解的元素)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这些情况下，您不必指定约束目标。如果它增加了源代码的可读性，仍然建议这样做。如果在无法自动确定约束目标的情况下，也未指定该约束目标，则会引发 <code>ConstraintDeclarationException</code>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_返回值约束"><a class="anchor" href="#_返回值约束"></a>3.1.2. 返回值约束</h4>
<div class="paragraph">
<p>方法或构造函数的返回参数的校验也可以通过添加约束注解来声明，如<a href="#example-declaring-return-value-constraints">Example 30, &#8220;声明方法和构造函数返回值约束&#8221;</a> 。</p>
</div>
<div id="example-declaring-return-value-constraints" class="exampleblock">
<div class="title">Example 30. 声明方法和构造函数返回值约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.returnvalue;

public class RentalStation {

	@ValidRentalStation
	public RentalStation() {
		//...
	}

	@NotNull
	@Size(min = 1)
	public List&lt;@NotNull Customer&gt; getCustomers() {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面是 <code>RentalStation</code> 类声明的约束:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建 <code>RentalStation</code> 对象必须通过 <code>@ValidRentalStation</code> 校验</p>
</li>
<li>
<p><code>getCustomers()</code> 返回值不能为 <code>null</code> ，并且必须至少包含元素( list.size() &gt; 0 )</p>
</li>
<li>
<p><code>getCustomers()</code> 包含的元素( <code>Customer</code> 对象 )不能为 <code>null</code> 对象</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>正如您在上面的示例中看到的，方法返回值校验支持集合元素约束。同样的方法参数校验也支持它们。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_级联校验"><a class="anchor" href="#_级联校验"></a>3.1.3. 级联校验</h4>
<div class="paragraph">
<p>类似于 JavaBeans 属性的级联校验  (see
<a href="#section-object-graph-validation">Section 2.1.6, &#8220;对象图&#8221;</a>), <code>@Valid</code> 注解可用于标记可执行参数和级联校验的返回值。在校验带有 <code>@Valid</code> 注解的输入参数或返回值时，也会校验在输入参数或返回值对象中声明的约束。</p>
</div>
<div class="paragraph">
<p>在 <a href="#example-cascaded-executable-validation">Example 31, &#8220;级联校验标记输入参数和返回值&#8221;</a> 中, <code>Garage#checkCar()</code> 方法的输入参数 <code>car</code> 和构造函数 <code>Garage</code> 一样都会进行级联校验。</p>
</div>
<div id="example-cascaded-executable-validation" class="exampleblock">
<div class="title">Example 31. 级联校验标记输入参数和返回值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Garage {

	@NotNull
	private String name;

	@Valid
	public Garage(String name) {
		this.name = name;
	}

	public boolean checkCar(@Valid @NotNull Car car) {
		//...
		return false;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	public Car(String manufacturer, String licencePlate) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
	}

	//getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在校验 <code>checkCar()</code> 方法的输入参数时, 还将计算传递的 <code>Car</code> 对象的属性上的约束。类似地，在校验 <code>Garage</code>  构造函数的返回值时，将检查 <code>Garage</code> 的 name 字段的 <code>@NotNull</code> 约束。</p>
</div>
<div class="paragraph">
<p>通常，级联校验对可执行方法的工作方式与上一章对 JavaBeans 属性的工作方式完全相同。</p>
</div>
<div class="paragraph">
<p>特别是，在级联校验过程中忽略 <code>null</code> (当然在构造函数返回值校验过程中不会发生这种情况) ，并且级联校验是递归执行的，例如，如果标记为级联校验的参数或返回值对象本身的属性标记为 <code>@Valid</code> ，那么在被引用元素上声明的约束也将得到校验。</p>
</div>
<div class="paragraph">
<p>与字段和属性一样，还可以对返回值和输入参数的容器元素(例如集合元素、映射或自定义容器)声明级联校验。</p>
</div>
<div class="paragraph">
<p>在这种情况下，将校验容器中包含的每个元素。在校验
<a href="#example-cascaded-executable-validation-container-elements">Example 32, &#8220;标记为级联校验的方法参数的容器元素&#8221;</a> 中的 <code>checkCars()</code> 方法的输入参数时, 将对列表里的每一个 <code>Car</code> 实例进行校验，并在校验失败的情况下创建 <code>ConstraintViolation</code> 对象。</p>
</div>
<div id="example-cascaded-executable-validation-container-elements" class="exampleblock">
<div class="title">Example 32. 标记为级联校验的方法参数的容器元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.cascaded.containerelement;

public class Garage {

	public boolean checkCars(@NotNull List&lt;@Valid Car&gt; cars) {
		//...
		return false;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-method-constraints-inheritance-hierarchies"><a class="anchor" href="#section-method-constraints-inheritance-hierarchies"></a>3.1.4. 继承层次中的方法约束</h4>
<div class="paragraph">
<p>在继承层次结构中声明方法约束时，注意以下规则非常重要:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法的调用方要满足的输入参数不能在子类的重写方法中加强</p>
</li>
<li>
<p>保证给方法的调用方的输出参数不能在子类的重写方法中弱化</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些规则是由 <em>behavioral subtyping</em> 的概念驱动的，它要求在任何使用 <code>T</code> 类型的地方， 用 <code>T</code> 的 <em>subType(子类型)</em> <code>S</code> 替换 <code>T</code> 但是不会改变程序的行为。</p>
</div>
<div class="paragraph">
<p>举个例子，假设一个类调用一个静态方法返回 <code>T</code> ，如果该对象的运行时类型是 <code>S</code> ，而 <code>S</code> 加强了输入参数的校验，则客户端类可能无法满足这些前置条件，因为它们不知道这些前置条件。这一规则也被称为 <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov
substitution principle</a>。</p>
</div>
<div class="paragraph">
<p>Jakarta Bean Validation 规范实现了第一个规则，它禁止对重写或实现在超类型(超类或接口)中声明的方法进行参数约束。例
<a href="#example-illegal-parameter-constraints">Example 33, &#8220;子类型中的非法方法参数约束&#8221;</a></p>
</div>
<div id="example-illegal-parameter-constraints" class="exampleblock">
<div class="title">Example 33. 子类型中的非法方法参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public interface Vehicle {

	void drive(@Max(75) int speedInMph);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public class Car implements Vehicle {

	@Override
	public void drive(@Max(55) int speedInMph) {
		//...
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Car#drive()</code> 上面的 <code>@Max</code> 约束是非法的，因为此方法实现了接口方法
<code>Vehicle#drive()</code> 。注意，如果超类的方法本身没有声明任何参数约束，也不允许重写方法上的参数约束。</p>
</div>
<div class="paragraph">
<p>此外，如果一个方法覆盖或实现了在几个并行超类型中声明的方法(例如，两个没有相互扩展的接口，或者一个类和一个没有被该类实现的接口) ，那么在任何涉及的类型中都不能为该方法指定参数约束。 <a href="#example-illegal-parameter-constraints-parallel-types">Example 34, &#8220;层次结构的并行类型中的非法方法参数约束&#8221;</a> 违反了该规则。  <code>RacingCar#drive()</code> 重写了 <code>Vehicle#drive()</code> 和 <code>Car#drive()</code> 方法。
所以 <code>RacingCar#drive()</code> 是非法的。</p>
</div>
<div class="paragraph">
<p><mark>(译者注：原文档所写 Vehicle#drive() 是非法的，译者认为此出存在笔误。)</mark></p>
</div>
<div id="example-illegal-parameter-constraints-parallel-types" class="exampleblock">
<div class="title">Example 34. 层次结构的并行类型中的非法方法参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Vehicle {

	void drive(@Max(75) int speedInMph);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Car {

	void drive(int speedInMph);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public class RacingCar implements Car, Vehicle {

	@Override
	public void drive(int speedInMph) {
		//...
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面描述的限制规则只适用于输入参数约束。相反，返回值约束可以添加到重写或实现任何超类方法的方法上。</p>
</div>
<div class="paragraph">
<p>在这种情况下，所有方法的返回值约束都适用于子类型方法，即子类型方法本身上声明的约束，以及重写/实现的超类型方法上的任何返回值约束。这是合法的，因为增加额外的回报值约束可能永远不会削弱方法调用者得到的后置条件保证。</p>
</div>
<div class="paragraph">
<p>在 <a href="#example-return-value-constraints-in-hierarchy">Example 35, &#8220;超类型和子类型方法的返回值约束&#8221;</a> 中，校验 <code>Car#getPassengers()</code> 方法的返回值， <code>@Size</code> 方法也会在重写的 <code>Vehicle#getPassengers()</code> 的返回值被校验。</p>
</div>
<div id="example-return-value-constraints-in-hierarchy" class="exampleblock">
<div class="title">Example 35. 超类型和子类型方法的返回值约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public interface Vehicle {

	@NotNull
	List&lt;Person&gt; getPassengers();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public class Car implements Vehicle {

	@Override
	@Size(min = 1)
	public List&lt;Person&gt; getPassengers() {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果校验引擎检测到违反了上述任何规则，则将抛出
<code>ConstraintDeclarationException</code> 异常</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本节中描述的规则只适用于方法，而不适用于构造函数。根据定义，构造函数永远不会重写超类型构造函数。因此，在校验构造函数调用的参数或返回值时，只应用构造函数本身声明的约束，而不应用超类型构造函数声明的任何约束。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在创建 Validator 实例之前，可以通过设置  <code>MethodValidationConfiguration</code> 的   <code>HibernateValidatorConfiguration</code> 属性中包含的配置参数来放松这些规则的实施。 参见 <a href="#section-method-validation-prerequisite-relaxation">Section 12.3, &#8220;放宽类层次中方法校验的要求&#8221;</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-validating-executable-constraints"><a class="anchor" href="#section-validating-executable-constraints"></a>3.2. 校验 method 约束</h3>
<div class="paragraph">
<p>方法约束的校验使用 <code>ExecutableValidator</code> 接口完成。</p>
</div>
<div class="paragraph">
<p>在 <a href="#section-obtaining-executable-validator">Section 3.2.1, &#8220;获取 <code>ExecutableValidator</code> 实例&#8221;</a> 你将学会如何掌握一个 <code>ExecutableValidator</code>
实例。 在 <a href="#section-executable-validator-methods">Section 3.2.2, &#8220;<code>ExecutableValidator</code> 的方法&#8221;</a> 展示了如何使用这个接口定义的不同方法。</p>
</div>
<div class="paragraph">
<p><code>ExecutableValidator</code> 不是直接从应用程序代码中调用需要校验方法，而是通过方法拦截技术(如 AOP、代理对象等)调用它们。这将导致在方法或构造函数调用时自动和透明地校验可执行约束。通常，integration 层在违反任何约束时都会引发 <code>ConstraintViolationException</code> 。</p>
</div>
<div class="sect3">
<h4 id="section-obtaining-executable-validator"><a class="anchor" href="#section-obtaining-executable-validator"></a>3.2.1. 获取 <code>ExecutableValidator</code> 实例</h4>
<div class="paragraph">
<p>可以通过 <code>Validator#forExecutables()</code> 检索 <code>ExecutableValidator</code> 实例，如
<a href="#example-obtaining-executable-validator">Example 36, &#8220;获取 <code>ExecutableValidator</code> 实例&#8221;</a> 。</p>
</div>
<div id="example-obtaining-executable-validator" class="exampleblock">
<div class="title">Example 36. 获取 <code>ExecutableValidator</code> 实例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
executableValidator = factory.getValidator().forExecutables();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，方法校验器是从默认校验器工厂(default validator factory)获取的，但是如果需要做相关配置的话，您可以阅读
<a href="#chapter-bootstrapping">Chapter 9, <em>Bootstrapping</em></a> 。例如，为了使用特定的参数名称提供器
(参见 <a href="#section-parameter-name-provider">Section 9.2.4, &#8220;<code>ParameterNameProvider</code>&#8221;</a>)。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-executable-validator-methods"><a class="anchor" href="#section-executable-validator-methods"></a>3.2.2. <code>ExecutableValidator</code> 的方法</h4>
<div class="paragraph">
<p><code>ExecutableValidator</code> 接口提供了四种方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>validateParameters()</code> 和 <code>validateReturnValue()</code> 用于方法的校验</p>
</li>
<li>
<p><code>validateConstructorParameters()</code> 和 <code>validateConstructorReturnValue()</code> 用于构造函数的校验</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>和 <code>Validator</code> 的方法一样,所有这些方法都返回一个 <code>Set&lt;ConstraintViolation&gt;</code> ，它包含每个违反的约束的  <code>ConstraintViolation</code> ，如果校验成功，该返回值将为空 Set 。此外，所有方法都有一个可变长 groups 参数，您可以通过该参数传递要进行校验的校验组。</p>
</div>
<div class="paragraph">
<p>以下部分中的示例基于 <a href="#example-executable-validator-class-car">Example 37, &#8220;<code>Car</code> 使用约束方法和构造函数&#8221;</a> 中的 <code>Car</code> 类。</p>
</div>
<div id="example-executable-validator-class-car" class="exampleblock">
<div class="title">Example 37. <code>Car</code> 使用约束方法和构造函数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.validation;

public class Car {

	public Car(@NotNull String manufacturer) {
		//...
	}

	@ValidRacingCar
	public Car(String manufacturer, String team) {
		//...
	}

	public void drive(@Max(75) int speedInMph) {
		//...
	}

	@Size(min = 1)
	public List&lt;Passenger&gt; getPassengers() {
		//...
		return Collections.emptyList();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_executablevalidatorvalidateparameters"><a class="anchor" href="#_executablevalidatorvalidateparameters"></a>3.2.2.1. <code>ExecutableValidator#validateParameters()</code></h5>
<div class="paragraph">
<p><code>validateParameters()</code> 法用于校验方法调用的参数。在
<a href="#example-executable-validator-validate-parameters">Example 38, &#8220;使用 <code>ExecutableValidator#validateParameters()</code>&#8221;</a> 中 <code>drive()</code> 方法违法了 <code>@Max</code> 约束。</p>
</div>
<div id="example-executable-validator-validate-parameters" class="exampleblock">
<div class="title">Example 38. 使用 <code>ExecutableValidator#validateParameters()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters(
		object,
		method,
		parameterValues
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( Max.class, constraintType );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意 <code>validateParameters()</code> 校验方法的所有参数约束，即包括单个参数的约束以及交叉参数约束。</p>
</div>
</div>
<div class="sect4">
<h5 id="_executablevalidatorvalidatereturnvalue"><a class="anchor" href="#_executablevalidatorvalidatereturnvalue"></a>3.2.2.2. <code>ExecutableValidator#validateReturnValue()</code></h5>
<div class="paragraph">
<p>使用 <code>validateReturnValue()</code> 可以校验方法的返回值。在
<a href="#example-executable-validator-validate-return-value">Example 39, &#8220;使用 <code>ExecutableValidator#validateReturnValue()</code>&#8221;</a> 产生一个约束冲突，因为 <code>getPassengers()</code> 方法需要至少返回一个 <code>Passenger</code> 实例。</p>
</div>
<div id="example-executable-validator-validate-return-value" class="exampleblock">
<div class="title">Example 39. 使用 <code>ExecutableValidator#validateReturnValue()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "getPassengers" );
Object returnValue = Collections.&lt;Passenger&gt;emptyList();
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateReturnValue(
		object,
		method,
		returnValue
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( Size.class, constraintType );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_executablevalidatorvalidateconstructorparameters"><a class="anchor" href="#_executablevalidatorvalidateconstructorparameters"></a>3.2.2.3. <code>ExecutableValidator#validateConstructorParameters()</code></h5>
<div class="paragraph">
<p>使用 <code>validateConstructorParameters()</code> 校验构造函数调用的参数，如<a href="#example-executable-validator-validate-constructor-parameters">Example 40, &#8220;使用 <code>ExecutableValidator#validateConstructorParameters()</code>&#8221;</a>. 因为 <code>manufacturer</code> 字段的 <code>@NotNull</code> 约束，校验调用返回一个约束冲突。</p>
</div>
<div id="example-executable-validator-validate-constructor-parameters" class="exampleblock">
<div class="title">Example 40. 使用 <code>ExecutableValidator#validateConstructorParameters()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class );
Object[] parameterValues = { null };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateConstructorParameters(
		constructor,
		parameterValues
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( NotNull.class, constraintType );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_executablevalidatorvalidateconstructorreturnvalue"><a class="anchor" href="#_executablevalidatorvalidateconstructorreturnvalue"></a>3.2.2.4. <code>ExecutableValidator#validateConstructorReturnValue()</code></h5>
<div class="paragraph">
<p>最后，通过使用 <code>validateConstructorReturnValue()</code> ，可以校验构造函数的返回值。
<a href="#example-executable-validator-validate-constructor-return-value">Example 41, &#8220;使用 <code>ExecutableValidator#validateConstructorReturnValue()</code>&#8221;</a>, <code>validateConstructorReturnValue()</code>
返回一个约束冲突，因为构造函数返回的 <code>Car</code> 实例不满足 <code>@ValidRacingCar</code>  约束。</p>
</div>
<div id="example-executable-validator-validate-constructor-return-value" class="exampleblock">
<div class="title">Example 41. 使用 <code>ExecutableValidator#validateConstructorReturnValue()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">//constructor for creating racing cars
Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class, String.class );
Car createdObject = new Car( "Morris", null );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateConstructorReturnValue(
		constructor,
		createdObject
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( ValidRacingCar.class, constraintType );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_校验方法的结果_constraintviolation"><a class="anchor" href="#_校验方法的结果_constraintviolation"></a>3.2.3. 校验方法的结果 <code>ConstraintViolation</code></h4>
<div class="paragraph">
<p>除了 <a href="#section-constraint-violation-methods">Section 2.2.3, &#8220;<code>ConstraintViolation</code>&#8221;</a> 介绍的方法之外，<code>ConstraintViolation</code> 还提供了另外两个特定于校验可执行参数和返回值的方法。</p>
</div>
<div class="paragraph">
<p><code>ConstraintViolation#getExecutableParameters()</code> 在方法或构造函数参数校验的情况下返回校验过的参数数组 ， 而 <code>ConstraintViolation#getExecutableReturnValue()</code>
在返回值校验的情况下提供对校验对象的访问。</p>
</div>
<div class="paragraph">
<p><code>ConstraintViolation</code> 所有其他方法通常都以校验 bean 的方式一样。</p>
</div>
<div class="paragraph">
<p>注意 <code>getPropertyPath()</code> 对于获取有关校验参数或返回值的详细信息非常有用，例如用于日志记录。特别是，您可以从路径节点检索相关方法的名称和参数类型以及相关参数的索引。<a href="#example-executable-validation-property-path">Example 42, &#8220;检索方法和参数信息&#8221;</a> 中显示了如何做到这一点。</p>
</div>
<div id="example-executable-validation-property-path" class="exampleblock">
<div class="title">Example 42. 检索方法和参数信息</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters(
		object,
		method,
		parameterValues
);

assertEquals( 1, violations.size() );
Iterator&lt;Node&gt; propertyPath = violations.iterator()
		.next()
		.getPropertyPath()
		.iterator();

MethodNode methodNode = propertyPath.next().as( MethodNode.class );
assertEquals( "drive", methodNode.getName() );
assertEquals( Arrays.&lt;Class&lt;?&gt;&gt;asList( int.class ), methodNode.getParameterTypes() );

ParameterNode parameterNode = propertyPath.next().as( ParameterNode.class );
assertEquals( "speedInMph", parameterNode.getName() );
assertEquals( 0, parameterNode.getParameterIndex() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>参数名称是使用当前的 <code>ParameterNameProvider</code> (参见
<a href="#section-parameter-name-provider">Section 9.2.4, &#8220;<code>ParameterNameProvider</code>&#8221;</a>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-builtin-method-constraints"><a class="anchor" href="#section-builtin-method-constraints"></a>3.3. 内置 method 约束</h3>
<div class="paragraph">
<p>除了 <a href="#section-builtin-constraints">Section 2.3, &#8220;内置约束&#8221;</a> 中讨论的内置 bean 和属性级约束之外，Hibernate Validator 目前还提供了一个方法级约束 <code>@ParameterScriptAssert</code> 这是一个通用的交叉参数约束，它允许使用任何与 JSR 223兼容(“ Java <sup>TM</sup> 平台的脚本编写”)的脚本语言实现校验例程，前提是在类路径中可以使用这种语言的引擎。</p>
</div>
<div class="paragraph">
<p>若要从表达式内引用可执行方法的参数，请使用从激活的参数名称提供者获得的参数名称 (see <a href="#section-parameter-name-provider">Section 9.2.4, &#8220;<code>ParameterNameProvider</code>&#8221;</a>).
<a href="#example-parameterscriptassert">Example 43, &#8220;使用 <code>@ParameterScriptAssert</code>&#8221;</a> 示了如何在 <code>@LuggageCountMatchesPassengerCount</code>
的帮助下表示 <a href="#example-using-cross-parameter-constraint">Example 28, &#8220;声明交叉参数约束&#8221;</a> 的 <code>@ParameterScriptAssert</code> 约束的校验逻辑。</p>
</div>
<div id="example-parameterscriptassert" class="exampleblock">
<div class="title">Example 43. 使用 <code>@ParameterScriptAssert</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter03.parameterscriptassert;

public class Car {

	@ParameterScriptAssert(lang = "javascript", script = "luggage.size() &lt;= passengers.size() * 2")
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-message-interpolation"><a class="anchor" href="#chapter-message-interpolation"></a>4. 添加约束错误消息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>消息插值是违反 Jakarta Bean Validation 约束后创建错误消息的过程。在本章中，您将学习如何定义和解析这些消息，以及如何在默认算法不足以满足需求的情况下插入自定义消息插入器。</p>
</div>
<div class="sect2">
<h3 id="section-message-interpolation"><a class="anchor" href="#section-message-interpolation"></a>4.1. 默认消息插值</h3>
<div class="paragraph">
<p>违反约束的消息是从所谓的消息descriptors(描述器)中检索的。每个约束都定义了它们自己其默认消息descriptors(描述器)。在声明时，默认descriptors(描述器)可以被特定的值覆盖，如 <a href="#example-overriding-message">Example 44, &#8220;使用消息属性指定消息描述符&#8221;</a>.</p>
</div>
<div id="example-overriding-message" class="exampleblock">
<div class="title">Example 44. 使用消息属性指定消息描述符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter04;

public class Car {

	@NotNull(message = "The manufacturer name must not be null")
	private String manufacturer;

	//constructor, getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果违反了相关约束注解，将由validation引擎使用当前配置的 <code>MessageInterpolator</code> 进行消息的构建。然后通过调用 <code>ConstraintViolation#getMessage()</code> 方法可以获取结果。</p>
</div>
<div class="paragraph">
<p>消息描述符可以包含 <em>message parameters(消息参数)</em> 以及在插值期间将要解析的 <em>message expressions(消息表达式)</em> 。消息参数是封闭在 <code>{}</code> 中的字符串，而消息表达式是封闭在 <code>${}</code> 中的字符串。在方法插值过程中应用了以下算法:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将 <em>message parameters(消息参数)</em> 作为键值(key)在资源包 <em>ValidationMessages</em> 中检索value值。 如果这个资源包包含给定 <em>message parameters(消息参数)</em> ，那么该参数的value将替换在消息中的 <em>message parameters(消息参数)</em> 。如果替换的值再次包含消息参数，将递归地执行此步骤。资源包应该由应用程序开发人员提供，例如，通过将名为 <em>ValidationMessages.properties</em> 的文件添加到 classpath 中。您还可以通过提供此包的特定于国家的语言文件(如 <em>ValidationMessages_en_US.properties</em> )来创建本地化的错误消息。默认情况下，在包中查找消息时将使用 JVM 的默认语言环境( <code>Locale#getDefault()</code> )。</p>
</li>
<li>
<p>通过将任何消息参数用作包含 Jakarta Bean Validation规范附录 B 中定义的内置约束的标准错误消息的资源包的键来解析它们。对于 Hibernate Validator，这个绑定包名为 <code>org.hibernate.validator.ValidationMessages</code> 。如果此步骤触发替换，则再次执行步骤1，否则应用步骤3。</p>
</li>
<li>
<p>通过将任何消息参数替换为具有相同名称的约束注解成员的值来解析它们。这允许在错误消息 (例如"must be at least ${ min }") 中引用约束的属性值(例如 <code>Size#min()</code>)。</p>
</li>
<li>
<p>通过将任何消息表达式计算为统一表达式语言表达式来解析它们。请参阅<a href="#section-interpolation-with-message-expressions">Section 4.1.2, &#8220;带有消息表达式的插值&#8221;</a> 了解有关在错误消息中使用统一 EL 的更多信息。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以在 Jakarta Bean Validation 规范的6.3.1.1节中找到插值算法的形式化定义。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="section-special-characters"><a class="anchor" href="#section-special-characters"></a>4.1.1. 特殊字符</h4>
<div class="paragraph">
<p>由于字符 <code>{</code>, <code>}</code> 和 <code>$</code> 在消息描述符中具有特殊的含义，如果要按字面意思使用它们，就需要对它们进行转义。以下规则适用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>\{</code> 代表字符 <code>{</code></p>
</li>
<li>
<p><code>\}</code> 代表字符 <code>}</code></p>
</li>
<li>
<p><code>\$</code> 代表字符 <code>$</code></p>
</li>
<li>
<p><code>\\</code> 代表字符 <code>\</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="section-interpolation-with-message-expressions"><a class="anchor" href="#section-interpolation-with-message-expressions"></a>4.1.2. 带有消息表达式的插值</h4>
<div class="paragraph">
<p>从 Hibernate Validator 5 (Bean Validation 1.1) 开始，可以在违反约束的消息中使用
<a href="https://projects.eclipse.org/projects/ee4j.el">Jakarta Expression Language</a> 。这允许基于条件逻辑定义错误消息，还支持高级格式化输出。验证引擎使以下对象在 EL 上下文中可用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过约束的属性名称映射到配置的值</p>
</li>
<li>
<p><em>validatedValue</em> 表式的当前验证的值(属性、 bean、方法参数等)</p>
</li>
<li>
<p>也可以用 <code>format(String format, Object…​ args)</code> 格式化输出，它的行为类似于 <code>java.util.Formatter.format(String format, Object&#8230;&#8203; args)</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Expression Language非常灵活，Hibernate Validator 提供了几个特性级别，您可以通过 <code>ExpressionLanguageFeatureLevel</code> 这个枚举来启用不同等级表达式语言特性:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code>: Expression Language 插值完全禁用。</p>
</li>
<li>
<p><code>VARIABLES</code>: 允许通过 <code>addExpressionVariable()</code>, 资源包 和  <code>formatter</code> 对象.</p>
</li>
<li>
<p><code>BEAN_PROPERTIES</code>: 除了 <code>VARIABLES</code> 允许的还包括插入bean的属性(Getter方法)。</p>
</li>
<li>
<p><code>BEAN_METHODS</code>: 还允许使用可执行方法的返回值。对于硬编码的约束消息可以认为是安全的，但是对于需要额外注意的 <a href="#section-hibernateconstraintvalidatorcontext">custom violations</a> (自定义约束)。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>约束消息的默认特性级别是 <code>BEAN_PROPERTIES</code>。</p>
</div>
<div class="paragraph">
<p>你也可以在启动的时候设置级别 <a href="#el-features">bootstrapping the <code>ValidatorFactory</code></a>.</p>
</div>
<div class="paragraph">
<p>以下部分提供了在错误消息中使用 EL 表达式的几个示例：</p>
</div>
</div>
<div class="sect3">
<h4 id="_示例"><a class="anchor" href="#_示例"></a>4.1.3. 示例</h4>
<div class="paragraph">
<p><a href="#example-message-descriptors">Example 45, &#8220;指定消息descriptors(描述符)&#8221;</a> 展示了如何使用不同的选项来指定消息descriptors(描述符)。</p>
</div>
<div id="example-message-descriptors" class="exampleblock">
<div class="title">Example 45. 指定消息descriptors(描述符)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter04.complete;

public class Car {

	@NotNull
	private String manufacturer;

	@Size(
			min = 2,
			max = 14,
			message = "The license plate '${validatedValue}' must be between {min} and {max} characters long"
	)
	private String licensePlate;

	@Min(
			value = 2,
			message = "There must be at least {value} seat${value &gt; 1 ? 's' : ''}"
	)
	private int seatCount;

	@DecimalMax(
			value = "350",
			message = "The top speed ${formatter.format('%1$.2f', validatedValue)} is higher " +
					"than {value}"
	)
	private double topSpeed;

	@DecimalMax(value = "100000", message = "Price must not be higher than ${value}")
	private BigDecimal price;

	public Car(
			String manufacturer,
			String licensePlate,
			int seatCount,
			double topSpeed,
			BigDecimal price) {
		this.manufacturer = manufacturer;
		this.licensePlate = licensePlate;
		this.seatCount = seatCount;
		this.topSpeed = topSpeed;
		this.price = price;
	}

	//getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>校验这个无效的 <code>Car</code> 实例会产生以下违反约束的行为，用该单元测试验证 <a href="#example-expected-error-messages">Example 46, &#8220;判断是否为预期的错误消息&#8221;</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>manufacturer</code> 字段的 <code>@NotNull</code> 约束将输出错误信息 "must not be null" ，这是由的Jakarta Bean Validation 规范定义的，加之你没有特殊的指定输出信息。</p>
</li>
<li>
<p><code>licensePlate</code> 字段的 <code>@Size</code> 约束，展示如何使用 <em>message parameters(消息参数)</em>  (<code>{min}</code>, <code>{max}</code>) 以及如何添加当前校验值，通过EL表达式: <code>${validatedValue}</code>。</p>
</li>
<li>
<p><code>seatCount</code> 字段的 <code>@Min</code> 约束，演示了如何使用带有三元表达式的 EL 表达式动态选择单数或复数形式，这取决于约束的属性("There must
be at least 1 seat" vs. "There must be at least 2 seats")</p>
</li>
<li>
<p><code>topSpeed</code> 字段的 <code>@DecimalMax</code> 展示了如何使用格式化(formatter.format)程序实例输出已验证的值</p>
</li>
<li>
<p>最后，<code>price</code> 字段的 <code>@DecimalMax</code> 约束展示了参数插值优先于表达式求值声明，也就是 <code>$</code> 符号显示在最大价格前面</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只有实际的约束属性可以使用格式 <code>{attributeName}</code>
。当引用添加到插值上下文中的验证值或自定义表达式变量时(参见  <a href="#section-hibernateconstraintvalidatorcontext">Section 12.13.1, &#8220;<code>HibernateConstraintValidatorContext</code>&#8221;</a>), 必须使用形式为 <code>${attributeName}</code> 的 EL 表达式。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-expected-error-messages" class="exampleblock">
<div class="title">Example 46. 判断是否为预期的错误消息</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Car car = new Car( null, "A", 1, 400.123456, BigDecimal.valueOf( 200000 ) );

String message = validator.validateProperty( car, "manufacturer" )
		.iterator()
		.next()
		.getMessage();
assertEquals( "must not be null", message );

message = validator.validateProperty( car, "licensePlate" )
		.iterator()
		.next()
		.getMessage();
assertEquals(
		"The license plate 'A' must be between 2 and 14 characters long",
		message
);

message = validator.validateProperty( car, "seatCount" ).iterator().next().getMessage();
assertEquals( "There must be at least 2 seats", message );

message = validator.validateProperty( car, "topSpeed" ).iterator().next().getMessage();
assertEquals( "The top speed 400.12 is higher than 350", message );

message = validator.validateProperty( car, "price" ).iterator().next().getMessage();
assertEquals( "Price must not be higher than $100000", message );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-custom-message-interpolation"><a class="anchor" href="#section-custom-message-interpolation"></a>4.2. 自定义消息插值</h3>
<div class="paragraph">
<p>如果默认的消息插值算法不符合您的要求，也可以自己实现一个 <code>MessageInterpolator</code> 。</p>
</div>
<div class="paragraph">
<p>自定义插值器必须实现接口 <code>jakarta.validation.MessageInterpolator</code>。 注意，您的实现必须是线程安全的。建议自定义消息内插器将最终实现委托给缺省的内插器，可以通过
<code>Configuration#getDefaultMessageInterpolator()</code> 获取。</p>
</div>
<div class="paragraph">
<p>为了使用自定义消息插入器，必须在 Jakarta Bean Validation XML 配置文件 <em>META-INF/validation.xml</em> (参见 <a href="#section-configuration-validation-xml">Section 8.1, &#8220;配置 validator factory 通过 <em>validation.xml</em>&#8221;</a>) 中配置它，或者启动过程中配置 <code>ValidatorFactory</code> 或 <code>Validator</code> 时传递它 (参见 <a href="#section-validator-factory-message-interpolator">Section 9.2.1, &#8220;<code>MessageInterpolator</code>&#8221;</a> 和 <a href="#section-configuring-validator">Section 9.3, &#8220;配置Validator&#8221;</a>, respectively).</p>
</div>
<div class="sect3">
<h4 id="section-resource-bundle-locator"><a class="anchor" href="#section-resource-bundle-locator"></a>4.2.1. <code>ResourceBundleLocator</code></h4>
<div class="paragraph">
<p>在某些用例中，您希望使用 Bean Validation 规范定义的消息插值算法，但是从 <em>ValidationMessages</em> 以外的其他资源包中检索错误消息。在这种情况下 Hibernate Validator 的 <code>ResourceBundleLocator</code> SPI 可以提供帮助。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 中的缺省消息内插器 <code>ResourceBundleMessageInterpolator</code> 通过 SPI 技术检索具体的实现。在启动加载程序 <code>ValidatorFactory</code> 时，使用替代的资源包只需要传递一个具有资源包 <code>PlatformResourceBundleLocator</code> 实例的名称，如 <a href="#example-using-specific-resource-bundle-locator">Example 47, &#8220;使用特定的资源包&#8221;</a>.</p>
</div>
<div id="example-using-specific-resource-bundle-locator" class="exampleblock">
<div class="title">Example 47. 使用特定的资源包</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator(
				new ResourceBundleMessageInterpolator(
						new PlatformResourceBundleLocator( "MyMessages" )
				)
		)
		.buildValidatorFactory()
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当然，您也可以实现一个完全不同的 <code>ResourceBundleLocator</code>, 例如，它可以将数据库中的记录作为返回的资源信息。在这种情况下，您可以通过
<code>HibernateValidatorConfiguration#getDefaultResourceBundleLocator()</code> 获得默认locator(定位器)，例如，您可以使用它作为备用数据源。</p>
</div>
<div class="paragraph">
<p>除了 <code>PlatformResourceBundleLocator</code> 之外，Hibernate Validator还提供了另一个资源包locator(定位器)实现，即 <code>AggregateResourceBundleLocator</code> ，它允许从多个资源包检索错误消息。例如，您可以在多模块应用程序中使用此实现，其中每个模块需要一个消息包。<a href="#example-using-aggregate-resource-bundle-locator">Example 48, &#8220;使用 <code>AggregateResourceBundleLocator</code>&#8221;</a> 展示了如何使用 <code>AggregateResourceBundleLocator</code> 。</p>
</div>
<div id="example-using-aggregate-resource-bundle-locator" class="exampleblock">
<div class="title">Example 48. 使用 <code>AggregateResourceBundleLocator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator(
				new ResourceBundleMessageInterpolator(
						new AggregateResourceBundleLocator(
								Arrays.asList(
										"MyMessages",
										"MyOtherMessages"
								)
						)
				)
		)
		.buildValidatorFactory()
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，资源包是按照传递给构造函数的顺序处理的。这意味着，如果多个资源包包含给定消息键的条目，则该值将从包含该键的列表中的第一个资源包中取出。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-groups"><a class="anchor" href="#chapter-groups"></a>5. 分组约束</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前面几章中讨论的 <code>Validator</code> 和 <code>ExecutableValidator</code> 中的所有校验方法都有可变长参数 <code>groups</code> 。到目前为止，我们一直忽略这个参数，但是现在是时候仔细研究一下了。</p>
</div>
<div class="sect2">
<h3 id="_请求分组"><a class="anchor" href="#_请求分组"></a>5.1. 请求分组</h3>
<div class="paragraph">
<p>Groups(分组)允许你在校验的时候限制校验范围，校验分组的一个使用场景是UI导航，其中每个步骤中只有指定的约束子集而得到校验。目标分组作为参数传递给校验方法。</p>
</div>
<div class="paragraph">
<p>让我们来看接下来的这个例子， <a href="#example-person">Example 49, &#8220;实体类 <code>Person</code>&#8221;</a> 中的 <code>Person</code> 类的 <code>name</code> 有一个 <code>@NotNull</code> 注解约束。如果没有特别指定分组，那么会分组为默认的 <code>jakarta.validation.groups.Default</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当校验一个或多个分组的时候，也没有显示的指定分组。那么会被分类至 <code>jakarta.validation.groups.Default</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-person" class="exampleblock">
<div class="title">Example 49. 实体类 <code>Person</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

public class Person {

	@NotNull
	private String name;

	public Person(String name) {
		this.name = name;
	}

	// getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-driver">Example 50, &#8220;Driver类&#8221;</a> 中的 <code>Driver</code> 类继承至 <code>Person</code> 类，同时添加了 <code>age</code> 和 <code>hasDrivingLicense</code> 两个字段。司机必须年满18岁(<code>@Min(18)</code>)并持有驾驶执照( <code>@AssertTrue</code> ) ， 在这些属性上定义的约束都属于 <code>DriverChecks</code> 分组，它只是一个简单的标记接口。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用接口使得组的使用类型安全，并且允许轻松地进行重构。这也意味着组可以通过类继承彼此继承。见 <a href="#section-group-inheritance">Section 5.2, &#8220;分组继承&#8221;</a></p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-driver" class="exampleblock">
<div class="title">Example 50. Driver类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

public class Driver extends Person {

	@Min(
			value = 18,
			message = "You have to be 18 to drive a car",
			groups = DriverChecks.class
	)
	public int age;

	@AssertTrue(
			message = "You first have to pass the driving test",
			groups = DriverChecks.class
	)
	public boolean hasDrivingLicense;

	public Driver(String name) {
		super( name );
	}

	public void passedDrivingTest(boolean b) {
		hasDrivingLicense = b;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

public interface DriverChecks {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后 <code>Car</code> 类(<a href="#example-car">Example 51, &#8220;Car类&#8221;</a>) 具有一些约束，这些约束是默认组的一部分，但是 <code>passedVehicleInspection</code> 字段的 <code>@AssertTrue</code> 约束注解属于 <code>CarChecks</code> 分组，它表示一辆汽车是否通过了道路测试。</p>
</div>
<div id="example-car" class="exampleblock">
<div class="title">Example 51. Car类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

public class Car {
	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	@AssertTrue(
			message = "The car has to pass the vehicle inspection first",
			groups = CarChecks.class
	)
	private boolean passedVehicleInspection;

	@Valid
	private Driver driver;

	public Car(String manufacturer, String licencePlate, int seatCount) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	public boolean isPassedVehicleInspection() {
		return passedVehicleInspection;
	}

	public void setPassedVehicleInspection(boolean passedVehicleInspection) {
		this.passedVehicleInspection = passedVehicleInspection;
	}

	public Driver getDriver() {
		return driver;
	}

	public void setDriver(Driver driver) {
		this.driver = driver;
	}

	// getters and setters ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

public interface CarChecks {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>总的来说，示例中使用了三个不同的组:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Person.name</code>, <code>Car.manufacturer</code>, <code>Car.licensePlate</code> 和 <code>Car.seatCount</code>
字段属于 <code>Default</code> 分组</p>
</li>
<li>
<p><code>Driver.age</code> 和 <code>Driver.hasDrivingLicense</code> 字段属于 <code>DriverChecks</code> 分组</p>
</li>
<li>
<p><code>Car.passedVehicleInspection</code> 字段属于 <code>CarChecks</code> 分组</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#example-drive-away">Example 52, &#8220;使用校验分组&#8221;</a> 展示了如何将不同的组合传递给 <code>Validator#validate()</code>
方法，从而导致不同的校验结果。</p>
</div>
<div id="example-drive-away" class="exampleblock">
<div class="title">Example 52. 使用校验分组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">// create a car and check that everything is ok with it.
Car car = new Car( "Morris", "DD-AB-123", 2 );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
assertEquals( 0, constraintViolations.size() );

// but has it passed the vehicle inspection?
constraintViolations = validator.validate( car, CarChecks.class );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"The car has to pass the vehicle inspection first",
		constraintViolations.iterator().next().getMessage()
);

// let's go to the vehicle inspection
car.setPassedVehicleInspection( true );
assertEquals( 0, validator.validate( car, CarChecks.class ).size() );

// now let's add a driver. He is 18, but has not passed the driving test yet
Driver john = new Driver( "John Doe" );
john.setAge( 18 );
car.setDriver( john );
constraintViolations = validator.validate( car, DriverChecks.class );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"You first have to pass the driving test",
		constraintViolations.iterator().next().getMessage()
);

// ok, John passes the test
john.passedDrivingTest( true );
assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

// just checking that everything is in order now
assertEquals(
		0, validator.validate(
		car,
		Default.class,
		CarChecks.class,
		DriverChecks.class
).size()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-drive-away">Example 52, &#8220;使用校验分组&#8221;</a> 中第一次调用 <code>validate()</code> 方法是在没有显式指定分组的情况下完成的。没有验证错误，即使 <code>passedVehicleInspection</code> 的默认值是 <code>false</code> ，因为在该属性上定义的约束不属于默认组。</p>
</div>
<div class="paragraph">
<p>第二次校验的是 <code>CarChecks</code> 分组，会校验失败除非汽车通过车辆检查(passedVehicleInspection = true)。为汽车添加一个驾驶员，会再次导致校验失败，因为驾驶员尚未通过驾驶考试，只有将 <code>passedDrivingTest</code> 设置为 <code>true</code> 后，对 <code>DriverChecks</code> 的分组才会通过。</p>
</div>
<div class="paragraph">
<p>最后一次调用 <code>validate()</code> 表示所有定义的分组的约束都通过校验。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-group-inheritance"><a class="anchor" href="#section-group-inheritance"></a>5.2. 分组继承</h3>
<div class="paragraph">
<p>在 <a href="#example-drive-away">Example 52, &#8220;使用校验分组&#8221;</a>, 我们需要为每个校验分组调用一次 <code>validate()</code> ， 或者一次性指定他们所有。</p>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望定义一组包含另一组的约束。您可以使用分组继承来实现这一点。</p>
</div>
<div class="paragraph">
<p>在 <a href="#example-supercar">Example 53, &#8220;SuperCar类&#8221;</a>中，我们定义了一个 <code>SuperCar</code> 类和一个 <code>RaceCarChecks</code> 分组，<code>RaceCarChecks</code> 分组继承至 <code>Default</code> 分组。 <code>SuperCar</code> (超级跑车)必须配备安全带才能参加比赛。</p>
</div>
<div id="example-supercar" class="exampleblock">
<div class="title">Example 53. SuperCar类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05.groupinheritance;

public class SuperCar extends Car {

	@AssertTrue(
			message = "Race car must have a safety belt",
			groups = RaceCarChecks.class
	)
	private boolean safetyBelt;

	// getters and setters ...

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05.groupinheritance;

import jakarta.validation.groups.Default;

public interface RaceCarChecks extends Default {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在下面的例子中，我们将校验 <code>SuperCar</code> 在只有一个座位且没有安全带，是否是合格的汽车？是否是合格的竞速车辆？</p>
</div>
<div id="example-group-inheritance" class="exampleblock">
<div class="title">Example 54. 使用分组继承</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">// create a supercar and check that it's valid as a generic Car
SuperCar superCar = new SuperCar( "Morris", "DD-AB-123", 1  );
assertEquals( "must be greater than or equal to 2", validator.validate( superCar ).iterator().next().getMessage() );

// check that this supercar is valid as generic car and also as race car
Set&lt;ConstraintViolation&lt;SuperCar&gt;&gt; constraintViolations = validator.validate( superCar, RaceCarChecks.class );

assertThat( constraintViolations ).extracting( "message" ).containsOnly(
		"Race car must have a safety belt",
		"must be greater than or equal to 2"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在第一次调用 <code>validate()</code> 时，我们不指定分组。有一个验证错误，因为汽车必须至少有一个座位。它是来自 <code>Default</code> 分组的约束。</p>
</div>
<div class="paragraph">
<p>在第二次调用中，我们只指定 <code>RaceCarChecks</code> 分组。有两个验证错误: 一个是 <code>Default</code> 分组的座位缺少，另一个是 <code>RaceCarChecks</code> 分组没有安全带。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-defining-group-sequences"><a class="anchor" href="#section-defining-group-sequences"></a>5.3. 定义分组序列</h3>
<div class="paragraph">
<p>默认情况下，不管约束属于哪个分组，约束都不按特定顺序进行计算。然而，在某些情况下，控制校验约束的顺序是有很用的。</p>
</div>
<div class="paragraph">
<p>在 <a href="#example-drive-away">Example 52, &#8220;使用校验分组&#8221;</a> 中。要求在检查汽车的是否是赛车之前，首先要通过所有默认的汽车约束。最后，在开车离开之前，应该检查实际的驾驶员是否满足约束。</p>
</div>
<div class="paragraph">
<p>为了实现这样的验证顺序，您只需定义一个接口并使用 <code>@GroupSequence</code> 对其进行注解，定义必须验证组的顺序(参见 <a href="#example-defining-group-sequence">Example 55, &#8220;定义一个分组序列&#8221;</a>)。 如果序列组中有一个约束校验失败，序列组中剩下的约束都不能算验证通过。</p>
</div>
<div id="example-defining-group-sequence" class="exampleblock">
<div class="title">Example 55. 定义一个分组序列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

import jakarta.validation.GroupSequence;
import jakarta.validation.groups.Default;

@GroupSequence({ Default.class, CarChecks.class, DriverChecks.class })
public interface OrderedChecks {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>定义序列的组和组成序列的组不能直接或间接地通过级联序列定义或组继承参与循环依赖。如果计算包含这种循环的组，则会引发 <code>GroupDefinitionException</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后您可以在<a href="#example-group-sequence">Example 56, &#8220;使用分组序列&#8221;</a>使用刚刚定义的分组序列。</p>
</div>
<div id="example-group-sequence" class="exampleblock">
<div class="title">Example 56. 使用分组序列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Car car = new Car( "Morris", "DD-AB-123", 2 );
car.setPassedVehicleInspection( true );

Driver john = new Driver( "John Doe" );
john.setAge( 18 );
john.passedDrivingTest( true );
car.setDriver( john );

assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-default-group-class"><a class="anchor" href="#section-default-group-class"></a>5.4. 重新定义默认组序列</h3>
<div class="sect3">
<h4 id="_groupsequence"><a class="anchor" href="#_groupsequence"></a>5.4.1. <code>@GroupSequence</code></h4>
<div class="paragraph">
<p>除了定义分组序列, <code>@GroupSequence</code> 分组还允许为给定的类重新定义默认组。为此，只需将 <code>@GroupSequence</code> 注释添加到类中，并指定在注释中用 <code>Default</code> 替换该类的组的顺序。</p>
</div>
<div class="paragraph">
<p><a href="#example-rental-car">Example 57, &#8220;为 <code>RentalCar</code> 重新定义默认分组&#8221;</a> 介绍将 <code>RentalCar</code> 重新定义默认分组。</p>
</div>
<div id="example-rental-car" class="exampleblock">
<div class="title">Example 57. 为 <code>RentalCar</code> 重新定义默认分组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })
public class RentalCar extends Car {
	@AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
	private boolean rented;

	public RentalCar(String manufacturer, String licencePlate, int seatCount) {
		super( manufacturer, licencePlate, seatCount );
	}

	public boolean isRented() {
		return rented;
	}

	public void setRented(boolean rented) {
		this.rented = rented;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05;

public interface RentalChecks {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-testCarIsRented">Example 58, &#8220;验证具有重定义的默认组的对象&#8221;</a> 当做了上述定义后，当你校验 <code>Default</code> 分组时，会同时 <code>RentalCar</code> 校验中 <code>RentalChecks</code>, <code>CarChecks</code> 分组的约束 。</p>
</div>
<div id="example-testCarIsRented" class="exampleblock">
<div class="title">Example 58. 验证具有重定义的默认组的对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
rentalCar.setPassedVehicleInspection( true );
rentalCar.setRented( true );

Set&lt;ConstraintViolation&lt;RentalCar&gt;&gt; constraintViolations = validator.validate( rentalCar );

assertEquals( 1, constraintViolations.size() );
assertEquals(
		"Wrong message",
		"The car is currently rented out",
		constraintViolations.iterator().next().getMessage()
);

rentalCar.setRented( false );
constraintViolations = validator.validate( rentalCar );

assertEquals( 0, constraintViolations.size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为分组和分组序列定义中不能有循环依赖项，所以不能将 Default 添加到为类重新定义 Default 的序列中。相反，必须添加类本身。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Default</code> 分组序列重写对于在其上定义的类是local(本地)的，不会传播到关联的对象。对于本例，这意味着将 <code>DriverChecks</code> 添加到 <code>RentalCar</code> 的默认组序列中，而不会对其他类产生任何效果。并且只有 <code>Default</code> 分组关联了驾驶员相关注解。</p>
</div>
<div class="paragraph">
<p>请注意，您可以通过声明组转换规则来控制传播的组(
<a href="#section-group-conversion">Section 5.5, &#8220;分组转化&#8221;</a>)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_groupsequenceprovider"><a class="anchor" href="#_groupsequenceprovider"></a>5.4.2. <code>@GroupSequenceProvider</code></h4>
<div class="paragraph">
<p>除了通过 <code>@GroupSequence</code> 静态重新定义默认组序列之外，Hibernate Validator 还提供了一个 SPI，用于根据对象状态动态重新定义默认组序列。</p>
</div>
<div class="paragraph">
<p>为此，需要实现接口 <code>DefaultGroupSequenceProvider</code> ，并通过 <code>@GroupSequenceProvider</code> 注解向目标类注册该实现。例如，在租车场景中，您可以动态地添加   <code>CarChecks</code> ，如<a href="#example-implementing-using-default-group-sequence-provider">Example 59, &#8220;实现和使用默认的组序列提供程序&#8221;</a></p>
</div>
<div id="example-implementing-using-default-group-sequence-provider" class="exampleblock">
<div class="title">Example 59. 实现和使用默认的组序列提供程序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05.groupsequenceprovider;

public class RentalCarGroupSequenceProvider
		implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {

	@Override
	public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {
		List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();
		defaultGroupSequence.add( RentalCar.class );

		if ( car != null &amp;&amp; !car.isRented() ) {
			defaultGroupSequence.add( CarChecks.class );
		}

		return defaultGroupSequence;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05.groupsequenceprovider;

@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
public class RentalCar extends Car {

	@AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
	private boolean rented;

	public RentalCar(String manufacturer, String licencePlate, int seatCount) {
		super( manufacturer, licencePlate, seatCount );
	}

	public boolean isRented() {
		return rented;
	}

	public void setRented(boolean rented) {
		this.rented = rented;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-group-conversion"><a class="anchor" href="#section-group-conversion"></a>5.5. 分组转化</h3>
<div class="paragraph">
<p>如果你想校验汽车相关检查和驾驶员检查一起进行怎么办？当然，您可以显式地将所需的组传递给 validate 方法，但是如果您希望将这些验证作为 <code>Default</code> 分组验证的一部分进行呢？这里使用了 <code>@ConvertGroup</code> ，它允许您在级联验证期间使用与最初请求的组不同的组。</p>
</div>
<div class="paragraph">
<p>让我们看看 <a href="#example-group-conversion-dedault-to-driver-checks">Example 60, &#8220;<code>@ConvertGroup</code> 用例&#8221;</a>。这里 <code>@GroupSequence({
CarChecks.class, Car.class })</code> 是修改 <code>Default</code> 分组。
(see <a href="#section-default-group-class">Section 5.4, &#8220;重新定义默认组序列&#8221;</a>). 这里的 <code>@ConvertGroup(from = Default.class, to =
DriverChecks.class)</code> 它确保在对汽车程序关联进行级联验证期间将 <code>Default</code> 分组转化为 <code>DriverChecks</code> 分组。</p>
</div>
<div id="example-group-conversion-dedault-to-driver-checks" class="exampleblock">
<div class="title">Example 60. <code>@ConvertGroup</code> 用例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05.groupconversion;

public class Driver {

	@NotNull
	private String name;

	@Min(
			value = 18,
			message = "You have to be 18 to drive a car",
			groups = DriverChecks.class
	)
	public int age;

	@AssertTrue(
			message = "You first have to pass the driving test",
			groups = DriverChecks.class
	)
	public boolean hasDrivingLicense;

	public Driver(String name) {
		this.name = name;
	}

	public void passedDrivingTest(boolean b) {
		hasDrivingLicense = b;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	// getters and setters ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter05.groupconversion;

@GroupSequence({ CarChecks.class, Car.class })
public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	@AssertTrue(
			message = "The car has to pass the vehicle inspection first",
			groups = CarChecks.class
	)
	private boolean passedVehicleInspection;

	@Valid
	@ConvertGroup(from = Default.class, to = DriverChecks.class)
	private Driver driver;

	public Car(String manufacturer, String licencePlate, int seatCount) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	public boolean isPassedVehicleInspection() {
		return passedVehicleInspection;
	}

	public void setPassedVehicleInspection(boolean passedVehicleInspection) {
		this.passedVehicleInspection = passedVehicleInspection;
	}

	public Driver getDriver() {
		return driver;
	}

	public void setDriver(Driver driver) {
		this.driver = driver;
	}

	// getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-group-conversion-test">Example 61, &#8220;测试用例 <code>@ConvertGroup</code>&#8221;</a> 的校验结果是成功的。即使 <code>hasDrivingLicense</code> 的约束属于 <code>DriverChecks</code> 分组，并且 <code>validate()</code> 方法只校验 <code>Default</code> 分组。</p>
</div>
<div id="example-group-conversion-test" class="exampleblock">
<div class="title">Example 61. 测试用例 <code>@ConvertGroup</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">// create a car and validate. The Driver is still null and does not get validated
Car car = new Car( "VW", "USD-123", 4 );
car.setPassedVehicleInspection( true );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
assertEquals( 0, constraintViolations.size() );

// create a driver who has not passed the driving test
Driver john = new Driver( "John Doe" );
john.setAge( 18 );

// now let's add a driver to the car
car.setDriver( john );
constraintViolations = validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"The driver constraint should also be validated as part of the default group",
		constraintViolations.iterator().next().getMessage(),
		"You first have to pass the driving test"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在任何使用 <code>@Valid</code> 注解的地方，使用分组转化。即关联、方法和构造函数参数以及返回值。可以使用 <code>@ConvertGroup.List</code> 同时指定多种转化。</p>
</div>
<div class="paragraph">
<p>不过，仅在下面的场景不适用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@ConvertGroup</code>  只能与 <code>@Valid</code> 结合使用。如果不使用，则引发 <code>ConstraintDeclarationException</code> 。</p>
</li>
<li>
<p>在同一个元素上具有相同的 <code>from</code> 值的多个转换规则是不合法的。在这种情况下，将引发 <code>ConstraintDeclarationException</code> 。</p>
</li>
<li>
<p><code>from</code> 属性不能引用分组序列。在这种情况下会引发 <code>ConstraintDeclarationException</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>规则不是递归执行的。使用第一个匹配转换规则，并忽略后续规则。例如，如果一组 @ConvertGroup 声明 a 到 b，b 到 c，组 a 将被转换为 b 而不是 c。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-customconstraints"><a class="anchor" href="#validator-customconstraints"></a>6. 自定义约束</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta Bean Validation API 定义了一整套标准约束注解，如 <code>@NotNull</code>,
<code>@Size</code> 等。在这些内置约束不够充分的情况下，可以轻松地创建根据特定校验需求定制的自定义约束。</p>
</div>
<div class="sect2">
<h3 id="validator-customconstraints-simple"><a class="anchor" href="#validator-customconstraints-simple"></a>6.1. 创建一个简单的约束</h3>
<div class="paragraph">
<p>要创建自定义约束，需要以下三个步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个约束注解</p>
</li>
<li>
<p>实现一个校验器</p>
</li>
<li>
<p>定义默认错误消息</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="validator-customconstraints-constraintannotation"><a class="anchor" href="#validator-customconstraints-constraintannotation"></a>6.1.1. 约束注解</h4>
<div class="paragraph">
<p>本节展示如何编写一个约束注解，该注解可用于校验给定的字符串完全大写或小写。稍后，这个约束将应用于 <a href="#validator-gettingstarted">Chapter 1, <em>快速开始</em></a> 中的 <code>Car</code> 类 <code>licensePlate</code> 字段。确保该字段始终是大写字母字符串。</p>
</div>
<div class="paragraph">
<p>首先需要的是一种表达这两种情况模式(大写或小写)的方法。虽然可以使用 <code>String</code> 常量，但更好的方法是为此使用枚举:</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. 枚举 <code>CaseMode</code> 表示大小写两种状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06;

public enum CaseMode {
	UPPER,
	LOWER;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一步是定义约束注解。如果你以前从未设计过注解，这看起来可能有点吓人，但实际上并不难:</p>
</div>
<div id="example-defining-custom-constraint" class="exampleblock">
<div class="title">Example 63. 定义 <code>@CheckCase</code> 约束注解</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE })
@Retention(RUNTIME)
@Constraint(validatedBy = CheckCaseValidator.class)
@Documented
@Repeatable(List.class)
public @interface CheckCase {

	String message() default "{org.hibernate.validator.referenceguide.chapter06.CheckCase." +
			"message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };

	CaseMode value();

	@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
	@Retention(RUNTIME)
	@Documented
	@interface List {
		CheckCase[] value();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>@interface</code> 关键字定义注解类型。注解类型的所有属性都以类似于方法的方式声明。Jakarta Bean Validation API 规范要求任何约束注解定义:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>message</code> 属性返回校验失败的默认错误信息。</p>
</li>
<li>
<p><code>groups</code> 属性允许对分组(see <a href="#chapter-groups">Chapter 5, <em>分组约束</em></a>)约束进行校验。这必须默认为 Class &lt; ? &gt; 类型的空数组.</p>
</li>
<li>
<p><code>payload</code> 属性可以被Jakarta Bean Validation API的客户端用于将自定义有效负载对象分配给约束。API 本身不使用此属性。自定义有效负载的一个例子是严重性的定义:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public class Severity {
	public interface Info extends Payload {
	}

	public interface Error extends Payload {
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public class ContactDetails {
	@NotNull(message = "Name is mandatory", payload = Severity.Error.class)
	private String name;

	@NotNull(message = "Phone number not specified, but not mandatory",
			payload = Severity.Info.class)
	private String phoneNumber;

	// ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，客户端可以在校验 <code>ContactDetails</code> 实例后，使用 <code>ConstraintViolation.getConstraintDescriptor().getPayload()</code> 访问约束的严重性。并其根据严重性调整其行为。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了这三个强制属性外，还有另一个属性 <code>value</code>，它允许指定所需的 case 模式。<code>value</code> 值是一个特殊的值，如果它是唯一指定的属性，在使用注解时可以省略，例如 <code>@CheckCase(CaseMode.UPPER)</code> 。</p>
</div>
<div class="paragraph">
<p>此外，约束注解还使用了一些元注解:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE})</code>: 定义约束支持的目标元素类型。 <code>@CheckCase</code> 可用于字段 ( <code>FIELD</code>), JavaBeans properties
和返回值 (<code>METHOD</code>), 方法/构造函数参数 (<code>PARAMETER</code>) 和参数化类型的类型参数 (<code>TYPE_USE</code>)。元素类型 <code>ANNOTATION_TYPE</code> 允许 <code>@CheckCase</code> 创建组合约束。</p>
<div class="paragraph">
<p>在创建类级别约束 (see <a href="#validator-usingvalidator-classlevel">Section 2.1.4, &#8220;类层面的约束&#8221;</a>),  <code>TYPE</code> 类型必须被支持。针对构造函数返回值的约束需要支持 <code>CONSTRUCTOR</code> 类型。 交叉参数的校验必须支持 <code>METHOD</code> 和 <code>CONSTRUCTOR</code> 。</p>
</div>
</li>
<li>
<p><code>@Retention(RUNTIME)</code>: 指定此类型的注解将在运行时通过反射的方式可用</p>
</li>
<li>
<p><code>@Constraint(validatedBy = CheckCaseValidator.class)</code>: 标记在使用 <code>@CheckCase</code> 时指定一个指定的validator(校验器)。 如果某个约束可用于多个数据类型，则可以指定多个校验器，每个校验器对应一个数据类型。</p>
</li>
<li>
<p><code>@Documented</code>: 表示 <code>@CheckCase</code> 的使用将包含在用它注解的元素的 JavaDoc 中。</p>
</li>
<li>
<p><code>@Repeatable(List.class)</code>:  表示注解可以在同一个地方重复多次，通常使用不同的配置。 <code>List</code> 是包含的注解类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例中还显示了这个包含注解类型名为 <code>List</code> 。它允许在同一个元素上指定多个 <code>@CheckCase</code> ，例如使用不同的校验组和消息。虽然可以使用另一个名称，但 Jakarta Bean Validation 范建议使用名称 <code>List</code> 并使注解成为相应约束类型的内部注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-constraint-validator"><a class="anchor" href="#section-constraint-validator"></a>6.1.2. 约束校验器</h4>
<div class="paragraph">
<p>在定义了注解之后，您需要创建一个约束校验器，它能够校验使用 <code>@CheckCase</code> 的元素。 为此，实现
<code>ConstraintValidator</code>，如下所示:</p>
</div>
<div id="example-constraint-validator" class="exampleblock">
<div class="title">Example 64. 实现 <code>@CheckCase</code> 约束的约束校验器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

	private CaseMode caseMode;

	@Override
	public void initialize(CheckCase constraintAnnotation) {
		this.caseMode = constraintAnnotation.value();
	}

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		if ( caseMode == CaseMode.UPPER ) {
			return object.equals( object.toUpperCase() );
		}
		else {
			return object.equals( object.toLowerCase() );
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ConstraintValidator</code> 接口定义了需要在实现中设置的两个类型参数(范型)。第一个指定要校验的注释(<code>CheckCase</code>)。第二个指定校验器可以处理的元素类型( <code>String</code> )。如果一个约束支持多个数据类型，那么每个允许的类型都必须实现一个 <code>ConstraintValidator</code> ，并在约束注解中注册，如上所示。</p>
</div>
<div class="paragraph">
<p>校验器的实现非常简单。<code>initialize()</code> 方法使您能够访问已校验约束的属性值，并允许您将它们存储在校验器的字段中，如示例所示。</p>
</div>
<div class="paragraph">
<p><code>isValid()</code> 方法包含实际的校验逻辑。对于 <code>@CheckCase</code> ，这是检查给定的字符串是完全小写还是大写，这取决于 <code>initialize()</code> 中检索的大小写模式。注意，Jakarta Bean Validation 校验规范建议将空值视为有效值。如果 <code>null</code> 不是元素的有效值，则应该显式地用 <code>@NotNull</code> 对其进行注释。</p>
</div>
<div class="sect4">
<h5 id="_the_constraintvalidatorcontext"><a class="anchor" href="#_the_constraintvalidatorcontext"></a>6.1.2.1. The <code>ConstraintValidatorContext</code></h5>
<div class="paragraph">
<p><a href="#example-constraint-validator">Example 64, &#8220;实现 <code>@CheckCase</code> 约束的约束校验器&#8221;</a> 依赖于从 <code>isValid()</code> 方法返回 <code>true</code> 或 <code>false</code> 来判断是否生成默认错误消息。 使用作为参数传递的 <code>ConstraintValidatorContext</code> 对象，可以添加额外的错误消息，也可以完全禁用默认错误消息生成，并只定义自定义错误消息。 <code>ConstraintValidatorContext</code> API 被建模为 fluent 接口，最好用一个例子来演示:</p>
</div>
<div id="example-constraint-validator-context" class="exampleblock">
<div class="title">Example 65. 使用 <code>ConstraintValidatorContext</code> 定义自定义错误消息</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.constraintvalidatorcontext;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

	private CaseMode caseMode;

	@Override
	public void initialize(CheckCase constraintAnnotation) {
		this.caseMode = constraintAnnotation.value();
	}

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		boolean isValid;
		if ( caseMode == CaseMode.UPPER ) {
			isValid = object.equals( object.toUpperCase() );
		}
		else {
			isValid = object.equals( object.toLowerCase() );
		}

		if ( !isValid ) {
			constraintContext.disableDefaultConstraintViolation();
			constraintContext.buildConstraintViolationWithTemplate(
					"{org.hibernate.validator.referenceguide.chapter06." +
					"constraintvalidatorcontext.CheckCase.message}"
			)
			.addConstraintViolation();
		}

		return isValid;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-constraint-validator-context">Example 65, &#8220;使用 <code>ConstraintValidatorContext</code> 定义自定义错误消息&#8221;</a> 展示了如何禁用默认错误消息生成并使用指定的消息模板添加自定义错误消息。在这个示例中，使用 <code>ConstraintValidatorContext</code> 会生成与默认错误消息生成相同的错误消息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通过调用 <code>addConstraintViolation()</code> 添加每个已配置的约束冲突非常重要。只有在此之后才会创建新的约束冲突。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，在自定义约束中，<code>ConstraintValidatorContext</code> 不允许使用EL表达式。</p>
</div>
<div class="paragraph">
<p>但是，对于某些高级需求，可能需要使用 Expression Language。</p>
</div>
<div class="paragraph">
<p>在这种情况下，您需要打开 <code>HibernateConstraintValidatorContext</code> 并显式启用 Expression Language。有关更多信息，请参见 <a href="#section-hibernateconstraintvalidatorcontext">Section 12.13.1, &#8220;<code>HibernateConstraintValidatorContext</code>&#8221;</a> 。</p>
</div>
<div class="paragraph">
<p>请参阅 <a href="#section-custom-property-paths">Section 6.2.1, &#8220;自定义属性路径&#8221;</a>  ，以了解如何使用 <code>ConstraintValidatorContext</code> API 控制类级约束违反约束的属性路径。</p>
</div>
</div>
<div class="sect4">
<h5 id="constraint-validator-hibernateconstraintvalidator"><a class="anchor" href="#constraint-validator-hibernateconstraintvalidator"></a>6.1.2.2. The <code>HibernateConstraintValidator</code>  扩展</h5>
<div class="paragraph">
<p>Hibernate Validator 提供了 <code>ConstraintValidator</code> 的拓展：<code>HibernateConstraintValidator</code>。</p>
</div>
<div class="paragraph">
<p>这个扩展的目的是为 <code>initialize()</code> 方法提供更多的上下文信息，因为在当前 <code>ConstraintValidator</code> 契约中，只有注释作为参数传递。</p>
</div>
<div class="paragraph">
<p><code>HibernateConstraintValidator</code> 的 <code>initialize()</code> 方法有两个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ConstraintDescriptor</code> 代表当前的约束。你可以使用 <code>ConstraintDescriptor#getAnnotation()</code> 获取相关注解。</p>
</li>
<li>
<p><code>HibernateConstraintValidatorInitializationContext</code> 它提供有用的帮助和上下文信息，如时钟提供者或时间校验容忍度。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个扩展被标记为正在孵化，因此它可能会受到更改。该计划是将其标准化，并在未来将其纳入 Jakarta Bean Validation 标准。</p>
</div>
<div class="paragraph">
<p>下面的例子展示了如何将校验器基于 <code>HibernateConstraintValidator</code>:</p>
</div>
<div id="example-constraint-validator-hibernateconstraintvalidator" class="exampleblock">
<div class="title">Example 66. 使用 <code>HibernateConstraintValidator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06;

public class MyFutureValidator implements HibernateConstraintValidator&lt;MyFuture, Instant&gt; {

	private Clock clock;

	private boolean orPresent;

	@Override
	public void initialize(ConstraintDescriptor&lt;MyFuture&gt; constraintDescriptor,
			HibernateConstraintValidatorInitializationContext initializationContext) {
		this.orPresent = constraintDescriptor.getAnnotation().orPresent();
		this.clock = initializationContext.getClockProvider().getClock();
	}

	@Override
	public boolean isValid(Instant instant, ConstraintValidatorContext constraintContext) {
		//...

		return false;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您应该只实现 <code>initialize()</code> 方法中的一个。请注意，在初始化校验器时都会调用这两个方法。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="constraint-validator-payload"><a class="anchor" href="#constraint-validator-payload"></a>6.1.2.3. 将有效负载传递给约束校验器</h5>
<div class="paragraph">
<p>有时，您可能希望在某些外部参数上设定约束验证器行为的条件。</p>
</div>
<div class="paragraph">
<p>例如，如果每个国家有一个实例，那么邮政编码验证器可能会根据应用程序实例的区域设置而有所不同。另一个需求可能是在特定环境中具有不同的行为: 分段环境可能无法访问验证程序正确运行所必需的一些外部生产资源。</p>
</div>
<div class="paragraph">
<p>为所有这些用例引入了约束验证器有效负载的概念。它是一个通过 <code>HibernateConstraintValidatorContext</code> 从 <code>Validator</code> 实例传递到每个约束验证器的对象。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何在 <code>ValidatorFactory</code> 初始化期间设置约束验证器有效负载。除非您覆盖这个默认值，否则这个 <code>ValidatorFactory</code> 创建的所有 <code>Validator</code>s 都将设置这个约束验证器有效负载值。</p>
</div>
<div id="example-constraint-validator-payload-definition-validatorfactory" class="exampleblock">
<div class="title">Example 67. 在 <code>ValidatorFactory</code> 初始化时定义有效负载</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.constraintValidatorPayload( "US" )
		.buildValidatorFactory();

Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一个选项是使用上下文设置每个 <code>Validator</code>  的约束验证器有效负载:</p>
</div>
<div id="example-constraint-validator-payload-definition-validatorcontext" class="exampleblock">
<div class="title">Example 68. 获取不同有效负载的 <code>Validator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">HibernateValidatorFactory hibernateValidatorFactory = Validation.byDefaultProvider()
		.configure()
		.buildValidatorFactory()
		.unwrap( HibernateValidatorFactory.class );

Validator validator = hibernateValidatorFactory.usingContext()
		.constraintValidatorPayload( "US" )
		.getValidator();

// [...] US specific validation checks

validator = hibernateValidatorFactory.usingContext()
		.constraintValidatorPayload( "FR" )
		.getValidator();

// [...] France specific validation checks</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦你设置了约束验证器有效负载，它就可以在你的约束验证器中使用，如下面的例子所示:</p>
</div>
<div id="example-constraint-validator-payload-usage" class="exampleblock">
<div class="title">Example 69. 在约束验证器中使用约束验证器有效负载</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.constraintvalidatorpayload;

public class ZipCodeValidator implements ConstraintValidator&lt;ZipCode, String&gt; {

	public String countryCode;

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		boolean isValid = false;

		String countryCode = constraintContext
				.unwrap( HibernateConstraintValidatorContext.class )
				.getConstraintValidatorPayload( String.class );

		if ( "US".equals( countryCode ) ) {
			// checks specific to the United States
		}
		else if ( "FR".equals( countryCode ) ) {
			// checks specific to France
		}
		else {
			// ...
		}

		return isValid;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>HibernateConstraintValidatorContext#getConstraintValidatorPayload()</code> )有一个类型参数，只有当有效负载是给定类型时才返回有效负载。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>需要注意的是，约束验证器有效负载不同于您可以在引发的约束冲突中包含的动态有效负载。</p>
</div>
<div class="paragraph">
<p>这个约束验证器有效负载的全部目的是用来约束验证器的行为。它不包含在违反约束中，除非特定的
<code>ConstraintValidator</code> 实现通过使用 <a href="#section-dynamic-payload">constraint violation dynamic payload mechanism</a> 有效负载机制将有效负载传递给发出的违反约束的情况。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validator-customconstraints-errormessage"><a class="anchor" href="#validator-customconstraints-errormessage"></a>6.1.3. 错误信息</h4>
<div class="paragraph">
<p>最后一个缺少的构建块是一个错误消息，应该在违反 <code>@CheckCase</code> 约束时使用。要定义这个属性，请创建一个带有以下内容的 <em>ValidationMessages.properties</em> 文件 (see also <a href="#section-message-interpolation">Section 4.1, &#8220;默认消息插值&#8221;</a>)</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. 定义 <code>CheckCase</code> 约束的错误信息</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>org.hibernate.validator.referenceguide.chapter06.CheckCase.message=Case mode must be {value}.</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果发生验证错误，验证运行时将使用您为 <code>@CheckCase</code> 注释的消息属性指定的默认值，以便在此资源包中查找错误消息。</p>
</div>
</div>
<div class="sect3">
<h4 id="validator-customconstraints-using"><a class="anchor" href="#validator-customconstraints-using"></a>6.1.4. 使用约束</h4>
<div class="paragraph">
<p>现在你可以使用 <a href="#validator-gettingstarted">Chapter 1, <em>快速开始</em></a> 章节中的 <code>Car</code> 类中的用该约束来指定 <code>licensePlate</code> 字段应该只包含大写字符串:</p>
</div>
<div id="example-car-with-checkcase" class="exampleblock">
<div class="title">Example 71. 使用 <code>@CheckCase</code> 约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06;

public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	@CheckCase(CaseMode.UPPER)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	public Car(String manufacturer, String licencePlate, int seatCount) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	//getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后， <a href="#example-using-checkcase">Example 72, &#8220;校验 <code>@CheckCase</code> 约束&#8221;</a> 演示了如何通过校验将使用无效车牌的 <code>Car</code> 实例来违反 <code>@CheckCase</code> 约束。</p>
</div>
<div id="example-using-checkcase" class="exampleblock">
<div class="title">Example 72. 校验 <code>@CheckCase</code> 约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">//invalid license plate
Car car = new Car( "Morris", "dd-ab-123", 4 );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
		validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"Case mode must be UPPER.",
		constraintViolations.iterator().next().getMessage()
);

//valid license plate
car = new Car( "Morris", "DD-AB-123", 4 );

constraintViolations = validator.validate( car );

assertEquals( 0, constraintViolations.size() );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-class-level-constraints"><a class="anchor" href="#section-class-level-constraints"></a>6.2. 类级别的约束</h3>
<div class="paragraph">
<p>如前所述，还可以在类级别应用约束来验证整个对象的状态。定义类级别约束的方式与定义属性约束的方式相同。<a href="#example-implementing-classlevel-constraint">Example 73, &#8220;实现一个类级别的约束注解&#8221;</a> 展示了 <code>@ValidPassengerCount</code> 注解的定义。 它的使用可以查看 <a href="#example-class-level">Example 19, &#8220;类级别约束&#8221;</a>。</p>
</div>
<div id="example-implementing-classlevel-constraint" class="exampleblock">
<div class="title">Example 73. 实现一个类级别的约束注解</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.classlevel;

@Target({ TYPE, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = { ValidPassengerCountValidator.class })
@Documented
public @interface ValidPassengerCount {

	String message() default "{org.hibernate.validator.referenceguide.chapter06.classlevel." +
			"ValidPassengerCount.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.classlevel;

public class ValidPassengerCountValidator
		implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext context) {
		if ( car == null ) {
			return true;
		}

		return car.getPassengers().size() &lt;= car.getSeatCount();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如示例所示，您需要在 <code>@Target</code> 愿注解中添加 <code>TYPE</code> 类型。这允许将该约束放在类上使用。示例中的约束校验器的 <code>isValid()</code> 方法接收 <code>Car</code> 类型，并且可以访问完整的对象状态以确定给定实例是否有效。</p>
</div>
<div class="sect3">
<h4 id="section-custom-property-paths"><a class="anchor" href="#section-custom-property-paths"></a>6.2.1. 自定义属性路径</h4>
<div class="paragraph">
<p>默认情况下，类级别约束的约束冲突是在注释类型的级别上报告的，例如 <code>Car</code> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，违规的属性路径最好是指涉及的属性之一。例如，您可能希望针对 <code>Car</code> 具体不满足校验的属性，而不是 <code>@ValidPassengerCount</code> 约束。</p>
</div>
<div class="paragraph">
<p><a href="#example-custom-error">Example 74, &#8220;添加关于字段信息的 <code>ConstraintViolation</code>&#8221;</a> 展示了如何通过使用传递给 <code>isValid()</code> 的约束验证器上下文来为属性 passengers 构建一个带有属性节点的自定义约束违反。注意，您还可以添加几个属性节点，指向验证 bean 的子实体。</p>
</div>
<div id="example-custom-error" class="exampleblock">
<div class="title">Example 74. 添加关于字段信息的 <code>ConstraintViolation</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.custompath;

public class ValidPassengerCountValidator
		implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext constraintValidatorContext) {
		if ( car == null ) {
			return true;
		}

		boolean isValid = car.getPassengers().size() &lt;= car.getSeatCount();

		if ( !isValid ) {
			constraintValidatorContext.disableDefaultConstraintViolation();
			constraintValidatorContext
					.buildConstraintViolationWithTemplate( "{my.custom.template}" )
					.addPropertyNode( "passengers" ).addConstraintViolation();
		}

		return isValid;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-cross-parameter-constraints"><a class="anchor" href="#section-cross-parameter-constraints"></a>6.3. 交叉参数约束</h3>
<div class="paragraph">
<p>Jakarta Bean Validation 区分两种不同类型的约束。</p>
</div>
<div class="paragraph">
<p>一般的约束(到目前为止已经讨论过)适用于带注解的元素，例如类型、字段、容器元素、方法参数或返回值等。相反，交叉参数约束适用于方法或构造函数的参数数组，可用于表示依赖于多个参数值的验证逻辑。</p>
</div>
<div class="paragraph">
<p>为了定义交叉参数约束，其校验器类必须用 <code>@SupportedValidationTarget(ValidationTarget.PARAMETERS)</code> 标记。 <code>ConstraintValidator</code> 接口的范型参数( <code>T</code> )必须必须设置为 <code>Object</code> 或者 <code>Object[]</code> ，以便在 <code>isValid()</code> 方法中接收方法/构造函数参数数组。</p>
</div>
<div class="paragraph">
<p>下面的示例显示了交叉参数约束的定义，该约束可用于检查方法的两个 <code>Date</code> 参数的顺序是否正确:</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. 交叉参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@Constraint(validatedBy = ConsistentDateParametersValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ConsistentDateParameters {

	String message() default "{org.hibernate.validator.referenceguide.chapter04." +
			"crossparameter.ConsistentDateParameters.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>交叉参数约束的定义与定义一般约束没有任何不同，即它必须指定成员 <code>message()</code>, <code>groups()</code> 和 <code>payload()</code> ，并注释 <code>@Constraint</code> 。这个元注释还指定了相应的验证器，如 <a href="#example-cross-parameter-validator">Example 76, &#8220;泛型和交叉参数约束&#8221;</a> 所示。除了元素类型 <code>METHOD</code> 和 <code>CONSTRUCTOR</code> 之外，还指定了 <code>ANNOTATION_TYPE</code> 作为注释的目标，以便能够基于 <code>@ConsistentDateParameters</code> 创建组合约束(参见：<a href="#section-constraint-composition">Section 6.4, &#8220;约束组合&#8221;</a>)。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>跨参数约束是在方法或构造函数的声明上直接指定的，返回值约束也是这种情况。因此，为了提高代码的可读性，建议选择使约束目标明显的约束名称，例如：<code>@ConsistentDateParameters</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-cross-parameter-validator" class="exampleblock">
<div class="title">Example 76. 泛型和交叉参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ConsistentDateParametersValidator implements
		ConstraintValidator&lt;ConsistentDateParameters, Object[]&gt; {

	@Override
	public void initialize(ConsistentDateParameters constraintAnnotation) {
	}

	@Override
	public boolean isValid(Object[] value, ConstraintValidatorContext context) {
		if ( value.length != 2 ) {
			throw new IllegalArgumentException( "Illegal method signature" );
		}

		//leave null-checking to @NotNull on individual parameters
		if ( value[0] == null || value[1] == null ) {
			return true;
		}

		if ( !( value[0] instanceof Date ) || !( value[1] instanceof Date ) ) {
			throw new IllegalArgumentException(
					"Illegal method signature, expected two " +
							"parameters of type Date."
			);
		}

		return ( (Date) value[0] ).before( (Date) value[1] );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上所述，必须使用在 <code>@SupportedValidationTarget</code> 中设置目标为 <code>PARAMETERS</code> 来表示这是一个交叉参数约束。由于交叉参数约束可以应用于任何方法或构造函数，因此在验证器实现中检查预期的参数数量和类型被认为是一种最佳实践。</p>
</div>
<div class="paragraph">
<p>与通用约束一样，应该将 <code>null</code> 参数视为有效参数，并且应该对单个参数使用 <code>@NotNull</code> 来确保参数不为 <code>null</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与类级别约束类似，在验证交叉参数约束时，可以对单个参数而不是所有参数创建自定义约束违反。只需从传递给 <code>isValid()</code> 的 <code>ConstraintValidatorContext</code> 通过调用 <code>addParameterNode()</code> 添加一个参数节点。在这个示例中，您可以使用它对验证过的方法的结束日期参数创建约束冲突。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在极少数情况下，约束既是泛型约束又是交叉参数约束。如果一个约束具有一个带有 <code>@SupportedValidationTarget({ValidationTarget.PARAMETERS, ValidationTarget.ANNOTATED_ELEMENT})</code> 注释的验证器类，或者它具有一个通用的和跨参数的验证器类，那么就会出现这种情况。</p>
</div>
<div class="paragraph">
<p>当在具有参数和返回值的方法上声明这样的约束时，无法确定预期的约束目标。因此，同时具有通用性和交叉参数的约束必须定义一个成员 <code>validationAppliesTo()</code> ，它允许约束用户指定约束的目标，如示例 <a href="#example-dual-cross-parameter-constraint">Example 77, &#8220;泛型和交叉参数约束&#8221;</a> 。</p>
</div>
<div id="example-dual-cross-parameter-constraint" class="exampleblock">
<div class="title">Example 77. 泛型和交叉参数约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@Constraint(validatedBy = {
		ScriptAssertObjectValidator.class,
		ScriptAssertParametersValidator.class
})
@Target({ TYPE, FIELD, PARAMETER, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ScriptAssert {

	String message() default "{org.hibernate.validator.referenceguide.chapter04." +
			"crossparameter.ScriptAssert.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };

	String script();

	ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@ScriptAssert</code> 约束有两个验证器(未显示) ，一个泛型验证器和一个交叉参数验证器，因此定义了成员 <code>validationAppliesTo()</code> 。默认值 <code>IMPLICIT</code> 允许在可能的情况下自动派生目标(例如，如果约束在字段上声明，或者在具有参数但没有返回值的方法上声明)。</p>
</div>
<div class="paragraph">
<p>如果不能隐式确定目标，则用户必须将其设置为 <code>PARAMETERS</code> 或 <code>RETURN_VALUE</code>，如 <a href="#example-dual-cross-parameter-constraint-usage">Example 78, &#8220;为一般的和交叉参数约束指定目标&#8221;</a> 。</p>
</div>
<div id="example-dual-cross-parameter-constraint-usage" class="exampleblock">
<div class="title">Example 78. 为一般的和交叉参数约束指定目标</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@ScriptAssert(script = "arg1.size() &lt;= arg0", validationAppliesTo = ConstraintTarget.PARAMETERS)
public Car buildCar(int seatCount, List&lt;Passenger&gt; passengers) {
	//...
	return null;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-constraint-composition"><a class="anchor" href="#section-constraint-composition"></a>6.4. 约束组合</h3>
<div class="paragraph">
<p>查看示例 <a href="#example-car-with-checkcase">Example 71, &#8220;使用 <code>@CheckCase</code> 约束&#8221;</a> 中的 <code>Car</code> 类的 <code>licensePlate</code> 字段，您已经看到了三个约束注释。在更复杂的场景中，甚至可以对一个元素应用更多的约束，这可能很容易变得有点令人困惑。此外，如果在另一个类中有一个 <code>licensePlate</code> ，那么您也必须将所有约束声明复制到另一个类中，这违反了 DRY 原则。</p>
</div>
<div class="paragraph">
<p>您可以通过创建由几个基本约束组成的更高级别约束来解决此类问题。例子 <a href="#example-composed-constraint">Example 79, &#8220;创建一个 <code>@ValidLicensePlate</code> 约束&#8221;</a> 展示了一个合成的约束注释，其中包括 <code>@NotNull</code> 、<code>@Size</code> 和 <code>@CheckCase</code> :</p>
</div>
<div id="example-composed-constraint" class="exampleblock">
<div class="title">Example 79. 创建一个 <code>@ValidLicensePlate</code> 约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.constraintcomposition;

@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, TYPE_USE })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
@Documented
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"constraintcomposition.ValidLicensePlate.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要创建组合约束，只需使用其组合约束对约束声明进行注释。如果组合约束本身需要一个验证器，则在 <code>@Constraint</code> 注释中指定该验证器。对于不需要额外验证器(如 <code>@ValidLicensePlate</code> )的组合约束，只需将 <code>validatedBy()</code>  设置为一个空数组。</p>
</div>
<div class="paragraph">
<p>在 <code>licensePlate</code> 字段中使用新的组合约束完全等价于前一个版本，其中三个约束直接在字段本身中声明:</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. 使用组合约束 <code>ValidLicensePlate</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.constraintcomposition;

public class Car {

	@ValidLicensePlate
	private String licensePlate;

	//...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个在校验 <code>Car</code> 实例中构建 <code>ConstraintViolation</code>s 合集，是 <code>@ValidLicensePlate</code> 每个组成的约束，如果您更喜欢在任何构成约束被违反的情况下使用单个约束违反，可以使用 <code>@ReportAsSingleViolation</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. 使用 @ReportAsSingleViolation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter06.constraintcomposition.reportassingle;

//...
@ReportAsSingleViolation
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"constraintcomposition.reportassingle.ValidLicensePlate.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-valueextraction"><a class="anchor" href="#chapter-valueextraction"></a>7. 值提取</h2>
<div class="sectionbody">
<div class="paragraph">
<p>值提取是从集合中提取对象以便对其进行验证的过程。</p>
</div>
<div class="paragraph">
<p>它用于处理<a href="#container-element-constraints">集合元素约束</a>和<a href="#example-cascaded-validation-list">集合中的级联校验</a>。</p>
</div>
<div class="sect2">
<h3 id="section-valueextraction-builtinvalueextractors"><a class="anchor" href="#section-valueextraction-builtinvalueextractors"></a>7.1. 内置值提取器</h3>
<div class="paragraph">
<p>Hibernate Validator 为常用的 Java 容器类型提供了内置的值提取器，因此，除非您使用自己的自定义容器类型(或外部库，如 <a href="https://github.com/google/guava">Guava</a> 的 <code>Multimap</code> ) ，否则不应该添加自己的值提取器。</p>
</div>
<div class="paragraph">
<p>所有以下容器类型都有内置的值提取器:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Iterable</code>;</p>
</li>
<li>
<p><code>java.util.List</code>;</p>
</li>
<li>
<p><code>java.util.Map</code>: for keys and values;</p>
</li>
<li>
<p><code>java.util.Optional</code>, <code>java.util.OptionalInt</code>, <code>java.util.OptionalLong</code> and <code>java.util.OptionalDouble</code>;</p>
</li>
<li>
<p><a href="http://docs.oracle.com/javase/8/javase-clienttechnologies.htm">JavaFX</a>'s <code>ObservableValue</code> (参见 <a href="#section-valueextraction-javafx">Section 7.4, &#8220;JavaFX 值提取器&#8221;</a> ).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 <a href="http://beanvalidation.org/2.0/spec/#valueextractordefinition-builtinvalueextractors">Jakarta Bean Validation specification</a> 中可以找到内置值提取器的完整列表，并包含它们行为的所有细节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实现一个_valueextractor"><a class="anchor" href="#_实现一个_valueextractor"></a>7.2. 实现一个 <code>ValueExtractor</code></h3>
<div class="paragraph">
<p>要从自定义容器中提取值，需要实现 <code>ValueExtractor</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实现一个 <code>ValueExtractor</code> 是不够的，您还需要注册它。详情请参阅 <a href="#section-valueextraction-registeringvalueextractor">Section 7.5, &#8220;注册一个 <code>ValueExtractor</code>&#8221;</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ValueExtractor</code> 是一个非常简单的 API，因为值提取器的唯一目的是向 <code>ValueReceiver</code> 提供提取的值。</p>
</div>
<div class="paragraph">
<p>例如，让我们考虑 Guava&#8217;s <code>Optional</code>。这是一个简单的示例，因为我们可以参考 <code>java.util.Optional</code> 编写Guava的值提取器:</p>
</div>
<div id="example-valueextraction-guava-optional-valueextractor" class="exampleblock">
<div class="title">Example 82. 实现Guava&#8217;s <code>Optional</code> 的 <code>ValueExtractor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter07.valueextractor;

public class OptionalValueExtractor
		implements ValueExtractor&lt;Optional&lt;@ExtractedValue ?&gt;&gt; {

	@Override
	public void extractValues(Optional&lt;?&gt; originalValue, ValueReceiver receiver) {
		receiver.value( null, originalValue.orNull() );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下是对上面行为一些解释:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@ExtractedValue</code> 注解标注使用约束的变量类型:即需要校验的参数类型</p>
</li>
<li>
<p>我们使用receiver的 <code>value()</code> 方法来获取 <code>Optional</code> 包装里的值</p>
</li>
<li>
<p>我们不希望属性违反约束时添加新的节点信息。所以在调用 <code>value()</code> 方法，我们传入了 <code>null</code> 作为节点名称。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个更有趣的例子是 Guava 的 <code>Multimap</code> : 我们希望能够验证这个容器类型的键和值。</p>
</div>
<div class="paragraph">
<p>让我们首先考虑值的情况，需要一个值提取器提取它们:</p>
</div>
<div id="example-valueextraction-guava-multimap-value-valueextractor" class="exampleblock">
<div class="title">Example 83. A <code>ValueExtractor</code> for <code>Multimap</code> values</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter07.valueextractor;

public class MultimapValueValueExtractor
		implements ValueExtractor&lt;Multimap&lt;?, @ExtractedValue ?&gt;&gt; {

	@Override
	public void extractValues(Multimap&lt;?, ?&gt; originalValue, ValueReceiver receiver) {
		for ( Entry&lt;?, ?&gt; entry : originalValue.entries() ) {
			receiver.keyedValue( "&lt;multimap value&gt;", entry.getKey(), entry.getValue() );
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>它用于验证 <code>Multimap</code> 值的约束:</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. 对 <code>Multimap</code> 的值进行约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">private Multimap&lt;String, @NotBlank String&gt; map1;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一个值提取器需要能够对 <code>Multimap</code> 的键进行约束:</p>
</div>
<div id="example-valueextraction-guava-multimap-key-valueextractor" class="exampleblock">
<div class="title">Example 85. A <code>ValueExtractor</code> for <code>Multimap</code> keys</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter07.valueextractor;

public class MultimapKeyValueExtractor
		implements ValueExtractor&lt;Multimap&lt;@ExtractedValue ?, ?&gt;&gt; {

	@Override
	public void extractValues(Multimap&lt;?, ?&gt; originalValue, ValueReceiver receiver) {
		for ( Object key : originalValue.keySet() ) {
			receiver.keyedValue( "&lt;multimap key&gt;", key, key );
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦这两个值提取器被注册，你可以声明 <code>Multimap</code> 的键和值的约束:</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. 对 <code>Multimap</code> 的键和值进行约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">private Multimap&lt;@NotBlank String, @NotBlank String&gt; map2;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这两个值提取器之间的差异乍一看可能有点微妙，所以让我们来解释一下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@ExtractedValue</code> 注释标记了需要提取目标类型参数(本例中为 <code>K</code> 或 <code>V</code> )。</p>
</li>
<li>
<p>我们使用不同的节点名称 (<code>&lt;multimap key&gt;</code> vs. <code>&lt;multimap value&gt;</code>).</p>
</li>
<li>
<p>在第一种情况下，我们将values传递给receiver (
<code>keyedValue()</code> 方法的第三个参数), 在另一种情况下，我们传递键。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据您的容器类型，您应该选择最适合的 <code>ValueReceiver</code> 方法:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>value()</code></dt>
<dd>
<p>对于一个简单的包装容器 - 它是用于 <code>Optional</code>s</p>
</dd>
<dt class="hdlist1"><code>iterableValue()</code></dt>
<dd>
<p>对于可迭代的容器 - 它是用于 <code>Set</code>s</p>
</dd>
<dt class="hdlist1"><code>indexedValue()</code></dt>
<dd>
<p>用于包含索引值的容器 - 它是用于 <code>List</code>s</p>
</dd>
<dt class="hdlist1"><code>keyedValue()</code></dt>
<dd>
<p>对于包含键值的容器 - 它是用于 <code>Map</code>s.
它同时用于键和值。对于校验键的情况，键也作为验证值传递。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>对于所有这些方法，您需要传递一个节点名称: 它是添加到违反约束的属性路径的节点中包含的名称。如前所述，如果节点名为 <code>null</code> ，则不会向属性路径添加任何节点: 对于类似于 <code>Optional</code> 的纯包装器类型来说，它非常有用。</p>
</div>
<div class="paragraph">
<p>选择使用的方法非常重要，因为它将上下文信息添加到违反约束的属性路径中，例如索引或验证值的键。</p>
</div>
</div>
<div class="sect2">
<h3 id="_非通用容器"><a class="anchor" href="#_非通用容器"></a>7.3. 非通用容器</h3>
<div class="paragraph">
<p>您可能已经注意到，到目前为止，我们只为泛型容器实现值提取器。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 还支持非通用容器的值提取。</p>
</div>
<div class="paragraph">
<p>让我们以 <code>java.util.OptionalInt</code> 为例，它将一个原生类型 <code>int</code> 的 <code>Optional</code> 包装类。</p>
</div>
<div class="paragraph">
<p>对 <code>OptionalInt</code> 的值提取器的第一次尝试如下:</p>
</div>
<div id="example-valueextraction-optionalint-valueextractor" class="exampleblock">
<div class="title">Example 87. A <code>ValueExtractor</code> for <code>OptionalInt</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter07.nongeneric;

public class OptionalIntValueExtractor
		implements ValueExtractor&lt;@ExtractedValue(type = Integer.class) OptionalInt&gt; {

	@Override
	public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
		receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于非泛型容器来说，有一个明显的缺陷: 我们没有类型参数。它有两个后果:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们不能使用类型参数来确定验证值的类型;</p>
</li>
<li>
<p>我们不能在类型参数上添加约束(例如 <code>Container&lt;@NotNull String&gt;</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>首先，我们需要一种方法来告诉 Hibernate Validator 从 <code>OptionalInt</code> 中提取的值是 <code>Integer</code> 类型的。正如您在上面的示例中看到的, <code>@ExtractedValue</code> 注解的 <code>type</code> 属性允许向验证引擎提供此信息。</p>
</div>
<div class="paragraph">
<p>然后，您必须告诉验证引擎，要添加到 <code>OptionalInt</code> 属性的 <code>Min</code> 约束与包装值有关，而与包装器无关。</p>
</div>
<div class="paragraph">
<p>Jakarta Bean Validation 为这种情况提供了 <code>Unwrapping.Unwrap</code> 有效负载:</p>
</div>
<div id="example-valueextraction-optionalint-unwrapping" class="exampleblock">
<div class="title">Example 88. 使用 <code>Unwrapping.Unwrap</code> 有效载荷</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@Min(value = 5, payload = Unwrapping.Unwrap.class)
private OptionalInt optionalInt1;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们退后一步，我们想要添加到 <code>OptionalInt</code> 属性的大部分约束(如果不是全部的话)将应用于包装的值，因此有一种方法使它成为默认值将是很好的。</p>
</div>
<div class="paragraph">
<p>这正是 <code>@UnwrapByDefault</code> 注释的用途:</p>
</div>
<div id="example-valueextraction-optionalint-unwrapbydefault-valueextractor" class="exampleblock">
<div class="title">Example 89. A <code>ValueExtractor</code> for <code>OptionalInt</code> marked with <code>@UnwrapByDefault</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter07.nongeneric;

@UnwrapByDefault
public class UnwrapByDefaultOptionalIntValueExtractor
		implements ValueExtractor&lt;@ExtractedValue(type = Integer.class) OptionalInt&gt; {

	@Override
	public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
		receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当为 <code>OptionalInt</code> 声明这个值提取器时，约束注释默认应用于被包装的值:</p>
</div>
<div id="example-valueextraction-optionalint-implicitunwrapping" class="exampleblock">
<div class="title">Example 90. 隐式展开 <code>@UnwrapByDefault</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@Min(5)
private OptionalInt optionalInt2;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意，您仍然可以使用 <code>Unwrapping.Skip</code> 有效负载为包装器本身声明一个注释:</p>
</div>
<div id="example-valueextraction-optionalint-avoid-implicitunwrapping" class="exampleblock">
<div class="title">Example 91. Avoid implicit unwrapping with <code>Unwrapping.Skip</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@NotNull(payload = Unwrapping.Skip.class)
@Min(5)
private OptionalInt optionalInt3;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>OptionalInt</code> 的 <code>@UnwrapByDefault</code> 值提取器是内置值提取器的一部分: 不需要额外添加。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-valueextraction-javafx"><a class="anchor" href="#section-valueextraction-javafx"></a>7.4. JavaFX 值提取器</h3>
<div class="paragraph">
<p>JavaFX 中的 Bean 属性通常不是像 <code>String</code> 或 <code>int</code> 这样的简单数据类型，而是包装在 <code>Property</code> 类型中，这使得它们可以被observable(监听变化)，用于数据绑定等等。</p>
</div>
<div class="paragraph">
<p>因此，值提取需要能够对已包装的值应用约束。</p>
</div>
<div class="paragraph">
<p>JavaFX 的 <code>ObservableValue</code> 值提取器需要标注 <code>@UnwrapByDefault</code>。
因此，容器上承载的约束默认以包装后的值为目标。</p>
</div>
<div class="paragraph">
<p>因此，您可以像下面这样约束 <code>StringProperty</code> :</p>
</div>
<div class="exampleblock">
<div class="title">Example 92. 约束 <code>StringProperty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@NotBlank
private StringProperty stringProperty;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者约束 <code>LongProperty</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. 约束 <code>LongProperty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@Min(5)
private LongProperty longProperty;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可迭代的属性类型，即 <code>ReadOnlyListProperty</code> 、 <code>ListProperty</code>  及其 <code>Set</code> 和 <code>Map</code> 副本是泛型的，因此可以使用容器元素约束。因此，它们具有不用 <code>@UnwrapByDefault</code> 标记的特定值提取器。</p>
</div>
<div class="paragraph">
<p>可以像约束 <code>List</code> 那样约束 <code>ReadOnlyListProperty</code> :</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. 约束 <code>ReadOnlyListProperty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@Size(min = 1)
private ReadOnlyListProperty&lt;@NotBlank String&gt; listProperty;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-valueextraction-registeringvalueextractor"><a class="anchor" href="#section-valueextraction-registeringvalueextractor"></a>7.5. 注册一个 <code>ValueExtractor</code></h3>
<div class="paragraph">
<p>Hibernate Validator 不会自动检测classpath中的值提取器，因此必须注册它们。</p>
</div>
<div class="paragraph">
<p>有几种注册值提取器的方法(按优先级顺序递增) :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">由验证引擎本身提供</dt>
<dd>
<p>参见 <a href="#section-valueextraction-builtinvalueextractors">Section 7.1, &#8220;内置值提取器&#8221;</a>.</p>
</dd>
<dt class="hdlist1">通过 Java 服务加载器机制</dt>
<dd>
<p>文件 <code>META-INF/services/jakarta.validation.valueextraction.ValueExtractor</code>
必须以一个或多个值提取器实现的完全限定名作为其内容提供，每个都在单独的一行中。</p>
</dd>
<dt class="hdlist1">In the <code>META-INF/validation.xml</code> file</dt>
<dd>
<p>有关如何在 XML 配置中注册值提取器的更多信息， 参见 <a href="#section-configuration-validation-xml">Section 8.1, &#8220;配置 validator factory 通过 <em>validation.xml</em>&#8221;</a> 。</p>
</dd>
<dt class="hdlist1">By calling <code>Configuration#addValueExtractor(ValueExtractor&lt;?&gt;)</code></dt>
<dd>
<p>参见 <a href="#section-bootstrapping-valueextractors">Section 9.2.6, &#8220;注册 <code>ValueExtractor</code>s&#8221;</a></p>
</dd>
<dt class="hdlist1">By invoking <code>ValidatorContext#addValueExtractor(ValueExtractor&lt;?&gt;)</code></dt>
<dd>
<p>它只声明这个 Validator 实例的值提取器。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>对于给定的类型和类型参数，以较高优先级指定的值提取器会覆盖以较低优先级指定的相同类型和类型参数的任何其他提取器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_分辨率算法"><a class="anchor" href="#_分辨率算法"></a>7.6. 分辨率算法</h3>
<div class="paragraph">
<p>在大多数情况下，你不必担心这个问题，但是如果你覆盖了现有的值提取器，你可以在 Jakarta Bean Validation 规范中找到关于值提取器解析算法的详细描述:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>for <a href="http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-constraints">container element constraints</a>,</p>
</li>
<li>
<p>for <a href="http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-cascaded">cascaded validation</a>,</p>
</li>
<li>
<p>and for <a href="http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-implicitunwrapping">implicit unwrapping</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>记住一件重要的事情:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于容器元素约束，声明的类型用于解析值提取器;</p>
</li>
<li>
<p>对于级联验证，它是运行时类型。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-xml-configuration"><a class="anchor" href="#chapter-xml-configuration"></a>8. 通过 XML 配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，我们已经使用了 Jakarta Bean Validation 的默认配置源，即注解。然而，也有两种 描述符允许通过 XML 进行配置。第一个描述符描述了一般的 Jakarta Bean Validation 行为，并作为 <em>META-INF/validation.xml</em> 提供。第二个描述了约束声明，并通过注解与约束声明方法紧密匹配。让我们来看看这两种文档类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>XSD文件可以参看 <a href="https://jakarta.ee/xml/ns/validation/" class="bare">https://jakarta.ee/xml/ns/validation/</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="section-configuration-validation-xml"><a class="anchor" href="#section-configuration-validation-xml"></a>8.1. 配置 validator factory 通过 <em>validation.xml</em></h3>
<div class="paragraph">
<p>启用 Hibernate Validator 的 XML 配置的关键是文件 <em>META-INF/validation.xml</em> 。如果这个文件存在于classpath中，那么在创建 <code>ValidatorFactory</code> 时，它的配置将被应用。<a href="#image-validation-configuration">Figure 1, &#8220;Validation configuration schema&#8221;</a> 显示了 <em>validation.xml</em> 必须遵循的schema。</p>
</div>
<div id="image-validation-configuration" class="imageblock">
<div class="content">
<img src="validation-configuration-2.0.png" alt="validation-configuration-2.0.xsd">
</div>
<div class="title">Figure 1. Validation configuration schema</div>
</div>
<div class="paragraph">
<p><a href="#example-validation-xml">Example 95, &#8220;<code>validation.xml</code>&#8221;</a> 展示了 <em>validation.xml</em> 的几个配置选项。所有设置都是可选的，同样的配置选项也可以通过 <code>jakarta.validation.Configuration</code> 以编程方式提供。实际上，XML 配置将被通过编程 API 显式指定的值覆盖。甚至可以通过 <code>Configuration#ignoreXmlConfiguration()</code> 完全忽略 XML 配置。另见<a href="#section-configuring-validator-factory">Section 9.2, &#8220;配置 <code>ValidatorFactory</code>&#8221;</a>。</p>
</div>
<div id="example-validation-xml" class="exampleblock">
<div class="title">Example 95. <code>validation.xml</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;validation-config
        xmlns="https://jakarta.ee/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/configuration
            https://jakarta.ee/xml/ns/validation/validation-configuration-3.0.xsd"
        version="3.0"&gt;

    &lt;default-provider&gt;com.acme.ValidationProvider&lt;/default-provider&gt;

    &lt;message-interpolator&gt;com.acme.MessageInterpolator&lt;/message-interpolator&gt;
    &lt;traversable-resolver&gt;com.acme.TraversableResolver&lt;/traversable-resolver&gt;
    &lt;constraint-validator-factory&gt;
        com.acme.ConstraintValidatorFactory
    &lt;/constraint-validator-factory&gt;
    &lt;parameter-name-provider&gt;com.acme.ParameterNameProvider&lt;/parameter-name-provider&gt;
    &lt;clock-provider&gt;com.acme.ClockProvider&lt;/clock-provider&gt;

    &lt;value-extractor&gt;com.acme.ContainerValueExtractor&lt;/value-extractor&gt;

    &lt;executable-validation enabled="true"&gt;
        &lt;default-validated-executable-types&gt;
            &lt;executable-type&gt;CONSTRUCTORS&lt;/executable-type&gt;
            &lt;executable-type&gt;NON_GETTER_METHODS&lt;/executable-type&gt;
            &lt;executable-type&gt;GETTER_METHODS&lt;/executable-type&gt;
        &lt;/default-validated-executable-types&gt;
    &lt;/executable-validation&gt;

    &lt;constraint-mapping&gt;META-INF/validation/constraints-car.xml&lt;/constraint-mapping&gt;

    &lt;property name="hibernate.validator.fail_fast"&gt;false&lt;/property&gt;
&lt;/validation-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>classpath中必须只有一个名为 <em>META-INF/validation.xml</em> 的文件。如果发现多于一个，则抛出异常。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>default-provider</code> 允许选择 Jakarta Bean Validation 实现程序。如果classpath中有多个实现程序，则此选项非常有用。<code>message-interpolator</code>, <code>traversable-resolver</code>,
<code>constraint-validator-factory</code>, <code>parameter-name-provider</code> 和 <code>clock-provider</code> 的配置，分别用于指定 <code>MessageInterpolator</code>, <code>TraversableResolver</code>,
<code>ConstraintValidatorFactory</code>, <code>ParameterNameProvider</code> 和 <code>ClockProvider</code> 接口的具体实现。有关这些接口的更多信息，请参阅 <a href="#section-configuring-validator-factory">Section 9.2, &#8220;配置 <code>ValidatorFactory</code>&#8221;</a>  。</p>
</div>
<div class="paragraph">
<p><code>value-extractor</code> 允许声明附加的值提取器，以便从自定义容器类型中提取值或者覆盖内置的值提取器。有关如何实现 <code>jakarta.validation.valueextraction.ValueExtractor</code> ，参考 <a href="#chapter-valueextraction">Chapter 7, <em>值提取</em></a> 。</p>
</div>
<div class="paragraph">
<p><code>executable-validation</code> 和它的子节点定义了method约束的默认值。Jakarta Bean Validation 规范将构造函数和非 getter 方法定义为默认值。这个属性充当启用和关闭方法验证的全局切换(参见 <a href="#chapter-method-constraints">Chapter 3, <em>声明和校验 method 约束</em></a>)。</p>
</div>
<div class="paragraph">
<p>通过 <code>constraint-mapping</code> 配置，你需要列举出所有约束配置相关的 XML 文件。映射文件名必须使用其在classpath中的完全限定名指定。关于编写映射文件的详细信息可在下一节中找到。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的一点是，您可以通过 <code>property</code> 节点指定提供程序特定的属性。在这个例子中，我们使用了特定于 Hibernate Validator 的 <code>hibernate.validator.fail_fast</code> 属性(参见<a href="#section-fail-fast">Section 12.2, &#8220;快速失败模式&#8221;</a>)。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-mapping-xml-constraints"><a class="anchor" href="#section-mapping-xml-constraints"></a>8.2. 通过 <code>constraint-mappings</code> 映射约束</h3>
<div class="paragraph">
<p>可以通过文件来表达 XML 中的约束，这些文件遵循 <a href="#image-mapping-configuration">Figure 2, &#8220;Validation mapping schema&#8221;</a> 。注意，只有在 <em>validation.xml</em> 中通过约束映射列出这些映射文件时，才会处理它们。</p>
</div>
<div id="image-mapping-configuration" class="imageblock">
<div class="content">
<img src="validation-mapping-2.0.png" alt="validation-mapping-2.0.xsd">
</div>
<div class="title">Figure 2. Validation mapping schema</div>
</div>
<div class="paragraph">
<p><a href="#example-constraints-car">Example 96, &#8220;通过 XML 配置 Bean 约束&#8221;</a> 将 <a href="#example-car">Example 51, &#8220;Car类&#8221;</a> 中的 Car 和 <a href="#example-rental-car">Example 57, &#8220;为 <code>RentalCar</code> 重新定义默认分组&#8221;</a> 中的 RentalCar  类映射成 XML。</p>
</div>
<div id="example-constraints-car" class="exampleblock">
<div class="title">Example 96. 通过 XML 配置 Bean 约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;constraint-mappings
        xmlns="https://jakarta.ee/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/mapping
            https://jakarta.ee/xml/ns/validation/validation-mapping-3.0.xsd"
        version="3.0"&gt;

    &lt;default-package&gt;org.hibernate.validator.referenceguide.chapter05&lt;/default-package&gt;
    &lt;bean class="Car" ignore-annotations="true"&gt;
        &lt;field name="manufacturer"&gt;
            &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
        &lt;/field&gt;
        &lt;field name="licensePlate"&gt;
            &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
        &lt;/field&gt;
        &lt;field name="seatCount"&gt;
            &lt;constraint annotation="jakarta.validation.constraints.Min"&gt;
                &lt;element name="value"&gt;2&lt;/element&gt;
            &lt;/constraint&gt;
        &lt;/field&gt;
        &lt;field name="driver"&gt;
            &lt;valid/&gt;
        &lt;/field&gt;
        &lt;field name="partManufacturers"&gt;
            &lt;container-element-type type-argument-index="0"&gt;
                &lt;valid/&gt;
            &lt;/container-element-type&gt;
            &lt;container-element-type type-argument-index="1"&gt;
                &lt;container-element-type&gt;
                    &lt;valid/&gt;
                    &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
                &lt;/container-element-type&gt;
            &lt;/container-element-type&gt;
        &lt;/field&gt;
        &lt;getter name="passedVehicleInspection" ignore-annotations="true"&gt;
            &lt;constraint annotation="jakarta.validation.constraints.AssertTrue"&gt;
                &lt;message&gt;The car has to pass the vehicle inspection first&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;CarChecks&lt;/value&gt;
                &lt;/groups&gt;
                &lt;element name="max"&gt;10&lt;/element&gt;
            &lt;/constraint&gt;
        &lt;/getter&gt;
    &lt;/bean&gt;
    &lt;bean class="RentalCar" ignore-annotations="true"&gt;
        &lt;class ignore-annotations="true"&gt;
            &lt;group-sequence&gt;
                &lt;value&gt;RentalCar&lt;/value&gt;
                &lt;value&gt;CarChecks&lt;/value&gt;
            &lt;/group-sequence&gt;
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;constraint-definition annotation="org.mycompany.CheckCase"&gt;
        &lt;validated-by include-existing-validators="false"&gt;
            &lt;value&gt;org.mycompany.CheckCaseValidator&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-rental-station-xml">Example 97, &#8220;通过 XML 配置的方法约束&#8221;</a> 展示了
<a href="#example-declaring-parameter-constraints">Example 27, &#8220;声明方法和构造函数参数约束&#8221;</a>, <a href="#example-declaring-return-value-constraints">Example 30, &#8220;声明方法和构造函数返回值约束&#8221;</a>
和 <a href="#example-specifying-constraint-target">Example 29, &#8220;指定约束的目标&#8221;</a> 使用的方法约束，也可以被XML文件表示。</p>
</div>
<div id="example-rental-station-xml" class="exampleblock">
<div class="title">Example 97. 通过 XML 配置的方法约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;constraint-mappings
        xmlns="https://jakarta.ee/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/mapping
            https://jakarta.ee/xml/ns/validation/validation-mapping-3.0.xsd"
        version="3.0"&gt;

    &lt;default-package&gt;org.hibernate.validator.referenceguide.chapter08&lt;/default-package&gt;

    &lt;bean class="RentalStation" ignore-annotations="true"&gt;
        &lt;constructor&gt;
            &lt;return-value&gt;
                &lt;constraint annotation="ValidRentalStation"/&gt;
            &lt;/return-value&gt;
        &lt;/constructor&gt;

        &lt;constructor&gt;
            &lt;parameter type="java.lang.String"&gt;
                &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
            &lt;/parameter&gt;
        &lt;/constructor&gt;

        &lt;method name="getCustomers"&gt;
            &lt;return-value&gt;
                &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
                &lt;constraint annotation="jakarta.validation.constraints.Size"&gt;
                    &lt;element name="min"&gt;1&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/return-value&gt;
        &lt;/method&gt;

        &lt;method name="rentCar"&gt;
            &lt;parameter type="Customer"&gt;
                &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
            &lt;/parameter&gt;
            &lt;parameter type="java.util.Date"&gt;
                &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
                &lt;constraint annotation="jakarta.validation.constraints.Future"/&gt;
            &lt;/parameter&gt;
            &lt;parameter type="int"&gt;
                &lt;constraint annotation="jakarta.validation.constraints.Min"&gt;
                    &lt;element name="value"&gt;1&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/parameter&gt;
        &lt;/method&gt;

        &lt;method name="addCars"&gt;
            &lt;parameter type="java.util.List"&gt;
                &lt;container-element-type&gt;
                    &lt;valid/&gt;
                    &lt;constraint annotation="jakarta.validation.constraints.NotNull"/&gt;
                &lt;/container-element-type&gt;
            &lt;/parameter&gt;
        &lt;/method&gt;
    &lt;/bean&gt;

    &lt;bean class="Garage" ignore-annotations="true"&gt;
        &lt;method name="buildCar"&gt;
            &lt;parameter type="java.util.List"/&gt;
            &lt;cross-parameter&gt;
                &lt;constraint annotation="ELAssert"&gt;
                    &lt;element name="expression"&gt;...&lt;/element&gt;
                    &lt;element name="validationAppliesTo"&gt;PARAMETERS&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/cross-parameter&gt;
        &lt;/method&gt;
        &lt;method name="paintCar"&gt;
            &lt;parameter type="int"/&gt;
            &lt;return-value&gt;
                &lt;constraint annotation="ELAssert"&gt;
                    &lt;element name="expression"&gt;...&lt;/element&gt;
                    &lt;element name="validationAppliesTo"&gt;RETURN_VALUE&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/return-value&gt;
        &lt;/method&gt;
    &lt;/bean&gt;

&lt;/constraint-mappings&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>XML 配置和采用编程注解的效果是一样的。出于这个原因，建议在程序中添加一些注解就足够了。 <code>default-package</code> 用于需要类名的所有字段。如果指定的类没有完全限定，则将使用已配置的默认包。然后，每个映射文件可以有几个 bean 节点，每个 bean 节点用指定的类名描述实体上的约束。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一个类只能跨所有配置文件配置一次。对于给定的约束注解，约束定义也是如此。它只能出现在一个映射文件中。如果违反了这些规则，就会抛出 <code>ValidationException</code> 异常。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将 <code>ignore-annotations</code> 设置为 <code>true</code> 意味着放置在配置 bean 上的约束注解将被忽略。此值的默认值为 true。<code>ignore-annotations</code> 也可用于 <code>class</code>, <code>fields</code>, <code>getter</code>, <code>constructor</code>, <code>method</code>, <code>parameter</code>, <code>cross-parameter</code> and <code>return-value</code>。如果未在这些级别上显式指定，则默认配置为true。</p>
</div>
<div class="paragraph">
<p><code>class</code>, <code>field</code>, <code>getter</code>, <code>container-element-type</code>, <code>constructor</code> 和 <code>method</code> 节点(以及他们的子节点参数)决定了约束放置在哪个级别。<code>valid</code> 节点用于启用级联验证和约束节点在相应级别上添加约束。每个约束定义必须通过 <code>annotation</code> 定义类。Jakarta Bean Validation 规范(<code>message</code>, <code>groups</code> and
<code>payload</code>)所需的约束属性具有专用节点。所有其他特定于约束的属性都是使用元素节点配置的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>container-element-type</code> 允许为容器元素定义级联验证行为和约束。在上面的例子中，您可以看到一个嵌套在 <code>Map</code> 值中的 <code>List</code> 上的嵌套容器元素约束的例子。 <code>type-argument-index</code> 用于精确地确定映射的类型参数与配置有关。如果类型只有一个类型参数(例如，示例中的 <code>List</code>s ) ，则可以省略它。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>class</code> 节点还允许通过组序列节点重新配置默认的组序列(参见<a href="#section-default-group-class">Section 5.4, &#8220;重新定义默认组序列&#8221;</a>)。示例中没有显示使用 <code>group-sequence</code> 来指定组转换(参见<a href="#section-group-conversion">Section 5.5, &#8220;分组转化&#8221;</a>)。该节点可用于 <code>field</code>,
<code>getter</code>, <code>container-element-type</code>, <code>parameter</code> 和 <code>return-value</code>，并指定 <code>from</code> 和 <code>to</code> 属性以指定组。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的一点是，可以通过 <code>constraint-definition</code> 节点更改与给定约束关联的 <code>ConstraintValidator</code> 实例列表。注解属性表示被修改的约束注解。<code>validated-by</code> 元素表示与约束关联的 <code>ConstraintValidator</code> 实现的(有序的)列表。如果 <code>include-existing-validator</code> 设置为 <code>false</code> ，则会忽略约束注解上定义的验证器。如果设置为 <code>true</code> ，则 XML 中描述的约束验证器列表将连接到注解中指定的验证器列表。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>constraint-definition 的一个用例是更改 <code>@URL</code> 的默认约束定义。从历史上看，Hibernate Validator 针对此约束的默认约束验证器使用 <code>java.net.URL</code>  构造函数来验证 URL 是否有效。然而，也有一个纯粹基于正则表达式的版本，可以使用 XML 进行配置:</p>
</div>
<div class="listingblock">
<div class="title">使用 XML 注册基于正则表达式的约束定义 <code>@URL</code></div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;constraint-definition annotation="org.hibernate.validator.constraints.URL"&gt;
  &lt;validated-by include-existing-validators="false"&gt;
    &lt;value&gt;org.hibernate.validator.constraintvalidators.RegexpURLValidator&lt;/value&gt;
  &lt;/validated-by&gt;
&lt;/constraint-definition&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter-bootstrapping"><a class="anchor" href="#chapter-bootstrapping"></a>9. Bootstrapping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <a href="#section-obtaining-validator">Section 2.2.1, &#8220;获取 <code>Validator</code> 实例&#8221;</a>,您已经看到了一种创建 <code>Validator</code> 实例的方法 - 通过
<code>Validation#buildDefaultValidatorFactory()</code>。在本章中，您将学习如何使用 <code>jakarta.validation.Validation</code> 中的其他方法。以便引导生成特定配置的校验器。</p>
</div>
<div class="sect2">
<h3 id="section-retrieving-validator-factory-validator"><a class="anchor" href="#section-retrieving-validator-factory-validator"></a>9.1. 获取 <code>ValidatorFactory</code> 和 <code>Validator</code></h3>
<div class="paragraph">
<p>你可以通过 <code>jakarta.validation.Validation</code> 的静态方法获取一个 <code>ValidatorFactory</code> 实例。再通过调用 <code>ValidatorFactory</code> 工厂实例的 <code>getValidator()</code> 方法获取 <code>Validator</code> 对象。</p>
</div>
<div class="paragraph">
<p><a href="#example-build-default-validator-factory">Example 98, &#8220;获取默认 <code>ValidatorFactory</code> 以及 <code>Validator</code>&#8221;</a> 展示了如何从默认校验器工厂获得校验器:</p>
</div>
<div id="example-build-default-validator-factory" class="exampleblock">
<div class="title">Example 98. 获取默认 <code>ValidatorFactory</code> 以及 <code>Validator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>生成的 <code>ValidatorFactory</code> 和 <code>Validator</code> 实例是线程安全的，可以进行缓存。由于 Hibernate Validator 使用工厂作为缓存约束元数据的上下文，因此建议在应用程序中只使用一个工厂实例。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jakarta Bean Validation 支持在一个应用程序中多个provider(如 Hibernate Validator)一起工作。但是如果在classpath中存在多个provider，则不能保证在通过  <code>buildDefaultValidatorFactory()</code> 创建工厂时选择哪个provider。</p>
</div>
<div class="paragraph">
<p>在这种情况下，您可以通过 <code>Validation#byProvider()</code> 显式指定要使用的provider，传递provider的 <code>ValidationProvider</code> 类，如<a href="#example-using-specific-provider">Example 99, &#8220;获取 <code>ValidatorFactory</code> 和 <code>Validator</code> 通过指定的provider&#8221;</a>。</p>
</div>
<div id="example-using-specific-provider" class="exampleblock">
<div class="title">Example 99. 获取 <code>ValidatorFactory</code> 和 <code>Validator</code> 通过指定的provider</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意， <code>configure()</code> 返回的配置对象允许在调用 <code>buildValidatorFactory()</code> 之前专门定制工厂实例。本章后面将讨论可用的配置选项。</p>
</div>
<div class="paragraph">
<p>类似地，您可以获取默认配置的校验器工厂，如<a href="#example-configuring-default-provider">Example 100, &#8220;获取默认配置的 <code>ValidatorFactory</code>&#8221;</a>。</p>
</div>
<div id="example-configuring-default-provider" class="exampleblock">
<div class="title">Example 100. 获取默认配置的 <code>ValidatorFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果 <code>ValidatorFactory</code> 实例不再使用，应该通过调用 <code>ValidatorFactory#close()</code> 来释放它。同时将释放掉给工厂分配的所有资源。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="section-validation-provider-resolver"><a class="anchor" href="#section-validation-provider-resolver"></a>9.1.1. <code>ValidationProviderResolver</code></h4>
<div class="paragraph">
<p>默认情况下，可用的 Jakarta Bean Validation provider是通过使用 <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider">Java
Service Provider</a> 机制发现的。</p>
</div>
<div class="paragraph">
<p>为此，每个提供者都包含文件 <em>META-
INF/services/jakarta.validation.spi.ValidationProvider</em> ，包含其 <code>ValidationProvider</code> 实现的完全限定类名。对于 Hibernate Validator，这是 <code>org.hibernate.validator.HibernateValidator</code>。</p>
</div>
<div class="paragraph">
<p>根据您的环境及其类加载细节，Java 的服务加载器机制(SPI)可能无法工作。在这种情况下，您可以插入用于执行provider检索的自定义 <code>ValidationProviderResolver</code> 实现。一个例子是 OSGi，您可以在其中实现使用 OSGi 服务进行提供者发现的提供者解析器。</p>
</div>
<div class="paragraph">
<p>要使用自定义provider解析器，请通过 <code>providerResolver()</code> 传递它，如<a href="#example-using-custom-validation-provider-resolver">Example 101, &#8220;使用自定义 <code>ValidationProviderResolver</code>&#8221;</a>。</p>
</div>
<div id="example-using-custom-validation-provider-resolver" class="exampleblock">
<div class="title">Example 101. 使用自定义 <code>ValidationProviderResolver</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

public class OsgiServiceDiscoverer implements ValidationProviderResolver {

	@Override
	public List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders() {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.providerResolver( new OsgiServiceDiscoverer() )
		.configure()
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-configuring-validator-factory"><a class="anchor" href="#section-configuring-validator-factory"></a>9.2. 配置 <code>ValidatorFactory</code></h3>
<div class="paragraph">
<p>默认情况下，从 <code>Validation</code> 获取到的校验器工厂和它们创建的任何校验器都是根据 XML 描述符  <em>META-INF/validation.xml</em>  (参见<a href="#chapter-xml-configuration">Chapter 8, <em>通过 XML 配置</em></a>)配置的。</p>
</div>
<div class="paragraph">
<p>如果希望禁用基于 XML 的配置，可以通过调用 <code>Configuration#ignoreXmlConfiguration()</code> 来禁用。</p>
</div>
<div class="paragraph">
<p>XML 配置的不同值可以通过 <code>Configuration#getBootstrapConfiguration()</code> 访问。例如，如果您希望将 Jakarta Bean Validation 集成到托管环境中，并希望创建通过 XML 配置的对象的托管实例，那么这可能会很有帮助。</p>
</div>
<div class="paragraph">
<p>使用 fluent 配置 API，可以在引导 factory 时覆盖一个或多个默认配置。下面的部分将展示如何使用不同的配置选项。注意， <code>Configuration</code> 类公开了不同扩展点的默认实现，如果您希望将这些扩展点用作自定义实现的委托，那么这些扩展点非常有用。</p>
</div>
<div class="sect3">
<h4 id="section-validator-factory-message-interpolator"><a class="anchor" href="#section-validator-factory-message-interpolator"></a>9.2.1. <code>MessageInterpolator</code></h4>
<div class="paragraph">
<p>校验引擎使用Message interpolators(消息内插器)从约束消息描述符创建用户可读的错误消息。</p>
</div>
<div class="paragraph">
<p>如果在<a href="#chapter-message-interpolation">Chapter 4, <em>添加约束错误消息</em></a>中插值约束错误消息不足以满足您的需要，您可以通过配置 <code>Configuration#messageInterpolator()</code> 传递您自己的 <code>MessageInterpolator</code> 接口实现，如<a href="#example-using-custom-message-interpolator">Example 102, &#8220;使用自定义 <code>MessageInterpolator</code>&#8221;</a>。</p>
</div>
<div id="example-using-custom-message-interpolator" class="exampleblock">
<div class="title">Example 102. 使用自定义 <code>MessageInterpolator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

public class MyMessageInterpolator implements MessageInterpolator {

	@Override
	public String interpolate(String messageTemplate, Context context) {
		//...
		return null;
	}

	@Override
	public String interpolate(String messageTemplate, Context context, Locale locale) {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator( new MyMessageInterpolator() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-validator-factory-traversable-resolver"><a class="anchor" href="#section-validator-factory-traversable-resolver"></a>9.2.2. <code>TraversableResolver</code></h4>
<div class="paragraph">
<p>在某些情况下，校验引擎不应该访问 bean 属性的状态。最明显的例子是 JPA 的延迟加载的属性或关联实体。校验这个延迟属性或关联意味着必须访问它的状态，从而触发数据库的加载。</p>
</div>
<div class="paragraph">
<p>通过查询 <code>TraversableResolver</code> 接口，可以访问哪些属性，哪些属性不受控制。<a href="#example-using-custom-traversable-resolver">Example 103, &#8220;使用自定义 <code>TraversableResolver</code>&#8221;</a> 展示了如何使用自定义可遍历解析器实现。</p>
</div>
<div id="example-using-custom-traversable-resolver" class="exampleblock">
<div class="title">Example 103. 使用自定义 <code>TraversableResolver</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

public class MyTraversableResolver implements TraversableResolver {

	@Override
	public boolean isReachable(
			Object traversableObject,
			Node traversableProperty,
			Class&lt;?&gt; rootBeanType,
			Path pathToTraversableObject,
			ElementType elementType) {
		//...
		return false;
	}

	@Override
	public boolean isCascadable(
			Object traversableObject,
			Node traversableProperty,
			Class&lt;?&gt; rootBeanType,
			Path pathToTraversableObject,
			ElementType elementType) {
		//...
		return false;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.traversableResolver( new MyTraversableResolver() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有配置特定的可遍历解析器，则默认行为是将所有属性视为可访问和级联的。当 Hibernate Validator 和 JPA 2实现程序(如 Hibernate ORM)一起使用时，只有那些已经被持久层提供程序(ORM框架)加载的属性才被认为是可访问的，所有属性都被认为是级联的。</p>
</div>
<div class="paragraph">
<p>默认情况下，每个校验调用都缓存可遍历的解析程序返回的结果。这在 JPA 环境中特别重要，因为在这种环境中调用 <code>isReachable()</code> 的成本很高。</p>
</div>
<div class="paragraph">
<p>这种缓存会增加一些开销。如果您的自定义可遍历解析器非常快，那么最好考虑关闭缓存。</p>
</div>
<div class="paragraph">
<p>你可以通过 XML 配置来禁用缓存:</p>
</div>
<div id="example-disabling-traversable-resolver-result-cache-xml-configuration" class="exampleblock">
<div class="title">Example 104. 通过XML配置禁用 <code>TraversableResolver</code> 结果缓存</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="https://jakarta.ee/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/configuration https://jakarta.ee/xml/ns/validation/validation-configuration-3.0.xsd"
        version="3.0"&gt;
    &lt;default-provider&gt;org.hibernate.validator.HibernateValidator&lt;/default-provider&gt;

    &lt;property name="hibernate.validator.enable_traversable_resolver_result_cache"&gt;false&lt;/property&gt;
&lt;/validation-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者通过调用相关API:</p>
</div>
<div id="example-disabling-traversable-resolver-result-cache-programmatic-api" class="exampleblock">
<div class="title">Example 105. 通过API禁用 <code>TraversableResolver</code> 缓存结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.traversableResolver( new MyFastTraversableResolver() )
		.enableTraversableResolverResultCache( false )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraintvalidatorfactory"><a class="anchor" href="#_constraintvalidatorfactory"></a>9.2.3. <code>ConstraintValidatorFactory</code></h4>
<div class="paragraph">
<p><code>ConstraintValidatorFactory</code> 是用于自定义约束校验器如何实例化和释放的扩展点。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 提供的默认 <code>ConstraintValidatorFactory</code> 需要一个public的无参构造函数来实例化 <code>ConstraintValidator</code> 实例(参见<a href="#section-constraint-validator">Section 6.1.2, &#8220;约束校验器&#8221;</a>)。使用自定义 <code>ConstraintValidatorFactory</code> 可以提供在约束校验器(ConstraintValidator)实现中使用依赖注入。</p>
</div>
<div class="paragraph">
<p>要配置自定义约束校验器工厂，请调用 <code>Configuration#constraintValidatorFactory()</code> (<a href="#example-using-custom-constraint-validator-factory">Example 106, &#8220;使用自定义 <code>ConstraintValidatorFactory</code>&#8221;</a>)。</p>
</div>
<div id="example-using-custom-constraint-validator-factory" class="exampleblock">
<div class="title">Example 106. 使用自定义 <code>ConstraintValidatorFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

public class MyConstraintValidatorFactory implements ConstraintValidatorFactory {

	@Override
	public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(Class&lt;T&gt; key) {
		//...
		return null;
	}

	@Override
	public void releaseInstance(ConstraintValidator&lt;?, ?&gt; instance) {
		//...
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.constraintValidatorFactory( new MyConstraintValidatorFactory() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>任何依赖于特定于实现的 <code>ConstraintValidatorFactory</code>  行为的约束实现(依赖注入、无参数构造函数等等)都不被认为是可移植的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ConstraintValidatorFactory</code> 实现不应该缓存校验器实例，因为每个实例的状态都可以在   <code>initialize()</code> 方法中更改。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-parameter-name-provider"><a class="anchor" href="#section-parameter-name-provider"></a>9.2.4. <code>ParameterNameProvider</code></h4>
<div class="paragraph">
<p>在违反方法或构造函数参数约束的情况下，将使用 <code>ParameterNameProvider</code> 检索参数名称，并通过违反约束的属性路径将其提供给用户。</p>
</div>
<div class="paragraph">
<p>默认实现是通过 Java 反射 API 获得的参数名。如果使用 <code>-parameters</code> 编译器标志编译源代码，则会返回源代码中的实际参数名称。否则，将使用 <code>arg0</code> 、 <code>arg1</code> 等形式的合成名称。</p>
</div>
<div class="paragraph">
<p>要使用自定义参数名称提供程序，可以在引导期间传递提供程序的实例，如<a href="#example-using-custom-parameter-name-provider">Example 107, &#8220;使用自定义 <code>ParameterNameProvider</code>&#8221;</a>，或者指定提供程序的完全限定类名作为 <em>META-INF/validation.xml</em> 文件中的 <code>&lt;parameter-name-provider&gt;</code> 节点的值(参见<a href="#section-configuration-validation-xml">Section 8.1, &#8220;配置 validator factory 通过 <em>validation.xml</em>&#8221;</a>)。示例<a href="#example-using-custom-parameter-name-provider">Example 107, &#8220;使用自定义 <code>ParameterNameProvider</code>&#8221;</a>演示了这一点。</p>
</div>
<div id="example-using-custom-parameter-name-provider" class="exampleblock">
<div class="title">Example 107. 使用自定义 <code>ParameterNameProvider</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

public class MyParameterNameProvider implements ParameterNameProvider {

	@Override
	public List&lt;String&gt; getParameterNames(Constructor&lt;?&gt; constructor) {
		//...
		return null;
	}

	@Override
	public List&lt;String&gt; getParameterNames(Method method) {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.parameterNameProvider( new MyParameterNameProvider() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Validator 提供了一个基于 <a href="https://github.com/paul-hammant/paranamer/">ParaNamer</a> 库的自定义 <code>ParameterNameProvider</code> 实现，它提供了几种在运行时获取参数名称的方法。请参阅<a href="#section-paranamer-parameternameprovider">Section 12.14, &#8220;基于 Paranamer 的 <code>ParameterNameProvider</code>&#8221;</a>以了解关于这个特定实现的更多信息。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-clock-provider"><a class="anchor" href="#section-clock-provider"></a>9.2.5. <code>ClockProvider</code> 和时间校验容忍度</h4>
<div class="paragraph">
<p>对于与时间相关的校验(例如 <code>@Past</code> 和 <code>@Future</code> 约束) ，很值得思考如何表示 <code>now</code>。</p>
</div>
<div class="paragraph">
<p>当您希望以可靠的方式测试约束时，这一点尤其重要。</p>
</div>
<div class="paragraph">
<p>引用时间由 <code>ClockProvider</code> <code>ClockProvider</code> 的职责是提供一个 <code>java.time.Clock</code> 定义 <code>now</code> 提供给时间相关的校验器使用。</p>
</div>
<div id="example-using-custom-clock-provider" class="exampleblock">
<div class="title">Example 108. 使用自定义 <code>ClockProvider</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

import java.time.Clock;
import java.time.ZonedDateTime;

import jakarta.validation.ClockProvider;

public class FixedClockProvider implements ClockProvider {

	private Clock clock;

	public FixedClockProvider(ZonedDateTime dateTime) {
		clock = Clock.fixed( dateTime.toInstant(), dateTime.getZone() );
	}

	@Override
	public Clock getClock() {
		return clock;
	}

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.clockProvider( new FixedClockProvider( ZonedDateTime.of( 2016, 6, 15, 0, 0, 0, 0, ZoneId.of( "Europe/Paris" ) ) ) )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，在通过 <em>META-INF/validation.xml</em> 配置默认校验器工厂时，您可以使用 <code>&lt;clock-provider&gt;</code> 元素指定 <code>ClockProvider</code> 实现的完全限定类名(参见<a href="#chapter-xml-configuration">Chapter 8, <em>通过 XML 配置</em></a>)。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在校验 <code>@Future</code> 和 <code>@Past</code> 约束时，您可能希望获得当前时间。</p>
</div>
<div class="paragraph">
<p>您可以通过调用 <code>ConstraintValidatorContext#getClockProvider()</code> 方法来获得校验器中的  <code>ClockProvider</code> 。</p>
</div>
<div class="paragraph">
<p>例如，如果希望用更明确的消息替换 <code>@Future</code> 约束的缺省消息，这可能很有用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在处理分布式体系架构时，在应用诸如 <code>@Past</code> 或 <code>@Future</code> 这样的时间约束时，您可能需要一定的容错能力。</p>
</div>
<div class="paragraph">
<p>通过引导 <code>ValidatorFactory</code> ，可以设置时间校验容忍度，如下所示:</p>
</div>
<div id="example-using-temporal-validation-tolerance" class="exampleblock">
<div class="title">Example 109. 使用时间校验公差</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.temporalValidationTolerance( Duration.ofMillis( 10 ) )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以在 XML 配置中定义它，方法是在 <em>META-INF/validation.xml</em> 中设置 <code>hibernate.validator.temporal_validation_tolerance</code> 属性。</p>
</div>
<div class="paragraph">
<p>此属性的值必须为 <code>long</code> ，以毫秒为单位定义公差。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在实现您自己的时间约束时，您可能需要访问时间校验容忍度。</p>
</div>
<div class="paragraph">
<p>可以通过调用 <code>HibernateConstraintValidatorInitializationContext#getTemporalValidationTolerance()</code> 方法获得。</p>
</div>
<div class="paragraph">
<p>注意，要在初始化时访问这个上下文，约束校验器必须实现 <code>HibernateConstraintValidator</code> 契约(参见<a href="#constraint-validator-hibernateconstraintvalidator">Section 6.1.2.2, &#8220;The <code>HibernateConstraintValidator</code>  扩展&#8221;</a>)。这份合同目前被标记为正在酝酿之中: 未来可能会发生变化。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-bootstrapping-valueextractors"><a class="anchor" href="#section-bootstrapping-valueextractors"></a>9.2.6. 注册 <code>ValueExtractor</code>s</h4>
<div class="paragraph">
<p>正如在<a href="#chapter-valueextraction">Chapter 7, <em>值提取</em></a>中提到的，值提取器可以在引导过程中注册(参见<a href="#section-valueextraction-registeringvalueextractor">Section 7.5, &#8220;注册一个 <code>ValueExtractor</code>&#8221;</a>的其他注册值提取器的方法)。</p>
</div>
<div class="paragraph">
<p><a href="#example-registering-value-extractor">Example 110, &#8220;注册值提取器&#8221;</a> 展示了我们如何注册先前创建的值提取器，以提取 Guava 的 <code>Multimap</code> 的键和值。</p>
</div>
<div id="example-registering-value-extractor" class="exampleblock">
<div class="title">Example 110. 注册值提取器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.addValueExtractor( new MultimapKeyValueExtractor() )
		.addValueExtractor( new MultimapValueValueExtractor() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_添加映射流"><a class="anchor" href="#_添加映射流"></a>9.2.7. 添加映射流</h4>
<div class="paragraph">
<p>如前所述，您可以使用基于 XML 的约束映射配置应用于 Java beans 的约束。</p>
</div>
<div class="paragraph">
<p>除了  <em>META-INF/validation.xml</em> 中指定的映射文件之外，还可以通过 <code>Configuration#addMapping()</code> 添加进一步的映射(参见<a href="#example-adding-mapping-streams">Example 111, &#8220;添加约束映射流&#8221;</a>)。注意，传递的输入流必须遵守<a href="#section-mapping-xml-constraints">Section 8.2, &#8220;通过 <code>constraint-mappings</code> 映射约束&#8221;</a>中提出的约束映射的 XML 模式。</p>
</div>
<div id="example-adding-mapping-streams" class="exampleblock">
<div class="title">Example 111. 添加约束映射流</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">InputStream constraintMapping1 = null;
InputStream constraintMapping2 = null;
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.addMapping( constraintMapping1 )
		.addMapping( constraintMapping2 )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在创建了校验器工厂之后，应该关闭所有传递的输入流。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-provider-specific-settings"><a class="anchor" href="#section-provider-specific-settings"></a>9.2.8. Provider-specific 配置</h4>
<div class="paragraph">
<p>通过 <code>Validation#byProvider()</code> ()返回的配置对象，可以配置 <code>Provider-specific</code> 。</p>
</div>
<div class="paragraph">
<p>对于 Hibernate Validator，这个例子允许您启用故障快速模式并传递一个或多个编程约束映射，如<a href="#example-hibernate-validator-specific-options">Example 112, &#8220;设置特定于 Hibernate Validator 的选项&#8221;</a>所示。</p>
</div>
<div id="example-hibernate-validator-specific-options" class="exampleblock">
<div class="title">Example 112. 设置特定于 Hibernate Validator 的选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.failFast( true )
		.addMapping( (ConstraintMapping) null )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另外，provider-specific 的选项可以通过 <code>Configuration#addProperty()</code> 传递。 Hibernate Validator 也支持以这种方式启用故障快速模式:</p>
</div>
<div id="example-hibernate-validator-specific-option-via-addproperty" class="exampleblock">
<div class="title">Example 113. 通过 <code>addProperty()</code> 方式启用 Hibernate Validator 特定选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.addProperty( "hibernate.validator.fail_fast", "true" )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="#section-fail-fast">Section 12.2, &#8220;快速失败模式&#8221;</a>和<a href="#section-programmatic-api">Section 12.4, &#8220;可编程约束的定义和声明&#8221;</a>，以了解有关 Fail fast mode 和 constraint declaration API 的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-script-evaluator-factory"><a class="anchor" href="#section-script-evaluator-factory"></a>9.2.9. 配置 <code>ScriptEvaluatorFactory</code></h4>
<div class="paragraph">
<p>对于像 <code>@ScriptAssert</code> 和 <code>@ParameterScriptAssert</code> 这样的约束，可以配置如何初始化脚本引擎以及如何构建脚本计算器。这可以通过设置 <code>ScriptEvaluatorFactory</code> 的自定义实现来实现。</p>
</div>
<div class="paragraph">
<p>特别是，这对于模块化环境(例如 OSGi)非常重要，在这种环境中，用户可能会遇到模块化类加载和 <a href="https://www.jcp.org/en/jsr/detail?id=223">JSR 223</a> 的问题。它还允许使用任何自定义脚本引擎，不一定基于 <a href="https://www.jcp.org/en/jsr/detail?id=223">JSR 223</a> (例如 Spring Expression Language)。</p>
</div>
<div class="sect4">
<h5 id="_xml_配置"><a class="anchor" href="#_xml_配置"></a>9.2.9.1. XML 配置</h5>
<div class="paragraph">
<p>要通过 XML 指定 <code>ScriptEvaluatorFactory</code> ，需要定义 <code>hibernate.validator.script_evaluator_factory</code> 属性。</p>
</div>
<div id="example-script-evaluator-factory-xml" class="exampleblock">
<div class="title">Example 114. 通过 XML 定义 <code>ScriptEvaluatorFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;validation-config
        xmlns="https://jakarta.ee/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/configuration
            https://jakarta.ee/xml/ns/validation/validation-configuration-3.0.xsd"
        version="3.0"&gt;

    &lt;property name="hibernate.validator.script_evaluator_factory"&gt;
        org.hibernate.validator.referenceguide.chapter09.CustomScriptEvaluatorFactory
    &lt;/property&gt;

&lt;/validation-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，指定的 <code>ScriptEvaluatorFactory</code> 必须具有无参数构造函数。</p>
</div>
</div>
<div class="sect4">
<h5 id="_程序化配置"><a class="anchor" href="#_程序化配置"></a>9.2.9.2. 程序化配置</h5>
<div class="paragraph">
<p>要以编程方式配置它，您需要将 <code>ScriptEvaluatorFactory</code> 的实例传递给 <code>ValidatorFactory</code> 。这为 <code>ScriptEvaluatorFactory</code> 的配置提供了更大的灵活性。<a href="#example-script-evaluator-factory-programmatically">Example 115, &#8220;以编程方式定义 <code>ScriptEvaluatorFactory</code>&#8221;</a>显示了如何实现这一点。</p>
</div>
<div id="example-script-evaluator-factory-programmatically" class="exampleblock">
<div class="title">Example 115. 以编程方式定义 <code>ScriptEvaluatorFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.scriptEvaluatorFactory( new CustomScriptEvaluatorFactory() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_自定义_scriptevaluatorfactory_的实现案例"><a class="anchor" href="#_自定义_scriptevaluatorfactory_的实现案例"></a>9.2.9.3. 自定义 <code>ScriptEvaluatorFactory</code> 的实现案例</h5>
<div class="paragraph">
<p>本节展示了两个自定义的 <code>ScriptEvaluatorFactory</code> 实现，它们可以在模块化环境中使用，也可以使用 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions">Spring Expression Language</a> 编写约束脚本。</p>
</div>
<div class="paragraph">
<p>模块化环境和 <a href="https://www.jcp.org/en/jsr/detail?id=223">JSR 223</a> 的问题来自类装载。脚本引擎可用的类装入器可能不同于 Hibernate Validator 。因此，使用默认策略将找不到脚本引擎。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，可以引入下面的 <code>MultiClassLoaderScriptEvaluatorFactory</code> 类:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">/*
 * Hibernate Validator, declare and validate application constraints
 *
 * License: Apache License, Version 2.0
 * See the license.txt file in the root directory or &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;.
 */
package org.hibernate.validator.osgi.scripting;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;

import org.hibernate.validator.spi.scripting.AbstractCachingScriptEvaluatorFactory;
import org.hibernate.validator.spi.scripting.ScriptEngineScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluationException;
import org.hibernate.validator.spi.scripting.ScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory;

/**
 * {@link ScriptEvaluatorFactory} that allows you to pass multiple {@link ClassLoader}s that will be used
 * to search for {@link ScriptEngine}s. Useful in environments similar to OSGi, where script engines can be
 * found only in {@link ClassLoader}s different from default one.
 *
 * @author Marko Bekhta
 */
public class MultiClassLoaderScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

	private final ClassLoader[] classLoaders;

	public MultiClassLoaderScriptEvaluatorFactory(ClassLoader... classLoaders) {
		if ( classLoaders.length == 0 ) {
			throw new IllegalArgumentException( "No class loaders were passed" );
		}
		this.classLoaders = classLoaders;
	}

	@Override
	protected ScriptEvaluator createNewScriptEvaluator(String languageName) {
		for ( ClassLoader classLoader : classLoaders ) {
			ScriptEngine engine = new ScriptEngineManager( classLoader ).getEngineByName( languageName );
			if ( engine != null ) {
				return new ScriptEngineScriptEvaluator( engine );
			}
		}
		throw new ScriptEvaluationException( "No JSR 223 script engine found for language " + languageName );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后声明:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.scriptEvaluatorFactory(
				new MultiClassLoaderScriptEvaluatorFactory( GroovyScriptEngineFactory.class.getClassLoader() )
		)
		.buildValidatorFactory()
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，就可以传递多个 <code>ClassLoader</code> 实例: 通常是所需 <code>ScriptEngine</code>s 的类加载器。</p>
</div>
<div class="paragraph">
<p>OSGi 环境的另一种方法是使用下面定义的 <code>OsgiScriptEvaluatorFactory</code> :</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">/*
 * Hibernate Validator, declare and validate application constraints
 *
 * License: Apache License, Version 2.0
 * See the license.txt file in the root directory or &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;.
 */
package org.hibernate.validator.osgi.scripting;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.script.ScriptEngineFactory;
import javax.script.ScriptEngineManager;
import jakarta.validation.ValidationException;

import org.hibernate.validator.spi.scripting.AbstractCachingScriptEvaluatorFactory;
import org.hibernate.validator.spi.scripting.ScriptEngineScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory;
import org.hibernate.validator.spi.scripting.ScriptEvaluatorNotFoundException;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;

/**
 * {@link ScriptEvaluatorFactory} suitable for OSGi environments. It is created
 * based on the {@code BundleContext} which is used to iterate through {@code Bundle}s and find all {@link ScriptEngineFactory}
 * candidates.
 *
 * @author Marko Bekhta
 */
public class OsgiScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

	private final List&lt;ScriptEngineManager&gt; scriptEngineManagers;

	public OsgiScriptEvaluatorFactory(BundleContext context) {
		this.scriptEngineManagers = Collections.unmodifiableList( findManagers( context ) );
	}

	@Override
	protected ScriptEvaluator createNewScriptEvaluator(String languageName) throws ScriptEvaluatorNotFoundException {
		return scriptEngineManagers.stream()
				.map( manager -&gt; manager.getEngineByName( languageName ) )
				.filter( Objects::nonNull )
				.map( engine -&gt; new ScriptEngineScriptEvaluator( engine ) )
				.findFirst()
				.orElseThrow( () -&gt; new ValidationException( String.format( "Unable to find script evaluator for '%s'.", languageName ) ) );
	}

	private List&lt;ScriptEngineManager&gt; findManagers(BundleContext context) {
		return findFactoryCandidates( context ).stream()
				.map( className -&gt; {
					try {
						return new ScriptEngineManager( Class.forName( className ).getClassLoader() );
					}
					catch (ClassNotFoundException e) {
						throw new ValidationException( "Unable to instantiate '" + className + "' based engine factory manager.", e );
					}
				} ).collect( Collectors.toList() );
	}

	/**
	 * Iterates through all bundles to get the available {@link ScriptEngineFactory} classes
	 *
	 * @return the names of the available ScriptEngineFactory classes
	 *
	 * @throws IOException
	 */
	private List&lt;String&gt; findFactoryCandidates(BundleContext context) {
		return Arrays.stream( context.getBundles() )
				.filter( Objects::nonNull )
				.filter( bundle -&gt; !"system.bundle".equals( bundle.getSymbolicName() ) )
				.flatMap( this::toStreamOfResourcesURL )
				.filter( Objects::nonNull )
				.flatMap( url -&gt; toListOfFactoryCandidates( url ).stream() )
				.collect( Collectors.toList() );
	}

	private Stream&lt;URL&gt; toStreamOfResourcesURL(Bundle bundle) {
		Enumeration&lt;URL&gt; entries = bundle.findEntries(
				"META-INF/services",
				"javax.script.ScriptEngineFactory",
				false
		);
		return entries != null ? Collections.list( entries ).stream() : Stream.empty();
	}

	private List&lt;String&gt; toListOfFactoryCandidates(URL url) {
		try ( BufferedReader reader = new BufferedReader( new InputStreamReader( url.openStream(), "UTF-8" ) ) ) {
			return reader.lines()
					.map( String::trim )
					.filter( line -&gt; !line.isEmpty() )
					.filter( line -&gt; !line.startsWith( "#" ) )
					.collect( Collectors.toList() );
		}
		catch (IOException e) {
			throw new ValidationException( "Unable to read the ScriptEngineFactory resource file", e );
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后声明:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.scriptEvaluatorFactory(
				new OsgiScriptEvaluatorFactory( FrameworkUtil.getBundle( this.getClass() ).getBundleContext() )
		)
		.buildValidatorFactory()
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>它是专门为 OSGi 环境设计的，并允许您传递 <code>BundleContext</code> ，该 <code>BundleContext</code> 将用于搜索 <code>ScriptEngineFactory</code> 作为参数。</p>
</div>
<div class="paragraph">
<p>如前所述，您还可以使用不基于 <a href="https://www.jcp.org/en/jsr/detail?id=223">JSR 223</a> 的脚本引擎。</p>
</div>
<div class="paragraph">
<p>例如，要使用 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions">Spring Expression Language</a> ，可以将 <code>SpringELScriptEvaluatorFactory</code> 定义为:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter09;

public class SpringELScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

	@Override
	public ScriptEvaluator createNewScriptEvaluator(String languageName) {
		if ( !"spring".equalsIgnoreCase( languageName ) ) {
			throw new IllegalStateException( "Only Spring EL is supported" );
		}

		return new SpringELScriptEvaluator();
	}

	private static class SpringELScriptEvaluator implements ScriptEvaluator {

		private final ExpressionParser expressionParser = new SpelExpressionParser();

		@Override
		public Object evaluate(String script, Map&lt;String, Object&gt; bindings) throws ScriptEvaluationException {
			try {
				Expression expression = expressionParser.parseExpression( script );
				EvaluationContext context = new StandardEvaluationContext( bindings.values().iterator().next() );
				for ( Entry&lt;String, Object&gt; binding : bindings.entrySet() ) {
					context.setVariable( binding.getKey(), binding.getValue() );
				}
				return expression.getValue( context );
			}
			catch (ParseException | EvaluationException e) {
				throw new ScriptEvaluationException( "Unable to evaluate SpEL script", e );
			}
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个工厂允许在 <code>ScriptAssert</code> 和 <code>ParameterScriptAssert</code> 约束中使用 Spring 表达式语言:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@ScriptAssert(script = "value &gt; 0", lang = "spring")
public class Foo {

	private final int value;

	private Foo(int value) {
		this.value = value;
	}

	public int getValue() {
		return value;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-configuring-validator"><a class="anchor" href="#section-configuring-validator"></a>9.3. 配置Validator</h3>
<div class="paragraph">
<p>在使用已配置的验证器工厂时，有时需要将不同的配置应用于单个 <code>Validator</code> 实例。<a href="#example-using-context">Example 116, &#8220;配置 <code>Validator</code> 实例通过 <code>usingContext()</code>&#8221;</a>  展示了如何通过调用 <code>ValidatorFactory#usingContext()</code> 来实现这一点。</p>
</div>
<div id="example-using-context" class="exampleblock">
<div class="title">Example 116. 配置 <code>Validator</code> 实例通过 <code>usingContext()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

Validator validator = validatorFactory.usingContext()
		.messageInterpolator( new MyMessageInterpolator() )
		.traversableResolver( new MyTraversableResolver() )
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-metadata-api"><a class="anchor" href="#validator-metadata-api"></a>10. 使用约束元数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta Bean Validation 规范不仅提供了一个验证引擎，而且还提供了一个用于以统一的方式检索约束元数据的 API，无论是使用注释声明约束还是通过 XML 映射声明约束。阅读本章可以了解更多关于这个 API 及其可能性的信息。您可以在 <code>jakarta.validation.metadata</code> 包中找到所有的元数据 API 类型。</p>
</div>
<div class="paragraph">
<p>本章中提供的例子基于<a href="#metadata-example-car">Example 117, &#8220;使用的演示类&#8221;</a>中所示的类和约束声明。</p>
</div>
<div id="metadata-example-car" class="exampleblock">
<div class="title">Example 117. 使用的演示类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter10;

public class Person {

	public interface Basic {
	}

	@NotNull
	private String name;

	//getters and setters ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter10;

public interface Vehicle {

	public interface Basic {
	}

	@NotNull(groups = Vehicle.Basic.class)
	String getManufacturer();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter10;

@ValidCar
public class Car implements Vehicle {

	public interface SeverityInfo extends Payload {
	}

	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	private Person driver;

	private String modelName;

	public Car() {
	}

	public Car(
			@NotNull String manufacturer,
			String licencePlate,
			Person driver,
			String modelName) {

		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.driver = driver;
		this.modelName = modelName;
	}

	public void driveAway(@Max(75) int speed) {
		//...
	}

	@LuggageCountMatchesPassengerCount(
			piecesOfLuggagePerPassenger = 2,
			validationAppliesTo = ConstraintTarget.PARAMETERS,
			payload = SeverityInfo.class,
			message = "There must not be more than {piecesOfLuggagePerPassenger} pieces " +
					"of luggage per passenger."
	)
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}

	@Override
	@Size(min = 3)
	public String getManufacturer() {
		return manufacturer;
	}

	public void setManufacturer(String manufacturer) {
		this.manufacturer = manufacturer;
	}

	@Valid
	@ConvertGroup(from = Default.class, to = Person.Basic.class)
	public Person getDriver() {
		return driver;
	}

	//further getters and setters...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter10;

public class Library {

	@NotNull
	private String name;

	private List&lt;@NotNull @Valid Book&gt; books;

	//getters and setters ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter10;

public class Book {

	@NotEmpty
	private String title;

	@NotEmpty
	private String author;

	//getters and setters ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_beandescriptor"><a class="anchor" href="#_beandescriptor"></a>10.1. <code>BeanDescriptor</code></h3>
<div class="paragraph">
<p>元数据 API 的入口点是 Validator <code>Validator#getConstraintsForClass()</code> 方法，它返回 <a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/BeanDescriptor.html"><code>BeanDescriptor</code></a> 接口的一个实例。使用这个描述符，您可以获得直接在 bean 本身(类或属性级)上声明的约束的元数据，但也可以检索表示单个属性、方法和构造函数的元数据描述符。</p>
</div>
<div class="paragraph">
<p><a href="#metadata-example-using-beandescriptor">Example 118, &#8220;使用 <code>BeanDescriptor</code>&#8221;</a> 演示了如何检索 <code>Car</code> 类的  <code>BeanDescriptor</code> ，以及如何以断言的形式使用该描述符。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果由请求的类承载的约束声明无效，则抛出 <code>ValidationException</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="metadata-example-using-beandescriptor" class="exampleblock">
<div class="title">Example 118. 使用 <code>BeanDescriptor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

assertTrue( carDescriptor.isBeanConstrained() );

//one class-level constraint
assertEquals( 1, carDescriptor.getConstraintDescriptors().size() );

//manufacturer, licensePlate, driver
assertEquals( 3, carDescriptor.getConstrainedProperties().size() );

//property has constraint
assertNotNull( carDescriptor.getConstraintsForProperty( "licensePlate" ) );

//property is marked with @Valid
assertNotNull( carDescriptor.getConstraintsForProperty( "driver" ) );

//constraints from getter method in interface and implementation class are returned
assertEquals(
		2,
		carDescriptor.getConstraintsForProperty( "manufacturer" )
				.getConstraintDescriptors()
				.size()
);

//property is not constrained
assertNull( carDescriptor.getConstraintsForProperty( "modelName" ) );

//driveAway(int), load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;)
assertEquals( 2, carDescriptor.getConstrainedMethods( MethodType.NON_GETTER ).size() );

//driveAway(int), getManufacturer(), getDriver(), load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;)
assertEquals(
		4,
		carDescriptor.getConstrainedMethods( MethodType.NON_GETTER, MethodType.GETTER )
				.size()
);

//driveAway(int)
assertNotNull( carDescriptor.getConstraintsForMethod( "driveAway", int.class ) );

//getManufacturer()
assertNotNull( carDescriptor.getConstraintsForMethod( "getManufacturer" ) );

//setManufacturer() is not constrained
assertNull( carDescriptor.getConstraintsForMethod( "setManufacturer", String.class ) );

//Car(String, String, Person, String)
assertEquals( 1, carDescriptor.getConstrainedConstructors().size() );

//Car(String, String, Person, String)
assertNotNull(
		carDescriptor.getConstraintsForConstructor(
				String.class,
				String.class,
				Person.class,
				String.class
		)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过 <code>isBeanConstrained()</code> 确定指定的类是否承载任何类或属性级别的约束。<code>isBeanConstrained()</code> 不能判断方法或构造函数约束。</p>
</div>
<div class="paragraph">
<p><code>getConstraintDescriptors()</code> 方法对于从 <code>ElementDescriptor</code> 派生的所有描述符都是通用的(参见<a href="#validator-metadata-api-elementdescriptor">Section 10.4, &#8220;<code>ElementDescriptor</code>&#8221;</a>) ，并返回一组描述符，它们表示直接在给定元素上声明的约束。对于 <code>BeanDescriptor</code> ，返回 bean 的类级别约束。关于 <code>ConstraintDescriptor</code> 的更多细节可以在<a href="#section-constraint-descriptor">Section 10.7, &#8220;<code>ConstraintDescriptor</code>&#8221;</a>中找到。</p>
</div>
<div class="paragraph">
<p>通过 <code>getConstraintsForProperty()</code> 、 <code>getConstraintsForMethod()</code> 和 <code>getConstraintsForConstructor()</code> ，您可以获得描述符，它表示一个给定的属性或可执行元素，通过其名称进行标识，对于方法和构造函数，还可以获得参数类型。这些方法返回的不同描述符类型将在下面的小节中描述。</p>
</div>
<div class="paragraph">
<p>请注意，这些方法根据<a href="#section-constraint-inheritance">Section 2.1.5, &#8220;约束继承&#8221;</a>中描述的约束继承规则，考虑在超类型中声明的约束。一个例子是 <code>manufacturer</code> 属性的描述符，它提供了对 <code>Vehicle#getManufacturer()</code> 和实现方法 <code>Car#getManufacturer()</code> 上定义的所有约束的访问。如果指定的元素不存在或不受约束，则返回 <code>null</code> 。</p>
</div>
<div class="paragraph">
<p>方法 <code>getConstrainedProperties()</code> 、 <code>getConstrainedMethods()</code> 和 <code>getConstrainedConstructors()</code>  返回集合(可能是空的)分别具有所有约束属性、方法和构造函数。如果一个元素至少有一个约束或者被标记为级联验证，则认为该元素受到约束。在调用 <code>getConstrainedMethods()</code> 时，可以指定要返回的方法的类型(getter、 non-getter 或者两者都是)。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-property-descriptor"><a class="anchor" href="#section-property-descriptor"></a>10.2. <code>PropertyDescriptor</code></h3>
<div class="paragraph">
<p>接口 <a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/PropertyDescriptor.html"><code>PropertyDescriptor</code></a> 表示类的一个给定属性。只要遵守 JavaBeans 命名约定，那么在字段或属性 getter 上声明约束是透明的。<a href="#metadata-example-using-propertydescriptor">Example 119, &#8220;使用 <code>PropertyDescriptor</code>&#8221;</a>展示了如何使用 <code>PropertyDescriptor</code> 接口。</p>
</div>
<div id="metadata-example-using-propertydescriptor" class="exampleblock">
<div class="title">Example 119. 使用 <code>PropertyDescriptor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">PropertyDescriptor licensePlateDescriptor = carDescriptor.getConstraintsForProperty(
		"licensePlate"
);

//"licensePlate" has two constraints, is not marked with @Valid and defines no group conversions
assertEquals( "licensePlate", licensePlateDescriptor.getPropertyName() );
assertEquals( 2, licensePlateDescriptor.getConstraintDescriptors().size() );
assertTrue( licensePlateDescriptor.hasConstraints() );
assertFalse( licensePlateDescriptor.isCascaded() );
assertTrue( licensePlateDescriptor.getGroupConversions().isEmpty() );

PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

//"driver" has no constraints, is marked with @Valid and defines one group conversion
assertEquals( "driver", driverDescriptor.getPropertyName() );
assertTrue( driverDescriptor.getConstraintDescriptors().isEmpty() );
assertFalse( driverDescriptor.hasConstraints() );
assertTrue( driverDescriptor.isCascaded() );
assertEquals( 1, driverDescriptor.getGroupConversions().size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>getConstraintDescriptors()</code> ，您可以检索一组 <code>ConstraintDescriptors</code> ，提供给定属性的各个约束的更多信息。如果属性标记为级联验证(使用 <code>@Valid</code> 注释或通过 XML) ，则 <code>isCascaded()</code> 方法返回 <code>true</code> ，否则返回 <code>false</code> 。<code>getGroupConversions()</code> 返回任何已配置的组转换。有关 <code>GroupConversionDescriptor</code> 的详细信息，请参阅<a href="#section-group-conversion-descriptor">Section 10.6, &#8220;<code>GroupConversionDescriptor</code>&#8221;</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_methoddescriptor_和_constructordescriptor"><a class="anchor" href="#_methoddescriptor_和_constructordescriptor"></a>10.3. <code>MethodDescriptor</code> 和 <code>ConstructorDescriptor</code></h3>
<div class="paragraph">
<p>约束方法和构造函数分别由接口 <a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/MethodDescriptor.html"><code>MethodDescriptor</code></a> 和 <a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/ConstructorDescriptor.html"><code>ConstructorDescriptor</code></a> 表示。<a href="#metadata-example-using-methodandconstructordescriptor">Example 120, &#8220;使用 <code>MethodDescriptor</code> 和 <code>ConstructorDescriptor</code>&#8221;</a> 演示了如何使用这些描述符。</p>
</div>
<div id="metadata-example-using-methodandconstructordescriptor" class="exampleblock">
<div class="title">Example 120. 使用 <code>MethodDescriptor</code> 和 <code>ConstructorDescriptor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">//driveAway(int) has a constrained parameter and an unconstrained return value
MethodDescriptor driveAwayDescriptor = carDescriptor.getConstraintsForMethod(
		"driveAway",
		int.class
);
assertEquals( "driveAway", driveAwayDescriptor.getName() );
assertTrue( driveAwayDescriptor.hasConstrainedParameters() );
assertFalse( driveAwayDescriptor.hasConstrainedReturnValue() );

//always returns an empty set; constraints are retrievable by navigating to
//one of the sub-descriptors, e.g. for the return value
assertTrue( driveAwayDescriptor.getConstraintDescriptors().isEmpty() );

ParameterDescriptor speedDescriptor = driveAwayDescriptor.getParameterDescriptors()
		.get( 0 );

//The "speed" parameter is located at index 0, has one constraint and is not cascaded
//nor does it define group conversions
assertEquals( "speed", speedDescriptor.getName() );
assertEquals( 0, speedDescriptor.getIndex() );
assertEquals( 1, speedDescriptor.getConstraintDescriptors().size() );
assertFalse( speedDescriptor.isCascaded() );
assert speedDescriptor.getGroupConversions().isEmpty();

//getDriver() has no constrained parameters but its return value is marked for cascaded
//validation and declares one group conversion
MethodDescriptor getDriverDescriptor = carDescriptor.getConstraintsForMethod(
		"getDriver"
);
assertFalse( getDriverDescriptor.hasConstrainedParameters() );
assertTrue( getDriverDescriptor.hasConstrainedReturnValue() );

ReturnValueDescriptor returnValueDescriptor = getDriverDescriptor.getReturnValueDescriptor();
assertTrue( returnValueDescriptor.getConstraintDescriptors().isEmpty() );
assertTrue( returnValueDescriptor.isCascaded() );
assertEquals( 1, returnValueDescriptor.getGroupConversions().size() );

//load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;) has one cross-parameter constraint
MethodDescriptor loadDescriptor = carDescriptor.getConstraintsForMethod(
		"load",
		List.class,
		List.class
);
assertTrue( loadDescriptor.hasConstrainedParameters() );
assertFalse( loadDescriptor.hasConstrainedReturnValue() );
assertEquals(
		1,
		loadDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size()
);

//Car(String, String, Person, String) has one constrained parameter
ConstructorDescriptor constructorDescriptor = carDescriptor.getConstraintsForConstructor(
		String.class,
		String.class,
		Person.class,
		String.class
);

assertEquals( "Car", constructorDescriptor.getName() );
assertFalse( constructorDescriptor.hasConstrainedReturnValue() );
assertTrue( constructorDescriptor.hasConstrainedParameters() );
assertEquals(
		1,
		constructorDescriptor.getParameterDescriptors()
				.get( 0 )
				.getConstraintDescriptors()
				.size()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>getName()</code> 返回给定方法或构造函数的名称。可以使用 <code>hasConstrainedParameters()</code> 和 <code>hasConstrainedReturnValue()</code> 方法快速检查可执行元素是否具有任何参数约束(单个参数约束或交叉参数约束)或返回值约束。</p>
</div>
<div class="paragraph">
<p>注意，约束并不直接公开在 <code>MethodDescriptor</code> 和 <code>ConstructorDescriptor</code> 上，而是公开在表示可执行文件的参数、其返回值及其交叉参数约束的专用描述符上。要获得其中一个描述符，请分别调用 <code>getParameterDescriptors()</code>, <code>getReturnValueDescriptor()</code> 或 <code>getCrossParameterDescriptor()</code> 。</p>
</div>
<div class="paragraph">
<p>这些描述符提供了对元素的约束(<code>getConstraintDescriptors()</code>)的访问，并且在参数和返回值的情况下，提供了对其级联验证( <code>isValid()</code> 和 <code>getGroupConversions()</code> )的配置的访问。对于参数，还可以通过 <code>getName()</code> 和 <code>getIndex()</code> 检索当前使用的参数名称提供程序(参见<a href="#section-parameter-name-provider">Section 9.2.4, &#8220;<code>ParameterNameProvider</code>&#8221;</a>)返回的索引和名称。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>遵循 JavaBeans 命名约定的 Getter 方法被视为 bean 属性，但也被视为受约束的方法。</p>
</div>
<div class="paragraph">
<p>这意味着您可以通过获取 <code>PropertyDescriptor</code> (例如 <code>BeanDescriptor.getConstraintsForProperty("foo")</code> )或通过检查 getter 的  <code>MethodDescriptor</code> 的返回值描述符(例如 <code>BeanDescriptor.getConstraintsForMethod("getFoo").getReturnValueDescriptor()</code> )来检索相关的元数据。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="validator-metadata-api-elementdescriptor"><a class="anchor" href="#validator-metadata-api-elementdescriptor"></a>10.4. <code>ElementDescriptor</code></h3>
<div class="paragraph">
<p><a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/ElementDescriptor.html"><code>ElementDescriptor</code></a> 接口是各个描述符类型(如 <code>BeanDescriptor</code>, <code>PropertyDescriptor</code>  等)的公共基类。除了 <code>getConstraintDescriptors()</code> 之外，它还提供了一些所有描述符通用的方法。</p>
</div>
<div class="paragraph">
<p><code>hasConstraints()</code> 允许快速检查一个元素是否有任何直接的约束(例如，在 <code>BeanDescriptor</code> 中的类级约束)。</p>
</div>
<div class="paragraph">
<p><code>getElementClass()</code> 返回由给定描述符表示的元素的 Java 类型:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>BeanDescriptor</code> 上调用时的对象类型,</p>
</li>
<li>
<p>当分别在 <code>PropertyDescriptor</code> 或 <code>ParameterDescriptor</code> 上调用属性或参数时,</p>
</li>
<li>
<p><code>Object[].class</code> 调用 <code>CrossParameterDescriptor</code> 时,</p>
</li>
<li>
<p>在 <code>ConstructorDescriptor</code> 、 <code>MethodDescriptor</code> 或 <code>ReturnValueDescriptor</code> 上调用时的返回类型。类将为没有返回值的方法返回 <code>void.class</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#metadata-example-using-elementdescriptor">Example 121, &#8220;使用 <code>ElementDescriptor methods</code>&#8221;</a> 展示了如何使用这些方法。</p>
</div>
<div id="metadata-example-using-elementdescriptor" class="exampleblock">
<div class="title">Example 121. 使用 <code>ElementDescriptor methods</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
		"manufacturer"
);

assertTrue( manufacturerDescriptor.hasConstraints() );
assertEquals( String.class, manufacturerDescriptor.getElementClass() );

CrossParameterDescriptor loadCrossParameterDescriptor = carDescriptor.getConstraintsForMethod(
		"load",
		List.class,
		List.class
).getCrossParameterDescriptor();

assertTrue( loadCrossParameterDescriptor.hasConstraints() );
assertEquals( Object[].class, loadCrossParameterDescriptor.getElementClass() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，<code>ElementDescriptor</code> 提供了对 <code>ConstraintFinder</code> API 的访问，该 API 允许您以细粒度的方式查询约束元数据。 <a href="#example-constraint-finder">Example 122, &#8220;用法 <code>ConstraintFinder</code>&#8221;</a> 展示了如何通过 <code>findConstraints()</code> 检索 <code>ConstraintFinder</code> 实例，并使用 API 查询约束元数据。</p>
</div>
<div id="example-constraint-finder" class="exampleblock">
<div class="title">Example 122. 用法 <code>ConstraintFinder</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
		"manufacturer"
);

//"manufacturer" constraints are declared on the getter, not the field
assertTrue(
		manufacturerDescriptor.findConstraints()
				.declaredOn( ElementType.FIELD )
				.getConstraintDescriptors()
				.isEmpty()
);

//@NotNull on Vehicle#getManufacturer() is part of another group
assertEquals(
		1,
		manufacturerDescriptor.findConstraints()
				.unorderedAndMatchingGroups( Default.class )
				.getConstraintDescriptors()
				.size()
);

//@Size on Car#getManufacturer()
assertEquals(
		1,
		manufacturerDescriptor.findConstraints()
				.lookingAt( Scope.LOCAL_ELEMENT )
				.getConstraintDescriptors()
				.size()
);

//@Size on Car#getManufacturer() and @NotNull on Vehicle#getManufacturer()
assertEquals(
		2,
		manufacturerDescriptor.findConstraints()
				.lookingAt( Scope.HIERARCHY )
				.getConstraintDescriptors()
				.size()
);

//Combining several filter options
assertEquals(
		1,
		manufacturerDescriptor.findConstraints()
				.declaredOn( ElementType.METHOD )
				.lookingAt( Scope.HIERARCHY )
				.unorderedAndMatchingGroups( Vehicle.Basic.class )
				.getConstraintDescriptors()
				.size()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过 <code>declaredOn()</code> ，您可以搜索某些元素类型上声明的 <code>ConstraintDescriptors</code> 。这对于查找字段或 getter 方法上声明的属性约束非常有用。</p>
</div>
<div class="paragraph">
<p><code>unorderedAndMatchingGroups()</code> 将产生的约束限制为与给定验证组相匹配的约束。</p>
</div>
<div class="paragraph">
<p><code>lookingAt()</code> 允许区分直接在元素上指定的约束(<code>Scope.LOCAL_ELEMENT</code>)或属于元素但驻留在类层次结构中任何位置的约束(<code>Scope.HIERARCHY</code>)。</p>
</div>
<div class="paragraph">
<p>您还可以组合上一个示例中所示的不同选项。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>unorderedAndMatchingGroups()</code> 不遵守顺序，但是通过序列的组继承和继承遵守顺序。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_containerdescriptor_和_containerelementtypedescriptor"><a class="anchor" href="#_containerdescriptor_和_containerelementtypedescriptor"></a>10.5. <code>ContainerDescriptor</code> 和 <code>ContainerElementTypeDescriptor</code></h3>
<div class="paragraph">
<p><a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/ContainerDescriptor.html"><code>ContainerDescriptor</code></a> 接口是所有支持容器元素约束和级联验证(<code>PropertyDescriptor</code>, <code>ParameterDescriptor</code>, <code>ReturnValueDescriptor</code>)的元素的公共接口。</p>
</div>
<div class="paragraph">
<p>它有一个方法 <code>getConstrainedContainerElementTypes()</code> ，它返回一组 <code>ContainerElementTypeDescriptor</code>。</p>
</div>
<div class="paragraph">
<p><code>ContainerElementTypeDescriptor</code> 扩展 <code>ContainerDescriptor</code> 以支持嵌套容器元素约束。</p>
</div>
<div class="paragraph">
<p><code>ContainerElementTypeDescriptor</code> 包含有关容器、约束和级联验证的信息。</p>
</div>
<div class="paragraph">
<p><a href="#metadata-example-using-containerelementtypedescriptor">Example 123, &#8220;使用 <code>ContainerElementTypeDescriptor</code>&#8221;</a>  展示了如何使用 <code>getConstrainedContainerElementTypes()</code> 检索 <code>ContainerElementTypeDescriptor</code> 集。</p>
</div>
<div id="metadata-example-using-containerelementtypedescriptor" class="exampleblock">
<div class="title">Example 123. 使用 <code>ContainerElementTypeDescriptor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">PropertyDescriptor booksDescriptor = libraryDescriptor.getConstraintsForProperty(
		"books"
);

Set&lt;ContainerElementTypeDescriptor&gt; booksContainerElementTypeDescriptors =
		booksDescriptor.getConstrainedContainerElementTypes();
ContainerElementTypeDescriptor booksContainerElementTypeDescriptor =
		booksContainerElementTypeDescriptors.iterator().next();

assertTrue( booksContainerElementTypeDescriptor.hasConstraints() );
assertTrue( booksContainerElementTypeDescriptor.isCascaded() );
assertEquals(
		0,
		booksContainerElementTypeDescriptor.getTypeArgumentIndex().intValue()
);
assertEquals(
		List.class,
		booksContainerElementTypeDescriptor.getContainerClass()
);

Set&lt;ConstraintDescriptor&lt;?&gt;&gt; constraintDescriptors =
		booksContainerElementTypeDescriptor.getConstraintDescriptors();
ConstraintDescriptor&lt;?&gt; constraintDescriptor =
		constraintDescriptors.iterator().next();

assertEquals(
		NotNull.class,
		constraintDescriptor.getAnnotation().annotationType()
);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-group-conversion-descriptor"><a class="anchor" href="#section-group-conversion-descriptor"></a>10.6. <code>GroupConversionDescriptor</code></h3>
<div class="paragraph">
<p>所有表示可以作为级联验证主题的元素的描述符类型(即 <code>PropertyDescriptor</code>, <code>ParameterDescriptor</code> 和 <code>ReturnValueDescriptor</code>)都通过 <code>getGroupConversions()</code> 提供对元素组转换的访问。返回的集合为每个配置的转换包含一个 <a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation//metadata/GroupConversionDescriptor.html"><code>GroupConversionDescriptor</code></a> ，允许检索转换的源和目标组。<a href="#metadata-example-using-groupconversiondescriptor">Example 124, &#8220;使用 <code>GroupConversionDescriptor</code>&#8221;</a> 显示了一个示例。</p>
</div>
<div id="metadata-example-using-groupconversiondescriptor" class="exampleblock">
<div class="title">Example 124. 使用 <code>GroupConversionDescriptor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

Set&lt;GroupConversionDescriptor&gt; groupConversions = driverDescriptor.getGroupConversions();
assertEquals( 1, groupConversions.size() );

GroupConversionDescriptor groupConversionDescriptor = groupConversions.iterator()
		.next();
assertEquals( Default.class, groupConversionDescriptor.getFrom() );
assertEquals( Person.Basic.class, groupConversionDescriptor.getTo() );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-constraint-descriptor"><a class="anchor" href="#section-constraint-descriptor"></a>10.7. <code>ConstraintDescriptor</code></h3>
<div class="paragraph">
<p>最后， <a href="http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api?jakarta/validation/metadata/ConstraintDescriptor.html"><code>ConstraintDescriptor</code></a> 接口描述单个约束及其组成约束。通过该接口的一个实例，您可以访问约束注释及其参数。</p>
</div>
<div class="paragraph">
<p><a href="#metadata-example-using-constraintdescriptor">Example 125, &#8220;使用 <code>ConstraintDescriptor</code>&#8221;</a>
展示了如何从 <code>ConstraintDescriptor</code> 中检索默认约束属性(如消息模板、组等)以及自定义约束属性(<code>piecesOfLuggagePerPassenger</code>)和其他元数据(如约束的注释类型及其验证器)。</p>
</div>
<div id="metadata-example-using-constraintdescriptor" class="exampleblock">
<div class="title">Example 125. 使用 <code>ConstraintDescriptor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">//descriptor for the @LuggageCountMatchesPassengerCount constraint on the
//load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;) method
ConstraintDescriptor&lt;?&gt; constraintDescriptor = carDescriptor.getConstraintsForMethod(
		"load",
		List.class,
		List.class
).getCrossParameterDescriptor().getConstraintDescriptors().iterator().next();

//constraint type
assertEquals(
		LuggageCountMatchesPassengerCount.class,
		constraintDescriptor.getAnnotation().annotationType()
);

//standard constraint attributes
assertEquals( SeverityInfo.class, constraintDescriptor.getPayload().iterator().next() );
assertEquals(
		ConstraintTarget.PARAMETERS,
		constraintDescriptor.getValidationAppliesTo()
);
assertEquals( Default.class, constraintDescriptor.getGroups().iterator().next() );
assertEquals(
		"There must not be more than {piecesOfLuggagePerPassenger} pieces of luggage per " +
		"passenger.",
		constraintDescriptor.getMessageTemplate()
);

//custom constraint attribute
assertEquals(
		2,
		constraintDescriptor.getAttributes().get( "piecesOfLuggagePerPassenger" )
);

//no composing constraints
assertTrue( constraintDescriptor.getComposingConstraints().isEmpty() );

//validator class
assertEquals(
		Arrays.&lt;Class&lt;?&gt;&gt;asList( LuggageCountMatchesPassengerCount.Validator.class ),
		constraintDescriptor.getConstraintValidatorClasses()
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-integration"><a class="anchor" href="#validator-integration"></a>11. 与其他框架集成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate Validator 用于实现多层数据校验，其中约束注解只标注一次(带注解的domain域模型) ，可以在应用程序的各个不同层进行检查。由于这个原因，存在与其他技术的多个集成点。</p>
</div>
<div class="sect2">
<h3 id="validator-checkconstraints-orm"><a class="anchor" href="#validator-checkconstraints-orm"></a>11.1. ORM 集成</h3>
<div class="paragraph">
<p>Hibernate Validator 可以和 Hibernate ORM 以及所有纯 Java 编写的持久层框架集成使用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当需要校验延迟加载的关联时，建议将约束放在关联的 getter 方法上。Hibernate ORM 用代理实例替换了延迟加载的关联，代理实例通过 getter 请求时得到初始化/加载的值。在这种情况下，如果将约束放置在字段级别，则将使用实际的代理实例，这将导致校验错误。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="validator-checkconstraints-db"><a class="anchor" href="#validator-checkconstraints-db"></a>11.1.1. 数据库schema级别校验</h4>
<div class="paragraph">
<p>开箱即用，Hibernate ORM 会将您为实体定义的约束转换为映射元数据。例如，如果实体的一个属性被注解为 <code>@NotNull</code> ，那么在 Hibernate ORM 生成的 DDL 语句中，它的列将被声明为 <code>not null</code> 。</p>
</div>
<div class="paragraph">
<p>如果由于某种原因，需要禁用该特性，请将 <code>hibernate.validator.apply_to_ddl</code> 设置为 <code>false</code>。另见<a href="#validator-defineconstraints-spec">Section 2.3.1, &#8220;Jakarta Bean Validation 约束&#8221;</a>和<a href="#validator-defineconstraints-hv-constraints">Section 2.3.2, &#8220;附加约束&#8221;</a>。</p>
</div>
<div class="paragraph">
<p>还可以通过设置 <code>org.hibernate.validator.group.ddl</code> 属性，将 DDL 约束生成限制为已定义约束的一个子集。该属性指定了用逗号分隔的、完全指定的组的类名。约束必须是这些组的一部分，才会在生成 DDL 语句时被考虑。</p>
</div>
</div>
<div class="sect3">
<h4 id="validator-checkconstraints-orm-hibernateevent"><a class="anchor" href="#validator-checkconstraints-orm-hibernateevent"></a>11.1.2. Hibernate ORM 事件校验</h4>
<div class="paragraph">
<p>Hibernate Validator 有一个内置的 Hibernate 事件监听器- <a href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java"><code>org.hibernate.cfg.beanvalidation.BeanValidationEventListener</code></a> - 它是 Hibernate ORM 的一部分。每当发生 <code>PreInsertEvent</code> 、 <code>PreUpdateEvent</code> 或 <code>PreDeleteEvent</code> 时，监听器将校验实体实例的所有约束，并在违反任何约束时抛出异常。根据默认情况，在 Hibernate ORM 进行任何插入或更新之前，将校验对象。删除事件之前将不会触发校验。您可以使用属性 <code>jakarta.persistence.validation.group.pre-persist</code>,
<code>jakarta.persistence.validation.group.pre-update</code> 和 <code>jakarta.persistence.validation.group.pre-remove</code> 将组配置为根据每个事件类型进行校验。这些属性的值是要校验的组的逗号分隔的完全指定的类名。<a href="#example-beanvalidationeventlistener-config">Example 126, &#8220;手动配置 <code>BeanValidationEvenListener</code>&#8221;</a>显示了这些属性的默认值。在这种情况下，它们也可以省略。</p>
</div>
<div class="paragraph">
<p>在违反约束时，事件将抛出一个运行时 <code>ConstraintViolationException</code> ，其中包含一组描述每个失败的 <code>ConstraintViolation</code> 实例。</p>
</div>
<div class="paragraph">
<p>如果 Hibernate Validator 出现在classpath中，Hibernate ORM 将透明地使用它。如果Hibernate Validator 位于classpath中，但是您不想对类校验，可以将 <code>jakarta.persistence.validation.mode</code> 设置为none。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果没有用校验注解对 bean 进行注解，那么就不会有运行时性能开销。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您需要为 Hibernate ORM 手动设置事件监听器，请在 <em>hibernate.cfg.xml</em> 中使用以下配置:</p>
</div>
<div id="example-beanvalidationeventlistener-config" class="exampleblock">
<div class="title">Example 126. 手动配置 <code>BeanValidationEvenListener</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;property name="jakarta.persistence.validation.group.pre-persist"&gt;
            jakarta.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="jakarta.persistence.validation.group.pre-update"&gt;
            jakarta.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="jakarta.persistence.validation.group.pre-remove"&gt;&lt;/property&gt;
        ...
        &lt;event type="pre-update"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-insert"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-delete"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jpa"><a class="anchor" href="#_jpa"></a>11.1.3. JPA</h4>
<div class="paragraph">
<p>如果您使用的是 JPA 2，并且 Hibernate Validator 位于classpath中，则 JPA2规范要求启用 Jakarta Bean Validation。在这种情况下，可以在 <em>persistence.xml</em>. 中配置 <code>jakarta.persistence.validation.group.pre-persist</code>,
<code>jakarta.persistence.validation.group.pre-update</code> 和 <code>jakarta.persistence.validation.group.pre-remove</code> 这两个属性，如<a href="#validator-checkconstraints-orm-hibernateevent">Section 11.1.2, &#8220;Hibernate ORM 事件校验&#8221;</a>所述。还定义了一个节点校验模式，可以设置为 <code>AUTO</code> 、 <code>CALLBACK</code> 或 <code>NONE</code> 。默认值是 <code>AUTO</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-presentation-layer"><a class="anchor" href="#section-presentation-layer"></a>11.2. JSF &amp; Seam</h3>
<div class="paragraph">
<p>当使用 JSF2 或 JBoss Seam ，并且 Hibernate Validator (Jakarta Bean Validation)存在运行环境中时，对应用程序中的每个字段都会触发校验。<a href="#example-jsf2">Example 127, &#8220;在JSF2使用Jakarta Bean Validation&#8221;</a> 展示了 JSF 页面中的 <code>f:validateBean</code> 标记的示例。 <code>validationGroups</code> 属性是可选的，可用于指定以逗号分隔的校验组列表。默认值是 <code>jakarta.validation.groups.Default</code> 。有关更多信息，请参考 Seam 文档或 JSF 2规范。</p>
</div>
<div id="example-jsf2" class="exampleblock">
<div class="title">Example 127. 在JSF2使用Jakarta Bean Validation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;h:form&gt;

  &lt;f:validateBean validationGroups="jakarta.validation.groups.Default"&gt;

    &lt;h:inputText value=#{model.property}/&gt;
    &lt;h:selectOneRadio value=#{model.radioProperty}&gt; ... &lt;/h:selectOneRadio&gt;
    &lt;!-- other input components here --&gt;

  &lt;/f:validateBean&gt;

&lt;/h:form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSF 2和 Jakarta Bean Validation 之间的集成在 <a href="http://jcp.org/en/jsr/detail?id=314">JSR-314</a> 的“Jakarta Bean Validation Integration”一章中进行了描述。了解 JSF 2实现了一个自定义的 <code>MessageInterpolator</code> 以确保正确的本地化是很有趣的。为了鼓励使用 Jakarta Bean Validation 消息工具，JSF 2默认只显示生成的 Bean 校验消息。但是，这可以通过应用程序资源包配置，方法是提供以下配置( <code>{0}</code> 替换为 Jakarta Bean 校验消息， <code>{1}</code> 替换为 JSF 组件标签) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>jakarta.faces.validator.BeanValidator.MESSAGE={1}: {0}</pre>
</div>
</div>
<div class="paragraph">
<p>默认的配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>jakarta.faces.validator.BeanValidator.MESSAGE={0}</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-integration-with-cdi"><a class="anchor" href="#section-integration-with-cdi"></a>11.3. CDI</h3>
<div class="paragraph">
<p>从1.1版本开始，Bean Validation (Jakarta Bean Validation)与 CDI (用于 Jakarta EE 的上下文和依赖注入文件)集成在一起。</p>
</div>
<div class="paragraph">
<p>这种集成为 <code>Validator</code> 和 <code>ValidatorFactory</code> 提供了 CDI 管理的 bean，并且支持约束校验器、自定义消息插值器、可遍历解析器、约束校验器工厂、参数名提供者、时钟提供者和值提取器等依赖注入。</p>
</div>
<div class="paragraph">
<p>此外，调用时将自动校验 CDI 管理 bean 的方法和构造函数的参数和返回值约束。</p>
</div>
<div class="paragraph">
<p>当您的应用程序在 Java EE 容器上运行时，默认情况下将启用此集成。在 Servlet 容器或纯 Java SE 环境中使用 CDI 时，可以使用 Hibernate Validator 提供的 CDI 可移植扩展。为此，将可移植扩展添加到类路径中，如<a href="#section-getting-started-cdi">Section 1.1.2, &#8220;CDI&#8221;</a>。</p>
</div>
<div class="sect3">
<h4 id="_依赖注入"><a class="anchor" href="#_依赖注入"></a>11.3.1. 依赖注入</h4>
<div class="paragraph">
<p>CDI 的依赖注入机制使得获取 <code>ValidatorFactory</code> 和 <code>Validator</code> 实例。并在你管理的 bean 中使用它们变得非常容易。只需使用 <code>@jakarta.inject.Inject</code> 注解 bean 的实例字段即可注入对象。如<a href="#example-dependency-injection">Example 128, &#8220;通过 <code>@Inject</code> 注入 validator factory 和 validator&#8221;</a>。</p>
</div>
<div id="example-dependency-injection" class="exampleblock">
<div class="title">Example 128. 通过 <code>@Inject</code> 注入 validator factory 和 validator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.validator;

@ApplicationScoped
public class RentalStation {

	@Inject
	private ValidatorFactory validatorFactory;

	@Inject
	private Validator validator;

	//...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注入的 bean 是默认的校验器工厂和校验器实例。为了配置它们 - 例如使用自定义消息插值器 - 您可以使用 Jakarta Bean Validation XML 描述符，如<a href="#chapter-xml-configuration">Chapter 8, <em>通过 XML 配置</em></a>。</p>
</div>
<div class="paragraph">
<p>如果您正在与几个 Jakarta Bean Validation 实现框架一起工作，您可以通过使用 <code>@HibernateValidator</code> 限定符注解注入点来确保从 Hibernate Validator 注入工厂和校验程序，<a href="#example-dependency-injection-using-hv">Example 129, &#8220;使用 <code>@HibernateValidator</code>  限定符注解&#8221;</a> 。</p>
</div>
<div id="example-dependency-injection-using-hv" class="exampleblock">
<div class="title">Example 129. 使用 <code>@HibernateValidator</code>  限定符注解</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.validator.qualifier;

@ApplicationScoped
public class RentalStation {

	@Inject
	@HibernateValidator
	private ValidatorFactory validatorFactory;

	@Inject
	@HibernateValidator
	private Validator validator;

	//...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>限定符注解的完全限定名是 <code>org.hibernate.validator.cdi.HibernateValidator</code> 。你需要确保不是导入 <code>org.hibernate.validator.HibernateValidator</code> ，它是 <code>ValidationProvider</code> 实现，用于在使用引导 API 时选择 Hibernate Validator (参见<a href="#section-retrieving-validator-factory-validator">Section 9.1, &#8220;获取 <code>ValidatorFactory</code> 和 <code>Validator</code>&#8221;</a>)。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过 <code>@Inject</code> ，您还可以将依赖关系注入约束校验器和其他 Jakarta Bean Validation 对象，例如 <code>MessageInterpolator</code> 实现等。</p>
</div>
<div class="paragraph">
<p><a href="#example-constraint-validator-injected-bean">Example 130, &#8220;带注入 bean 的约束校验器&#8221;</a> 演示了如何在 <code>ConstraintValidator</code> 实现中使用注入的 CDI bean 来确定给定的约束是否有效。如示例所示，您还可以使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 回调来实现所需的构造和销毁逻辑。</p>
</div>
<div id="example-constraint-validator-injected-bean" class="exampleblock">
<div class="title">Example 130. 带注入 bean 的约束校验器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.injection;

public class ValidLicensePlateValidator
		implements ConstraintValidator&lt;ValidLicensePlate, String&gt; {

	@Inject
	private VehicleRegistry vehicleRegistry;

	@PostConstruct
	public void postConstruct() {
		//do initialization logic...
	}

	@PreDestroy
	public void preDestroy() {
		//do destruction logic...
	}

	@Override
	public void initialize(ValidLicensePlate constraintAnnotation) {
	}

	@Override
	public boolean isValid(String licensePlate, ConstraintValidatorContext constraintContext) {
		return vehicleRegistry.isValidLicensePlate( licensePlate );
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_方法校验"><a class="anchor" href="#_方法校验"></a>11.3.2. 方法校验</h4>
<div class="paragraph">
<p>CDI 的方法拦截设施允许与 Jakarta Bean Validation 的方法校验功能进行非常紧密的集成。只需将约束注解放在 CDI bean 的参数和可执行文件的返回值上，它们将在调用方法或构造函数之前(参数约束)和之后(返回值约束)自动进行校验。</p>
</div>
<div class="paragraph">
<p>注意，不需要显式的拦截器绑定，相反，所需的方法校验拦截器将自动注册为所有带有约束方法和构造函数的托管 bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>拦截器 <code>org.hibernate.validator.cdi.internal.interceptor.ValidationInterceptor</code>  由 <code>org.hibernate.validator.cdi.internal.ValidationExtension</code> 这隐式地发生在 Java EE 执行期函式库中，或者通过添加 <em>hibernate-validator-cdi</em> 工件来显式地发生-参见<a href="#section-getting-started-cdi">Section 1.1.2, &#8220;CDI&#8221;</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以参见<a href="#example-cdi-method-validation">Example 131, &#8220;带有方法级约束的 CDI 管理 bean&#8221;</a>。</p>
</div>
<div id="example-cdi-method-validation" class="exampleblock">
<div class="title">Example 131. 带有方法级约束的 CDI 管理 bean</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation;

@ApplicationScoped
public class RentalStation {

	@Valid
	public RentalStation() {
		//...
	}

	@NotNull
	@Valid
	public Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
		return null;
	}

	@NotNull
	List&lt;Car&gt; getAvailableCars() {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation;

@RequestScoped
public class RentCarRequest {

	@Inject
	private RentalStation rentalStation;

	public void rentCar(String customerId, Date startDate, int duration) {
		//causes ConstraintViolationException
		rentalStation.rentCar( null, null, -1 );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里， <code>RentalStation</code> bean 承载了几个方法约束。当从另一个 bean (如 <code>RentCarRequest</code> )调用一个 <code>RentalStation</code> 方法时，将自动校验被调用方法的约束。如果像示例中那样传递了任何非法的参数值，方法拦截器将抛出 <code>ConstraintViolationException</code> ，并提供被违反的约束的详细信息。如果方法的返回值违反了任何返回值约束，情况也是如此。</p>
</div>
<div class="paragraph">
<p>类似地，构造函数约束在调用时自动进行校验。在示例中，将校验构造函数返回的 <code>RentalStation</code> 对象，因为构造函数返回值标记为 <code>@Valid</code>。</p>
</div>
<div class="sect4">
<h5 id="_校验可执行类型"><a class="anchor" href="#_校验可执行类型"></a>11.3.2.1. 校验可执行类型</h5>
<div class="paragraph">
<p>Jakarta Bean Validation允许对自动校验的可执行类型进行细粒度控制。默认情况下，会校验对构造函数和非 getter 方法的约束。因此，在<a href="#example-cdi-method-validation">Example 131, &#8220;带有方法级约束的 CDI 管理 bean&#8221;</a> 中，方法  <code>RentalStation#getAvailableCars()</code> 上的 <code>@NotNull</code> 约束在调用方法时不会得到校验。</p>
</div>
<div class="paragraph">
<p>您可以通过以下选项配置哪些类型的可执行文件在调用时进行校验:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过 XML 描述符 <em>META-INF/validation.xml</em> 全局配置可执行类型; 请参阅<a href="#section-configuration-validation-xml">Section 8.1, &#8220;配置 validator factory 通过 <em>validation.xml</em>&#8221;</a>的示例</p>
</li>
<li>
<p>在可执行或类型级别上使用 <code>@ValidateOnExecution</code> 注解</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果为给定的可执行文件指定了多个配置源，则可执行级别上的 <code>@ValidateOnExecution</code> 优先于类型级别上的 <code>@ValidateOnExecution</code> ，而 <code>@ValidateOnExecution</code> 通常优先于 <em>META-
INF/validation.xml</em> 中的全局配置类型。</p>
</div>
<div class="paragraph">
<p><a href="#example-using-validateonexecution">Example 132, &#8220;使用 <code>@ValidateOnExecution</code>&#8221;</a> ”展示了如何使用 <code>@ValidateOnExecution</code> 注解:</p>
</div>
<div id="example-using-validateonexecution" class="exampleblock">
<div class="title">Example 132. 使用 <code>@ValidateOnExecution</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation.configuration;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.ALL)
public class RentalStation {

	@Valid
	public RentalStation() {
		//...
	}

	@NotNull
	@Valid
	@ValidateOnExecution(type = ExecutableType.NONE)
	public Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
		return null;
	}

	@NotNull
	public List&lt;Car&gt; getAvailableCars() {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里不会在调用时校验 <code>rentCar()</code> 方法，因为它注解了 <code>@ValidateOnExecution(type = ExecutableType.NONE)</code> 。相比之下，构造函数和方法 <code>getAvailableCars()</code> 将由于在类型级别上给出了 <code>@ValidateOnExecution(type =
ExecutableType.ALL)</code> 而得到校验。 <code>ExecutableType.ALL</code> 是一种更加紧凑的形式，用于显式地指定所有类型 <code>CONSTRUCTORS</code>, <code>GETTER_METHODS</code> 和 <code>NON_GETTER_METHODS</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可执行校验可以通过在  <em>META-INF/validation.xml</em> 中指定 <code>&lt;executable-validation enabled="false"/&gt;</code>  来全局关闭。在这种情况下，所有 <code>@ValidateOnExecution</code> 注解都会被忽略。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>注意，当一个方法覆盖或实现一个超类型方法时，配置将从该覆盖或实现的方法中获取(通过 <code>@ValidateOnExecution</code> 在该方法本身或超类型上给出)。这可以保护 super-type 方法的客户端免受配置的意外更改，例如禁用子类型中重写的可执行文件的校验。</p>
</div>
<div class="paragraph">
<p>如果 CDI 管理的 bean 覆盖或实现了一个超类型方法，而这个超类型方法承载了任何约束，那么可能会发生校验拦截器没有正确地注册到 bean，导致在调用时没有对 bean 的方法进行校验。在这种情况下，您可以在子类上指定 <code>IMPLICIT</code> 类型，如<a href="#example-using-executabletype-implicit">Example 133, &#8220;使用 <code>ExecutableType.IMPLICIT</code>&#8221;</a> ，它确保发现所有需要的元数据，并在调用 <code>ExpressRentalStation</code> 上的方法时启用校验拦截器。</p>
</div>
<div id="example-using-executabletype-implicit" class="exampleblock">
<div class="title">Example 133. 使用 <code>ExecutableType.IMPLICIT</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation.implicit;

@ValidateOnExecution(type = ExecutableType.ALL)
public interface RentalStation {

	@NotNull
	@Valid
	Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays);

	@NotNull
	List&lt;Car&gt; getAvailableCars();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation.implicit;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.IMPLICIT)
public class ExpressRentalStation implements RentalStation {

	@Override
	public Car rentCar(Customer customer, Date startDate, @Min(1) int durationInDays) {
		//...
		return null;
	}

	@Override
	public List&lt;Car&gt; getAvailableCars() {
		//...
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java_ee"><a class="anchor" href="#_java_ee"></a>11.4. Java EE</h3>
<div class="paragraph">
<p>当您的应用程序在 Java EE 应用程序服务器( <a href="http://wildfly.org/">WildFly</a>)上运行时，您还可以通过管理对象(如 EJBs 等)中的 <code>@Resource</code> 注入获得 <code>Validator</code> 和 <code>ValidatorFactory</code>  实例，如<a href="#example-validator-resource-injection">Example 134, &#8220;通过 <code>@Resource</code> 注解注入 <code>Validator</code> 和 <code>ValidatorFactory</code>&#8221;</a>所示。</p>
</div>
<div id="example-validator-resource-injection" class="exampleblock">
<div class="title">Example 134. 通过 <code>@Resource</code> 注解注入 <code>Validator</code> 和 <code>ValidatorFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter11.javaee;

public class RentalStationBean {

	@Resource
	private ValidatorFactory validatorFactory;

	@Resource
	private Validator validator;

	//...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以分别以 "<em>java:comp/Validator</em>" 和 "<em>java:comp/ValidatorFactory</em>" 的名称从 JNDI 获得校验器和校验器工厂。</p>
</div>
<div class="paragraph">
<p>类似于通过 <code>@Inject</code> 实现的基于 cdi 的注入，这些对象表示默认的校验器和校验器工厂，因此可以使用 XML 描述符 <em>META-INF/validation.xml</em> (参见<a href="#chapter-xml-configuration">Chapter 8, <em>通过 XML 配置</em></a>)进行配置。</p>
</div>
<div class="paragraph">
<p>当您的应用程序启用了 cdi 时，注入的对象也可以感知到 cdi，例如，在约束校验器中支持依赖注入。</p>
</div>
</div>
<div class="sect2">
<h3 id="_javafx"><a class="anchor" href="#_javafx"></a>11.5. JavaFX</h3>
<div class="paragraph">
<p>Hibernate Validator 还支持对 JavaFX 属性进行展开。如果 JavaFX 出现在类路径上，那么 JavaFX 属性的 <code>ValueExtractor</code>s 就会自动注册。有关示例和进一步讨论，请参见<a href="#section-valueextraction-javafx">Section 7.4, &#8220;JavaFX 值提取器&#8221;</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-specifics"><a class="anchor" href="#validator-specifics"></a>12. Hibernate Validator 特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，您将学习如何使用 Hibernate Validator 提供的几个特性以及 Jakarta Bean Validation 规范定义的功能。这包括故障快速模式、编程约束配置的 API 和约束的布尔组合。</p>
</div>
<div class="paragraph">
<p>新的 APIs 或 SPIs 被标记为 <code>org.hibernate.validator.Incubating</code> ，表示他们都正在发展。这意味着这些元素(例如包、类型、方法、常量等)可能在后续版本中被不兼容地改变或删除。鼓励使用酝酿中的 API/SPI 成员(这样开发团队就可以获得关于这些新特性的反馈) ，但是在升级到新版本的 Hibernate Validator 时，您应该准备更新代码，因为使用这些开发中的特性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用以下部分中描述的特性可能会导致应用程序代码在 Jakarta Bean Validation提供程序之间不可移植。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_公共_api"><a class="anchor" href="#_公共_api"></a>12.1. 公共 API</h3>
<div class="paragraph">
<p>但是，让我们首先来看看 Hibernate Validator 的公共 API。下面您可以找到属于这个 API 的所有包的列表以及它们的用途。请注意，当一个包是公共 API 的一部分时，它的子包不一定是这样。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.hibernate.validator</code></dt>
<dd>
<p>Jakarta Bean Validation 引导机制(例如:验证提供程序，配置类)使用的类; 有关详细信息，请参阅<a href="#chapter-bootstrapping">Chapter 9, <em>Bootstrapping</em></a>。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.cfg</code>, <code>org.hibernate.validator.cfg.context</code>, <code>org.hibernate.validator.cfg.defs</code>, <code>org.hibernate.validator.spi.cfg</code></dt>
<dd>
<p>Hibernate Validator 中有关约束声明的 fluent API。 在 <code>org.hibernate.validator.cfg</code> 中可以找到 <code>ConstraintMapping</code> 接口，在 <code>org.hibernate.validator.cfg.defs</code> 可以找到所有约束的定义，在 <code>org.hibernate.validator.spi.cfg</code> 中可以找到使用该 API 配置默认验证器工厂的回调。有关详细信息，请参阅<a href="#section-programmatic-api">Section 12.4, &#8220;可编程约束的定义和声明&#8221;</a>。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.constraints</code>, <code>org.hibernate.validator.constraints.br</code>, <code>org.hibernate.validator.constraints.pl</code></dt>
<dd>
<p>Hibernate Validator 提供的一些有用的自定义约束，以及 Jakarta Bean Validation 规范定义的内置约束; 这些约束在<a href="#validator-defineconstraints-hv-constraints">Section 2.3.2, &#8220;附加约束&#8221;</a>中有详细描述。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.constraintvalidation</code></dt>
<dd>
<p>扩展的约束验证器上下文，允许为消息内插设置自定义属性。<a href="#section-hibernateconstraintvalidatorcontext">Section 12.13.1, &#8220;<code>HibernateConstraintValidatorContext</code>&#8221;</a> 描述了如何使用该特性。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.group</code>, <code>org.hibernate.validator.spi.group</code></dt>
<dd>
<p>组序列提供程序特性允许您根据验证的对象状态定义动态默认组序列; 具体内容可以在<a href="#section-default-group-class">Section 5.4, &#8220;重新定义默认组序列&#8221;</a>中找到。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.messageinterpolation</code>, <code>org.hibernate.validator.resourceloading</code>, <code>org.hibernate.validator.spi.resourceloading</code></dt>
<dd>
<p>与约束消息插值相关的类; 第一个包包含 Hibernate Validator 的默认消息插值器 <code>ResourceBundleMessageInterpolator</code> 。后两个包提供 <code>ResourceBundleLocator</code> SPI，用于加载资源包(请参阅<a href="#section-resource-bundle-locator">Section 4.2.1, &#8220;<code>ResourceBundleLocator</code>&#8221;</a>)及其默认实现。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.parameternameprovider</code></dt>
<dd>
<p>基于 Paranamer 库的 <code>ParameterNameProvider</code> ，见<a href="#section-paranamer-parameternameprovider">Section 12.14, &#8220;基于 Paranamer 的 <code>ParameterNameProvider</code>&#8221;</a>。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.propertypath</code></dt>
<dd>
<p>对 <code>jakarta.validation.Path</code> 的扩展，参见<a href="#section-extensions-path-api">Section 12.7, &#8220;拓展 Path API&#8221;</a>。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.spi.constraintdefinition</code></dt>
<dd>
<p>用于以编程方式注册附加约束验证器的 SPI，请参阅<a href="#section-constraint-definition-contribution">Section 12.15, &#8220;提供约束定义&#8221;</a>。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.spi.messageinterpolation</code></dt>
<dd>
<p>在插入约束违背消息时，可用于调整区域设置的分辨率的 SPI。参见<a href="#section-locale-resolver">Section 12.12, &#8220;自定义语言环境解析&#8221;</a>。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.validator.spi.nodenameprovider</code></dt>
<dd>
<p>一个 SPI，可用于在构造属性路径时更改属性名称的解析方式。请参阅<a href="#section-property-node-name-provider">Section 12.18, &#8220;自定义违反约束的属性名解析&#8221;</a>。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Validator 的公共包分为两类: 实际的 API 部分是用来被用户程序 <em>invoked(调用)</em> 或 <em>used(使用)</em> 的(例如用于编程约束声明的 API 或自定义约束) ，而 SPI (服务提供者接口)包含的接口是用来被用户程序 <em>implemented(实现)</em> 的(例如 <code>ResourceBundleLocator</code> )。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>该表中没有列出的任何包都是 Hibernate Validator 的内部包，用户程序不能访问。这些内部软件包的内容可以在不通知的情况下从一个版本更改到另一个版本，因此可能会破坏任何依赖它的用户程序代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-fail-fast"><a class="anchor" href="#section-fail-fast"></a>12.2. 快速失败模式</h3>
<div class="paragraph">
<p>使用快速失败模式，Hibernate Validator 允许在发生第一个约束冲突时从当前校验返回。这对于大型对象图的校验非常有用，因为您只对快速校验是否存在任何约束冲突感兴趣。</p>
</div>
<div class="paragraph">
<p><a href="#example-using-fail-fast">Example 135, &#8220;使用快速失败模式&#8221;</a> 展示了如何引导和使用失败快速启用的验证程序。</p>
</div>
<div id="example-using-fail-fast" class="exampleblock">
<div class="title">Example 135. 使用快速失败模式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.failfast;

public class Car {

	@NotNull
	private String manufacturer;

	@AssertTrue
	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	//getters and setters...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.failFast( true )
		.buildValidatorFactory()
		.getValidator();

Car car = new Car( null, false );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里验证过的对象实际上不能同时满足 <code>Car</code> 类上声明的约束，然而校验调用只产生一个 <code>ConstraintViolation</code> ，因为启用了 fail fast 模式。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不能保证以何种顺序计算约束，即不确定返回的冲突是来自 <code>@NotNull</code> 还是 <code>@AssertTrue</code> 约束。如果需要，可以使用<a href="#section-defining-group-sequences">Section 5.3, &#8220;定义分组序列&#8221;</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请参阅<a href="#section-provider-specific-settings">Section 9.2.8, &#8220;Provider-specific 配置&#8221;</a>，了解启动验证程序时启用失败快速模式的不同方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-method-validation-prerequisite-relaxation"><a class="anchor" href="#section-method-validation-prerequisite-relaxation"></a>12.3. 放宽类层次中方法校验的要求</h3>
<div class="paragraph">
<p>Jakarta Bean Validation 规范定义了一组前置条件，这些前置条件在定义类层次结构中方法的约束时适用。这些先决条件在 Jakarta Bean Validation 2.0规范的 <a href="http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance">section 5.6.5</a> 。请参阅本指南中的<a href="#section-method-constraints-inheritance-hierarchies">Section 3.1.4, &#8220;继承层次中的方法约束&#8221;</a>。</p>
</div>
<div class="paragraph">
<p>根据规范，Jakarta Bean Validation 实现程序可以放松这些先决条件。使用 Hibernate Validator，您可以通过以下两种方式之一完成此操作。</p>
</div>
<div class="paragraph">
<p>首先，你可以使用配置属性 <em>hibernate.validator.allow_parameter_constraint_override</em> ， <em>hibernate.validator.allow_multiple_cascaded_validation_on_result</em> 和  <em>hibernate.validator.allow_parallel_method_parameter_constraint</em> 在 <em>validation.xml</em> 文件中。参见 <a href="#example-relaxing-method-validation-xml">Example 136, &#8220;通过属性在类层次结构中配置方法验证行为&#8221;</a> 。</p>
</div>
<div id="example-relaxing-method-validation-xml" class="exampleblock">
<div class="title">Example 136. 通过属性在类层次结构中配置方法验证行为</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="https://jakarta.ee/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/configuration https://jakarta.ee/xml/ns/validation/validation-configuration-3.0.xsd"
        version="3.0"&gt;
    &lt;default-provider&gt;org.hibernate.validator.HibernateValidator&lt;/default-provider&gt;

    &lt;property name="hibernate.validator.allow_parameter_constraint_override"&gt;true&lt;/property&gt;
    &lt;property name="hibernate.validator.allow_multiple_cascaded_validation_on_result"&gt;true&lt;/property&gt;
    &lt;property name="hibernate.validator.allow_parallel_method_parameter_constraint"&gt;true&lt;/property&gt;
&lt;/validation-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，可以在编程引导期间应用这些设置。</p>
</div>
<div id="example-relaxing-method-validation" class="exampleblock">
<div class="title">Example 137. 在类层次结构中配置方法验证行为</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">HibernateValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class ).configure();

configuration.allowMultipleCascadedValidationOnReturnValues( true )
		.allowOverridingMethodAlterParameterConstraint( true )
		.allowParallelMethodsDefineParameterConstraints( true );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，所有这些属性都是 false，实现 Jakarta Bean Validation 规范中定义的默认行为。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>改变方法校验的默认行为将导致不符合规范和不可移植的应用程序。确保理解您正在做什么，并且您的用例确实需要对默认行为进行更改。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-programmatic-api"><a class="anchor" href="#section-programmatic-api"></a>12.4. 可编程约束的定义和声明</h3>
<div class="paragraph">
<p>根据 Jakarta Bean Validation 规范，您可以使用 Java 注解和基于 XML 的约束映射来定义和声明约束。</p>
</div>
<div class="paragraph">
<p>此外，Hibernate Validator 提供了一个 fluent API，允许对约束进行编程配置。用例包括在运行时动态添加约束，这取决于一些应用程序状态或测试，在这些测试中，您需要在不同场景中具有不同约束的实体，但是不希望为每个测试用例实现实际的 Java 类。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过 fluent API 添加的约束是通过标准配置功能配置的约束的附加物。但是也可以在需要时忽略注解和 XML 配置的约束。</p>
</div>
<div class="paragraph">
<p>API 以 <code>ConstraintMapping</code> 接口为中心。您可以通过 <code>HibernateValidatorConfiguration#createConstraintMapping()</code> 方法获得一个新的映射，然后以fluent的方式进行配置，如示例<a href="#example-constraint-mapping">Example 138, &#8220;编程实现约束声明&#8221;</a>所示。</p>
</div>
<div id="example-constraint-mapping" class="exampleblock">
<div class="title">Example 138. 编程实现约束声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">HibernateValidatorConfiguration configuration = Validation
		.byProvider( HibernateValidator.class )
		.configure();

ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.field( "manufacturer" )
			.constraint( new NotNullDef() )
		.field( "licensePlate" )
			.ignoreAnnotations( true )
			.constraint( new NotNullDef() )
			.constraint( new SizeDef().min( 2 ).max( 14 ) )
	.type( RentalCar.class )
		.getter( "rentalStation" )
			.constraint( new NotNullDef() );

Validator validator = configuration.addMapping( constraintMapping )
		.buildValidatorFactory()
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用方法链在多个类和属性上配置约束。约束定义类 <code>NotNullDef</code> 和 <code>SizeDef</code> 是帮助器类，允许以类型安全的方式配置约束参数。定义类存在于 <code>org.hibernate.validator.cfg.defs</code> 包中的所有内置约束。通过调用 <code>ignoreAnnotations()</code> ，对于给定的元素，通过注解 或 XML 配置的任何约束都会被忽略。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个元素(类型、属性、方法等)只能在用于设置一个验证器工厂的所有约束映射中配置一次。否则将抛出  <code>ValidationException</code> 异常。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不支持通过配置子类型向非重写的超类型属性和方法添加约束。在这种情况下，您需要配置超类型。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>配置了映射之后，必须将其添加回配置对象，然后可以从中获得验证器工厂。</p>
</div>
<div class="paragraph">
<p>对于自定义约束，您可以创建自己的扩展 <code>ConstraintDef</code> 的定义类，也可以使用  <code>GenericConstraintDef</code> ，如<a href="#example-generic-constraint-mapping">Example 139, &#8220;自定义约束的编程声明&#8221;</a>中所示。</p>
</div>
<div id="example-generic-constraint-mapping" class="exampleblock">
<div class="title">Example 139. 自定义约束的编程声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.field( "licensePlate" )
			.constraint( new GenericConstraintDef&lt;&gt;( CheckCase.class )
				.param( "value", CaseMode.UPPER )
			);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>containerElementType()</code> ，编程 API 支持容器元素约束。</p>
</div>
<div class="paragraph">
<p><a href="#example-nested-container-element-constraints">Example 140, &#8220;嵌套容器元素约束的编程声明&#8221;</a> 展示了一个在嵌套容器元素上声明约束的例子。</p>
</div>
<div id="example-nested-container-element-constraints" class="exampleblock">
<div class="title">Example 140. 嵌套容器元素约束的编程声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.field( "manufacturer" )
			.constraint( new NotNullDef() )
		.field( "licensePlate" )
			.ignoreAnnotations( true )
			.constraint( new NotNullDef() )
			.constraint( new SizeDef().min( 2 ).max( 14 ) )
		.field( "partManufacturers" )
			.containerElementType( 0 )
				.constraint( new NotNullDef() )
			.containerElementType( 1, 0 )
				.constraint( new NotNullDef() )
	.type( RentalCar.class )
		.getter( "rentalStation" )
			.constraint( new NotNullDef() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如前所述，传递给 <code>containerElementType()</code> 的参数是用于获取所需嵌套容器元素类型的类型变量索引的路径。</p>
</div>
<div class="paragraph">
<p>通过调用 <code>valid()</code> ，您可以为级联验证标记一个成员，这相当于用 <code>@Valid</code> 对其进行注释。使用 <code>convertGroup()</code> 方法配置要在级联验证期间应用的任何组转换(相当于 <code>@ConvertGroup</code>)。请参阅 <a href="#example-cascading-constraints">Example 141, &#8220;为级联校验标记属性&#8221;</a>。</p>
</div>
<div id="example-cascading-constraints" class="exampleblock">
<div class="title">Example 141. 为级联校验标记属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.field( "driver" )
			.constraint( new NotNullDef() )
			.valid()
			.convertGroup( Default.class ).to( PersonDefault.class )
		.field( "partManufacturers" )
			.containerElementType( 0 )
				.valid()
			.containerElementType( 1, 0 )
				.valid()
	.type( Person.class )
		.field( "name" )
			.constraint( new NotNullDef().groups( PersonDefault.class ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>不仅可以使用 fluent API 配置 bean 约束，还可以使用方法和构造函数约束。如<a href="#example-method-constraint-mapping">Example 142, &#8220;方法和构造函数约束的编程声明&#8221;</a> 构造函数通过其参数类型和方法的名称和参数类型来标识。选择了方法或构造函数之后，可以标记其参数和/或级联验证的返回值，并添加约束和交叉参数约束。</p>
</div>
<div class="paragraph">
<p>如示例所示，还可以对容器元素类型调用 <code>valid()</code> 。</p>
</div>
<div id="example-method-constraint-mapping" class="exampleblock">
<div class="title">Example 142. 方法和构造函数约束的编程声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.constructor( String.class )
			.parameter( 0 )
				.constraint( new SizeDef().min( 3 ).max( 50 ) )
			.returnValue()
				.valid()
		.method( "drive", int.class )
			.parameter( 0 )
				.constraint( new MaxDef().value( 75 ) )
		.method( "load", List.class, List.class )
			.crossParameter()
				.constraint( new GenericConstraintDef&lt;&gt;(
						LuggageCountMatchesPassengerCount.class ).param(
							"piecesOfLuggagePerPassenger", 2
						)
				)
		.method( "getDriver" )
			.returnValue()
				.constraint( new NotNullDef() )
				.valid();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后但并非最不重要的是，您可以配置默认组序列或类型的默认组序列提供程序，如下面的示例所示。</p>
</div>
<div id="example-sequences" class="exampleblock">
<div class="title">Example 143. 默认组序列和默认组序列提供程序的配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.defaultGroupSequence( Car.class, CarChecks.class )
	.type( RentalCar.class )
		.defaultGroupSequenceProviderClass( RentalCarGroupSequenceProvider.class );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-programmatic-api-contributor"><a class="anchor" href="#section-programmatic-api-contributor"></a>12.5. 将程序化的约束声明应用到默认的验证器工厂</h3>
<div class="paragraph">
<p>如果您没有手动启动验证器工厂，而是使用通过 <em>META-INF/validation.xml</em> 配置的默认工厂(参见<a href="#chapter-xml-configuration">Chapter 8, <em>通过 XML 配置</em></a>) ，则可以通过创建一个或多个约束映射贡献者来添加一个或多个约束映射。为此，实现 <code>ConstraintMappingContributor</code> 契约:</p>
</div>
<div id="example-constraint-mapping-contributor" class="exampleblock">
<div class="title">Example 144. 自定义 <code>ConstraintMappingContributor</code> 的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.constraintapi;

public class MyConstraintMappingContributor implements ConstraintMappingContributor {

	@Override
	public void createConstraintMappings(ConstraintMappingBuilder builder) {
		builder.addConstraintMapping()
			.type( Marathon.class )
				.getter( "name" )
					.constraint( new NotNullDef() )
				.field( "numberOfHelpers" )
					.constraint( new MinDef().value( 1 ) );

		builder.addConstraintMapping()
			.type( Runner.class )
				.field( "paidEntryFee" )
					.constraint( new AssertTrueDef() );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您需要使用属性键 <code>hibernate.validator.constraint_mapping_contributors</code> 在  <em>META-INF/validation.xml</em> 中指定贡献者实现的完全限定类名。可以通过用逗号分隔多个贡献者来指定它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-advanced-constraint-composition"><a class="anchor" href="#section-advanced-constraint-composition"></a>12.6. 高级约束组合特性</h3>
<div class="sect3">
<h4 id="_纯组合约束的验证目标规范"><a class="anchor" href="#_纯组合约束的验证目标规范"></a>12.6.1. 纯组合约束的验证目标规范</h4>
<div class="paragraph">
<p>如果您在方法声明中指定了一个纯粹的组合约束——即一个本身没有验证程序但仅由其他组合约束组成的约束——验证引擎无法确定该约束是作为返回值约束还是作为交叉参数约束应用。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 允许通过在组合约束类型的声明上指定 <code>@SupportedValidationTarget</code> 注释来解决这种模糊性，如<a href="#example-purely-composed-constraint-validation-target">Example 145, &#8220;指定纯组合约束的验证目标&#8221;</a> 。 <code>@ValidInvoiceAmount</code> 不声明任何验证器，但它完全由 <code>@Min</code> 和 <code>@NotNull</code> 约束组成。 <code>@SupportedValidationTarget</code> 确保在方法声明中给出约束时，约束应用于方法返回值。</p>
</div>
<div id="example-purely-composed-constraint-validation-target" class="exampleblock">
<div class="title">Example 145. 指定纯组合约束的验证目标</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.purelycomposed;

@Min(value = 0)
@NotNull
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
@SupportedValidationTarget(ValidationTarget.ANNOTATED_ELEMENT)
@ReportAsSingleViolation
public @interface ValidInvoiceAmount {

	String message() default "{org.hibernate.validator.referenceguide.chapter11.purelycomposed."
			+ "ValidInvoiceAmount.message}";

	Class&lt;?&gt;[] groups() default {};

	Class&lt;? extends Payload&gt;[] payload() default {};

	@OverridesAttribute(constraint = Min.class, name = "value")
	long value();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-boolean-constraint-composition"><a class="anchor" href="#section-boolean-constraint-composition"></a>12.6.2. 布尔约束组合</h4>
<div class="paragraph">
<p>Jakarta Bean Validation 指定组合约束的约束(参见<a href="#section-constraint-composition">Section 6.4, &#8220;约束组合&#8221;</a>)都通过逻辑 <em>AND</em> 进行组合。这意味着所有组合约束都需要返回 true 才能获得全面成功的验证。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 为此提供了扩展，并允许您通过逻辑 <em>OR</em> 或 <em>NOT</em> 来组合约束。为此，必须使用 constraint composition 注释和 enum CompositionType 及其值 <em>AND</em> 、 <em>OR</em>  和 <em>ALL_FALSE</em> 。</p>
</div>
<div class="paragraph">
<p><a href="#example-boolean-constraint-composition">Example 146, &#8220;OR 约束的组合&#8221;</a> 展示了如何构建一个组合约束 <code>@PatternOrSize</code> ，其中只有一个组合约束是有效的，才能通过验证。验证过的字符串要么全部采用小写格式，要么长度在两到三个字符之间。</p>
</div>
<div id="example-boolean-constraint-composition" class="exampleblock">
<div class="title">Example 146. OR 约束的组合</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.booleancomposition;

@ConstraintComposition(OR)
@Pattern(regexp = "[a-z]")
@Size(min = 2, max = 3)
@ReportAsSingleViolation
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
public @interface PatternOrSize {
	String message() default "{org.hibernate.validator.referenceguide.chapter11." +
			"booleancomposition.PatternOrSize.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 <em>ALL_FALSE</em> 作为组合类型隐式地强制在约束组合验证失败的情况下只报告一个违反。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-extensions-path-api"><a class="anchor" href="#section-extensions-path-api"></a>12.7. 拓展 Path API</h3>
<div class="paragraph">
<p>Hibernate Validator 提供了对 <code>jakarta.validation.Path</code> API的扩展。对于  <code>ElementKind.PROPERTY</code> 和 <code>ElementKind.CONTAINER_ELEMENT</code> 节点，它允许获取表示的属性的值。为此，将给定节点缩小到 <code>org.hibernate.validator.path.PropertyNode</code> 类型。或 <code>org.hibernate.validator.path.ContainerElementNode</code> 。分别使用 <code>Node#as()</code> 作为 ，如下例所示:</p>
</div>
<div id="example-property-node-get-value" class="exampleblock">
<div class="title">Example 147. 从属性节点获取值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Building building = new Building();

// Assume the name of the person violates a @Size constraint
Person bob = new Person( "Bob" );
Apartment bobsApartment = new Apartment( bob );
building.getApartments().add( bobsApartment );

Set&lt;ConstraintViolation&lt;Building&gt;&gt; constraintViolations = validator.validate( building );

Path path = constraintViolations.iterator().next().getPropertyPath();
Iterator&lt;Path.Node&gt; nodeIterator = path.iterator();

Path.Node node = nodeIterator.next();
assertEquals( node.getName(), "apartments" );
assertSame( node.as( PropertyNode.class ).getValue(), bobsApartment );

node = nodeIterator.next();
assertEquals( node.getName(), "resident" );
assertSame( node.as( PropertyNode.class ).getValue(), bob );

node = nodeIterator.next();
assertEquals( node.getName(), "name" );
assertEquals( node.as( PropertyNode.class ).getValue(), "Bob" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这对于获取属性路径上的 <code>Set</code> 属性元素(例如示例中的 <code>apartments</code> )也非常有用，否则无法识别(与 <code>Map</code> 和 <code>List</code> 不同，在这种情况下没有键或索引)。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-dynamic-payload"><a class="anchor" href="#section-dynamic-payload"></a>12.8. 动态有效载荷作为 <code>ConstraintViolation</code></h3>
<div class="paragraph">
<p>在某些情况下，如果违反约束提供了额外的数据——所谓的动态有效负载，则违反的自动处理可以得到帮助。例如，这个动态有效负载可能包含对用户如何解决冲突的提示。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>HibernateConstraintValidatorContext</code> 在 <a href="#validator-customconstraints">custom constraints</a> 中设置动态有效负载。在 <a href="#example-constraint-validator-setting-dynamic-payload">Example 148, &#8220;<code>ConstraintValidator</code> 实现设置动态有效负载&#8221;</a> ，其中 <code>jakarta.validation.ConstraintValidatorContext</code> 。为了调用 <code>withDynamicPayload</code> ，ConstraintValidatorContext 被解包到 <code>HibernateConstraintValidatorContext</code> 。</p>
</div>
<div id="example-constraint-validator-setting-dynamic-payload" class="exampleblock">
<div class="title">Example 148. <code>ConstraintValidator</code> 实现设置动态有效负载</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.dynamicpayload;

import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;

public class ValidPassengerCountValidator implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	private static final Map&lt;Integer, String&gt; suggestedCars = newHashMap();

	static {
		suggestedCars.put( 2, "Chevrolet Corvette" );
		suggestedCars.put( 3, "Toyota Volta" );
		suggestedCars.put( 4, "Maserati GranCabrio" );
		suggestedCars.put( 5, " Mercedes-Benz E-Class" );
	}

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext context) {
		if ( car == null ) {
			return true;
		}

		int passengerCount = car.getPassengers().size();
		if ( car.getSeatCount() &gt;= passengerCount ) {
			return true;
		}
		else {

			if ( suggestedCars.containsKey( passengerCount ) ) {
				HibernateConstraintValidatorContext hibernateContext = context.unwrap(
						HibernateConstraintValidatorContext.class
				);
				hibernateContext.withDynamicPayload( suggestedCars.get( passengerCount ) );
			}
			return false;
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在违反约束处理端，有一个 <code>jakarta.validation.ConstraintViolation</code> 。然后可以反过来将 解包为 <code>HibernateConstraintViolation</code> ，以便为进一步处理检索动态有效负载。</p>
</div>
<div id="example-retrieving-dynamic-payload" class="exampleblock">
<div class="title">Example 149. 检索 <code>ConstraintViolation</code>'s 动态有效载荷</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Car car = new Car( 2 );
car.addPassenger( new Person() );
car.addPassenger( new Person() );
car.addPassenger( new Person() );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation&lt;Car&gt; constraintViolation = constraintViolations.iterator().next();
@SuppressWarnings("unchecked")
HibernateConstraintViolation&lt;Car&gt; hibernateConstraintViolation = constraintViolation.unwrap(
		HibernateConstraintViolation.class
);
String suggestedCar = hibernateConstraintViolation.getDynamicPayload( String.class );
assertEquals( "Toyota Volta", suggestedCar );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="el-features"><a class="anchor" href="#el-features"></a>12.9. 启用EL表达式语言功能</h3>
<div class="paragraph">
<p>Hibernate 验证器限制默认情况下公开的表达式语言特性。</p>
</div>
<div class="paragraph">
<p>为此，我们在 <code>ExpressionLanguageFeatureLevel</code> 中定义了几个特征级别:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code>: 表达式语言插值完全禁用。</p>
</li>
<li>
<p><code>VARIABLES</code>: 允许通过 <code>addExpressionVariable()</code> 插入变量、资源包和 <code>formatter</code> 程序对象的使用。</p>
</li>
<li>
<p><code>BEAN_PROPERTIES</code>: 允许所有 <code>VARIABLES</code> 都允许加上 BEAN 属性的插值。</p>
</li>
<li>
<p><code>BEAN_METHODS</code>: 也允许执行 BEAN 方法。这可能会导致严重的安全问题，包括如果不仔细处理就会任意执行代码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据上下文，我们展示的特性是不同的:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于约束，默认级别为 <code>BEAN_PROPERTIES</code> 。要正确插入所有内置约束消息，您至少需要 <code>VARIABLES</code> 级别。</p>
</li>
<li>
<p>对于通过 <code>ConstraintValidatorContext</code> 创建的自定义违规，默认情况下禁用 Expression Language。您可以为特定的自定义违规启用它，当启用时，它将默认为 <code>VARIABLES</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hibernate Validator 提供了在启动 <code>ValidatorFactory</code> 时覆盖这些默认值的方法。</p>
</div>
<div class="paragraph">
<p>要更改约束的 Expression Language 特性级别，请使用以下命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.constraintExpressionLanguageFeatureLevel( ExpressionLanguageFeatureLevel.VARIABLES )
		.buildValidatorFactory();</code></pre>
</div>
</div>
<div class="paragraph">
<p>要更改用于自定义违规的表达式语言特性级别，请使用以下命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.customViolationExpressionLanguageFeatureLevel( ExpressionLanguageFeatureLevel.VARIABLES )
		.buildValidatorFactory();</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这样做将自动为应用程序中的所有自定义违规启用表达式语言。</p>
</div>
<div class="paragraph">
<p>它应该只用于兼容性和简化从旧版本 Hibernate 验证器的迁移。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>还可以使用以下属性定义这些级别:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hibernate.validator.constraint_expression_language_feature_level</code></p>
</li>
<li>
<p><code>hibernate.validator.custom_violation_expression_language_feature_level</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些属性的可接受值是: <code>none</code>, <code>variables</code>, <code>bean-properties</code> 和 <code>bean-methods</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="non-el-message-interpolator"><a class="anchor" href="#non-el-message-interpolator"></a>12.10. <code>ParameterMessageInterpolator</code></h3>
<div class="paragraph">
<p>Hibernate Validator 要求每个默认情况下都有一个统一 EL 的实现(参见<a href="#validator-gettingstarted-uel">Section 1.1.1, &#8220;统一的EL表达式&#8221;</a> )。这是允许使用 Jakarta Bean Validation 规范定义的 EL 表达式插值约束错误消息所需的。</p>
</div>
<div class="paragraph">
<p>对于不能或不希望提供 EL 实现的环境，Hibernate Validator 提供了一个非 EL 的消息内插器- <code>org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator</code> 。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#section-custom-message-interpolation">Section 4.2, &#8220;自定义消息插值&#8221;</a>，了解如何插入自定义消息插值器实现。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>包含 EL 表达式的约束消息将通过 <code>org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator</code> 返回未插入的消息。这也会影响使用 EL 表达式的内置默认约束消息。目前， <code>DecimalMin</code> 和 <code>DecimalMax</code> 受到影响。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_resourcebundlelocator"><a class="anchor" href="#_resourcebundlelocator"></a>12.11. <code>ResourceBundleLocator</code></h3>
<div class="paragraph">
<p>通过 <code>ResourceBundleLocator</code> ，Hibernate Validator 提供了一个额外的 SPI，它允许从  <em>ValidationMessages</em> 之外的其他资源包中检索错误消息，同时仍然使用规范定义的实际插值算法。请参阅<a href="#section-resource-bundle-locator">Section 4.2.1, &#8220;<code>ResourceBundleLocator</code>&#8221;</a>，以了解如何使用该 SPI。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-locale-resolver"><a class="anchor" href="#section-locale-resolver"></a>12.12. 自定义语言环境解析</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些合同被标记为 <code>@Incubating</code> ，因此它们在未来可能会发生变化。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hibernate Validator 提供了几个扩展点来构建自定义语言环境解析策略。在插入违反约束的消息时使用已解析的区域设置。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 的默认行为是始终使用系统默认语言环境(通过 <code>Locale.getDefault()</code> 获得)。例如，如果您通常将系统区域设置为  <code>en-US</code> ，但希望应用程序提供法语消息，那么这可能不是理想的行为。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何将 Hibernate Validator 缺省语言环境设置为 <code>fr-FR</code>:</p>
</div>
<div id="example-configure-default-locale" class="exampleblock">
<div class="title">Example 150. 配置默认语言环境</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.defaultLocale( Locale.FRANCE )
		.buildValidatorFactory()
		.getValidator();

Set&lt;ConstraintViolation&lt;Bean&gt;&gt; violations = validator.validate( new Bean() );
assertEquals( "doit avoir la valeur vrai", violations.iterator().next().getMessage() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>虽然这已经是一个很好的改进，但是在一个完全国际化的应用程序中，这是不够的: 您需要 Hibernate Validator 来根据用户上下文选择区域设置。</p>
</div>
<div class="paragraph">
<p>Hibernate Validator 提供了 <code>org.hibernate.validator.spi.messageinterpolation.LocaleResolver</code> SPI，它允许微调区域设置的分辨率。通常，在 JAX-RS 环境中，您可以从 <code>Accept-Language</code> HTTP 头解析要使用的语言环境。</p>
</div>
<div class="paragraph">
<p>在下面的示例中，我们使用硬编码的值，但是，举例来说，在 RESTEasy 应用程序的情况下，您可以从  <code>ResteasyContext</code> 中提取标头。</p>
</div>
<div id="example-locale-resolver" class="exampleblock">
<div class="title">Example 151. 对用于通过 <code>LocaleResolver</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">LocaleResolver localeResolver = new LocaleResolver() {

	@Override
	public Locale resolve(LocaleResolverContext context) {
		// get the locales supported by the client from the Accept-Language header
		String acceptLanguageHeader = "it-IT;q=0.9,en-US;q=0.7";

		List&lt;LanguageRange&gt; acceptedLanguages = LanguageRange.parse( acceptLanguageHeader );
		List&lt;Locale&gt; resolvedLocales = Locale.filter( acceptedLanguages, context.getSupportedLocales() );

		if ( resolvedLocales.size() &gt; 0 ) {
			return resolvedLocales.get( 0 );
		}

		return context.getDefaultLocale();
	}
};

Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.defaultLocale( Locale.FRANCE )
		.locales( Locale.FRANCE, Locale.ITALY, Locale.US )
		.localeResolver( localeResolver )
		.buildValidatorFactory()
		.getValidator();

Set&lt;ConstraintViolation&lt;Bean&gt;&gt; violations = validator.validate( new Bean() );
assertEquals( "deve essere true", violations.iterator().next().getMessage() );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用 <code>LocaleResolver</code> 时，必须通过 <code>locales()</code> 方法定义受支持的区域设置列表。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_自定义上下文"><a class="anchor" href="#_自定义上下文"></a>12.13. 自定义上下文</h3>
<div class="paragraph">
<p>Jakarta Bean Validation 规范在其 API 的几个方面提供了打开给定接口到特定实现子类型的可能性。在 <code>ConstraintValidator</code> 实现中创建约束冲突的情况下，以及在 <code>MessageInterpolator</code> 实例中创建消息插值的情况下，为所提供的上下文实例存在 <code>unwrap()</code> 方法—— <code>ConstraintValidatorContext</code> <code>MessageInterpolatorContext</code>。Hibernate Validator 为这两个接口提供自定义扩展。</p>
</div>
<div class="sect3">
<h4 id="section-hibernateconstraintvalidatorcontext"><a class="anchor" href="#section-hibernateconstraintvalidatorcontext"></a>12.13.1. <code>HibernateConstraintValidatorContext</code></h4>
<div id="section-custom-constraint-validator-context" class="paragraph">
<p><code>HibernateConstraintValidatorContext</code> 是 <code>ConstraintValidatorContext</code> 的一个子类型，它允许你:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>启用表达式语言插值为一个特定的自定义冲突-见下面</p>
</li>
<li>
<p>使用 <code>HibernateConstraintValidatorContext#addExpressionVariable(String, Object)</code> 或 <code>HibernateConstraintValidatorContext#addMessageParameter(String, Object)</code> 通过 Expression Language 消息插值工具设置插值的任意参数。</p>
<div id="example-custom-expression-variable" class="exampleblock">
<div class="title">Example 152. 自定义 <code>@Future</code>  注入表达式变量的验证程序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.context;

import java.time.Instant;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import jakarta.validation.constraints.Future;

import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;

public class MyFutureValidator implements ConstraintValidator&lt;Future, Instant&gt; {

	@Override
	public void initialize(Future constraintAnnotation) {
	}

	@Override
	public boolean isValid(Instant value, ConstraintValidatorContext context) {
		if ( value == null ) {
			return true;
		}

		HibernateConstraintValidatorContext hibernateContext = context.unwrap(
				HibernateConstraintValidatorContext.class
		);

		Instant now = Instant.now( context.getClockProvider().getClock() );

		if ( !value.isAfter( now ) ) {
			hibernateContext.disableDefaultConstraintViolation();
			hibernateContext
					.addExpressionVariable( "now", now )
					.buildConstraintViolationWithTemplate( "Must be after ${now}" )
					.addConstraintViolation();

			return false;
		}

		return true;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div id="example-custom-message-parameter" class="exampleblock">
<div class="title">Example 153. 自定义 <code>@Future</code> 注入消息参数的验证程序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.context;

import java.time.Instant;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import jakarta.validation.constraints.Future;

import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;

public class MyFutureValidatorMessageParameter implements ConstraintValidator&lt;Future, Instant&gt; {

	@Override
	public void initialize(Future constraintAnnotation) {
	}

	@Override
	public boolean isValid(Instant value, ConstraintValidatorContext context) {
		if ( value == null ) {
			return true;
		}

		HibernateConstraintValidatorContext hibernateContext = context.unwrap(
				HibernateConstraintValidatorContext.class
		);

		Instant now = Instant.now( context.getClockProvider().getClock() );

		if ( !value.isAfter( now ) ) {
			hibernateContext.disableDefaultConstraintViolation();
			hibernateContext
					.addMessageParameter( "now", now )
					.buildConstraintViolationWithTemplate( "Must be after {now}" )
					.addConstraintViolation();

			return false;
		}

		return true;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除了语法之外，消息参数和表达式变量之间的主要区别在于消息参数是简单的插值，而表达式变量是使用表达式语言引擎解释的。实际上，如果不需要表达式语言的高级特性，可以使用消息参数。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意，通过 <code>addExpressionVariable(String, Object)</code> 和 <code>addMessageParameter(String, Object)</code> 指定的参数是全局的，并且应用于此 <code>isValid()</code> 调用创建的所有违反约束的情况。这包括违反缺省约束，但也包括 <code>ConstraintViolationBuilder</code> 创建的所有违反。但是，您可以在 <code>ConstraintViolationBuilder#addConstraintViolation()</code> 的调用之间更新参数。</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>设置一个任意的动态有效负载——参见 <a href="#section-dynamic-payload">Section 12.8, &#8220;动态有效载荷作为 <code>ConstraintViolation</code>&#8221;</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，表达式语言插值是 <strong>disabled</strong> 自定义违反，这是为了避免任意代码执行或敏感的数据泄漏，如果消息模板是从不正确的转义用户输入构建的。</p>
</div>
<div class="paragraph">
<p>通过使用 <code>enableExpressionLanguage()</code> ，可以为给定的自定义违规启用 Expression Language，如下面的示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>public class SafeValidator implements ConstraintValidator&lt;ZipCode, String&gt; {

	@Override
	public boolean isValid(String value, ConstraintValidatorContext context) {
		if ( value == null ) {
			return true;
		}

		HibernateConstraintValidatorContext hibernateContext = context.unwrap(
				HibernateConstraintValidatorContext.class );
		hibernateContext.disableDefaultConstraintViolation();

		if ( isInvalid( value ) ) {
			hibernateContext
					.addExpressionVariable( "validatedValue", value )
					.buildConstraintViolationWithTemplate( "${validatedValue} is not a valid ZIP code" )
					.enableExpressionLanguage()
					.addConstraintViolation();

			return false;
		}

		return true;
	}

	private boolean isInvalid(String value) {
		// ...
		return false;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，消息模板将由 Expression Language 引擎插入。</p>
</div>
<div class="paragraph">
<p>默认情况下，启用表达式语言时只启用变量插值。</p>
</div>
<div class="paragraph">
<p>你可以通过使用 <code>HibernateConstraintViolationBuilder#enableExpressionLanguage(ExpressionLanguageFeatureLevel level)</code> 来启用更多功能。</p>
</div>
<div class="paragraph">
<p>我们为表达式语言插值定义了几个级别的特性:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code>: 表达式语言插值是完全禁用-这是默认的自定义违反。</p>
</li>
<li>
<p><code>VARIABLES</code>: 允许通过 <code>addExpressionVariable()</code> 插入变量、资源包和 <code>formatter</code> 程序对象的使用。</p>
</li>
<li>
<p><code>BEAN_PROPERTIES</code>: 允许所有 <code>VARIABLES</code> 都允许加上 BEAN 属性的插值。</p>
</li>
<li>
<p><code>BEAN_METHODS</code>: 也允许执行 BEAN 方法。这可能会导致严重的安全问题，包括如果不仔细处理就会任意执行代码。</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 <code>addExpressionVariable()</code> 是将变量注入到表达式中的唯一安全方法，如果使用 <code>BEAN_PROPERTIES</code> 或 <code>BEAN_METHODS</code> 特性级别，这一点尤为重要。</p>
</div>
<div class="paragraph">
<p>如果你通过简单地将用户输入连接到消息中来注入用户输入，你将允许潜在的任意代码执行和敏感的数据泄漏: 如果用户输入包含有效的表达式，它们将被表达式语言引擎执行。</p>
</div>
<div class="paragraph">
<p>这里有一个你 <strong>ABSOLUTELY NOT(绝对不能做)</strong> 的事情的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public class UnsafeValidator implements ConstraintValidator&lt;ZipCode, String&gt; {

	@Override
	public boolean isValid(String value, ConstraintValidatorContext context) {
		if ( value == null ) {
			return true;
		}

		context.disableDefaultConstraintViolation();

		HibernateConstraintValidatorContext hibernateContext = context.unwrap(
				HibernateConstraintValidatorContext.class );
		hibernateContext.disableDefaultConstraintViolation();

		if ( isInvalid( value ) ) {
			hibernateContext
					// THIS IS UNSAFE, DO NOT COPY THIS EXAMPLE
					.buildConstraintViolationWithTemplate( value + " is not a valid ZIP code" )
					.enableExpressionLanguage()
					.addConstraintViolation();

			return false;
		}

		return true;
	}

	private boolean isInvalid(String value) {
		// ...
		return false;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，如果 <code>value</code> (可能是用户输入)包含有效的表达式，则表达式语言引擎将对其进行插值，从而可能导致不安全的行为。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_hibernatemessageinterpolatorcontext"><a class="anchor" href="#_hibernatemessageinterpolatorcontext"></a>12.13.2. <code>HibernateMessageInterpolatorContext</code></h4>
<div class="paragraph">
<p>Hibernate Validator 还提供了一个自定义扩展 <code>MessageInterpolatorContext</code> ，即 <code>HibernateMessageInterpolatorContext</code> (参见<a href="#example-custom-message-interpolator-context">Example 154, &#8220;<code>HibernateMessageInterpolatorContext</code>&#8221;</a> )。引入这个子类型是为了将 Hibernate Validator 更好地集成到 Glassfish 中。在这种情况下，需要根 bean 类型来确定消息资源束的正确类装入器。如果您有任何其他用例，请让我们知道。</p>
</div>
<div id="example-custom-message-interpolator-context" class="exampleblock">
<div class="title">Example 154. <code>HibernateMessageInterpolatorContext</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public interface HibernateMessageInterpolatorContext extends MessageInterpolator.Context {

	/**
	 * Returns the currently validated root bean type.
	 *
	 * @return The currently validated root bean type.
	 */
	Class&lt;?&gt; getRootBeanType();

	/**
	 * @return the message parameters added to this context for interpolation
	 *
	 * @since 5.4.1
	 */
	Map&lt;String, Object&gt; getMessageParameters();

	/**
	 * @return the expression variables added to this context for EL interpolation
	 *
	 * @since 5.4.1
	 */
	Map&lt;String, Object&gt; getExpressionVariables();

	/**
	 * @return the path to the validated constraint starting from the root bean
	 *
	 * @since 6.1
	 */
	Path getPropertyPath();

	/**
	 * @return the level of features enabled for the Expression Language engine
	 *
	 * @since 6.2
	 */
	ExpressionLanguageFeatureLevel getExpressionLanguageFeatureLevel();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-paranamer-parameternameprovider"><a class="anchor" href="#section-paranamer-parameternameprovider"></a>12.14. 基于 Paranamer 的 <code>ParameterNameProvider</code></h3>
<div class="paragraph">
<p>Hibernate Validator 附带了一个利用 <a href="http://paranamer.codehaus.org/">Paranamer</a> 库的 <code>ParameterNameProvider</code> 实现。</p>
</div>
<div class="paragraph">
<p>这个库提供了几种在运行时获取参数名的方法，例如，基于 Java 编译器创建的调试符号，在编译后的步骤中将带有参数名的常量编织到字节码中，或者像 JSR 330的 <code>@Named</code> 注释这样的注释。</p>
</div>
<div class="paragraph">
<p>为了使用 <code>ParanamerParameterNameProvider</code> ，要么在引导验证程序时传递一个实例，如<a href="#example-using-custom-parameter-name-provider">Example 107, &#8220;使用自定义 <code>ParameterNameProvider</code>&#8221;</a> ，要么指定 <code>org.hibernate.validator.parameternameprovider.ParanamerParameterNameProvider</code> 作为 <em>META-INF/validation.xml</em> 文件中 <code>&lt;parameter-name-provider&gt;</code> 元素的值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用此参数名提供程序时，需要将 Paranamer 库添加到类路径中。它可以在 Maven Central 存储库中获得，该存储库的组 id 为 <code>com.thoughtworks.paranamer</code> ，工件 id 为 <code>paranamer</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下， <code>ParanamerParameterNameProvider</code> 从构建时添加到字节码的常量(通过  <code>DefaultParanamer</code> )和调试符号(通过 <code>BytecodeReadingParanamer</code> )中检索参数名。或者，您可以在创建 <code>ParanamerParameterNameProvider</code> 实例时指定所选择的 <code>Paranamer</code> 实现。</p>
</div>
</div>
<div class="sect2">
<h3 id="section-constraint-definition-contribution"><a class="anchor" href="#section-constraint-definition-contribution"></a>12.15. 提供约束定义</h3>
<div class="paragraph">
<p>Jakarta Bean Validation 允许(重新)通过 XML 在其约束映射文件中定义约束定义。有关更多信息，请参阅<a href="#section-mapping-xml-constraints">Section 8.2, &#8220;通过 <code>constraint-mappings</code> 映射约束&#8221;</a> ，并参阅<a href="#example-constraints-car">Example 96, &#8220;通过 XML 配置 Bean 约束&#8221;</a> 。虽然这种方法对于许多用例来说已经足够了，但是在其他用例中它还是有缺点的。例如，假设有一个约束库希望为自定义类型提供约束定义。这个库可以提供一个带有它们库的映射文件，但是这个文件仍然需要库的用户引用。幸运的是，还有更好的方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面的概念目前被认为是实验性的。让我们知道你是否认为他们有用，他们是否满足你的需要。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_通过_serviceloader_实现约束的定义"><a class="anchor" href="#_通过_serviceloader_实现约束的定义"></a>12.15.1. 通过 <code>ServiceLoader</code> 实现约束的定义</h4>
<div class="paragraph">
<p>Hibernate Validator 允许利用 Java 的
<a href="http://docs.oracle.com/javase/8/docs/api?java/util/ServiceLoader.html">ServiceLoader</a>
机制来注册附加的约束定义。您所要做的就是添加 <em>jakarta.validation.ConstraintValidator</em> 文件。到 <em>META-INF/services</em> 。在此服务文件中，列出约束验证器类的完全限定类名(每行一个)。Hibernate Validator 将自动推断它们应用于的约束类型。请通过<a href="#example-using-service-file-for-constraint-definitions">Constraint definition via service file</a> 查看约束定义的示例。</p>
</div>
<div id="example-using-service-file-for-constraint-definitions" class="exampleblock">
<div class="title">Example 155. <em>META-INF/services/jakarta.validation.ConstraintValidator</em></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code># Assuming a custom constraint annotation @org.mycompany.CheckCase
org.mycompany.CheckCaseValidator</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要为自定义约束贡献默认消息，请在 JAR 的根目录中放置一个文件 <em>ContributorValidationMessages.properties</em> 和/或其特定于区域设置的专门化。Hibernate Validator 将考虑除 <em>ValidationMessages.properties</em> 中给出的条目之外，在类路径中发现的所有绑定包中具有此名称的条目。</p>
</div>
<div class="paragraph">
<p>这种机制在创建大型多模块应用程序时也很有帮助: 您可以在每个模块中使用一个资源包，而不是将所有约束消息放到一个包中，而只包含该模块的那些消息。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>我们强烈推荐阅读 <a href="http://in.relation.to/2017/03/02/adding-custom-constraint-definitions-via-the-java-service-loader/">this blog post by Marko Bekhta</a> ，指导你一步一步地创建一个包含自定义约束并通过 <code>ServiceLoader</code> 声明它们的独立 JAR。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-programmatic-constraint-definition"><a class="anchor" href="#section-programmatic-constraint-definition"></a>12.15.2. 以编程方式添加约束定义</h4>
<div class="paragraph">
<p>虽然服务加载器方法可以在许多场景中工作，但并不适用于所有场景(例如，在服务文件不可见的 OSGi 中) ，但还有另一种贡献约束定义的方法。可以使用编程式约束声明 API ——请参见<a href="#example-using-constraint-definition-api">Example 156, &#8220;通过编程 API 添加约束定义&#8221;</a> 。</p>
</div>
<div id="example-using-constraint-definition-api" class="exampleblock">
<div class="title">Example 156. 通过编程 API 添加约束定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
		.constraintDefinition( ValidPassengerCount.class )
		.validatedBy( ValidPassengerCountValidator.class );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你的验证器实现相当简单(比如不需要注释的初始化，也不需要 <code>ConstraintValidatorContext</code> ) ，你也可以使用这个替代 API 来指定使用 Lambda 表达式或方法引用的约束逻辑:</p>
</div>
<div id="example-using-constraint-definition-api-lambda" class="exampleblock">
<div class="title">Example 157. 使用 Lambda 表达式添加约束定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
		.constraintDefinition( ValidPassengerCount.class )
			.validateType( Bus.class )
				.with( b -&gt; b.getSeatCount() &gt;= b.getPassengers().size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与直接向配置对象添加约束映射不同，您可以使用 <code>ConstraintMappingContributor</code> ，详见<a href="#section-programmatic-api-contributor">Section 12.5, &#8220;将程序化的约束声明应用到默认的验证器工厂&#8221;</a> 。这在使用 <em>META-INF/validation.xml</em> 配置默认验证器工厂时非常有用(参见<a href="#chapter-xml-configuration">Chapter 8, <em>通过 XML 配置</em></a>)。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通过编程 API 注册约束定义的一个用例是能够为 <code>@URL</code> 约束指定替代约束验证器。从历史上看，Hibernate Validator 针对此约束的默认约束验证器使用 <code>java.net.URL</code> 构造函数来验证 URL。然而，也有一个纯粹的基于正则表达式的版本，可以使用 <code>ConstraintDefinitionContributor</code> 进行配置:</p>
</div>
<div class="listingblock">
<div class="title">使用编程约束声明 API 注册基于正则表达式的约束定义 <code>@URL</code></div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
		.constraintDefinition( URL.class )
		.includeExistingValidators( false )
		.validatedBy( RegexpURLValidator.class );</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-constraint-customizing-class-loading"><a class="anchor" href="#section-constraint-customizing-class-loading"></a>12.16. 自定义类加载</h3>
<div class="paragraph">
<p>在以下几种情况下，Hibernate Validator 需要加载按名称给出的资源或类:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XML 描述符 (<em>META-INF/validation.xml</em> 以及 XML 约束映射)</p>
</li>
<li>
<p>在 XML 描述符中通过名称指定的类(例如自定义消息内插器等)</p>
</li>
<li>
<p><em>ValidationMessages</em> 资源包</p>
</li>
<li>
<p>用于基于表达式的消息插值的 <code>ExpressionFactory</code> 实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，Hibernate Validator 尝试通过当前线程上下文类加载器加载这些资源。如果不成功，Hibernate Validator 自己的类装入器将作为后备尝试。</p>
</div>
<div class="paragraph">
<p>对于这种策略不合适的情况(例如，模块化的环境，如 OSGi) ，你可以在启动验证器工厂时提供一个特定的类加载器来加载这些资源:</p>
</div>
<div id="example-using-external-class-loader" class="exampleblock">
<div class="title">Example 158. 提供一个类加载器来加载外部资源和类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.externalClassLoader( classLoader )
		.buildValidatorFactory()
		.getValidator();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在 OSGi 的情况下，你可以从绑定包引导 Hibernate Validator 中传递类的加载器，或者传递一个自定义类加载器实现到 <code>Bundle#loadClass()</code> 等等。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果不再需要给定的验证器工厂实例，则调用 <code>ValidatorFactory#close()</code> 。如果重新部署应用程序/捆绑包，并且应用程序代码仍然引用非关闭的验证程序工厂，则未能这样做可能会导致类装入器泄漏。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-getter-property-selection-strategy"><a class="anchor" href="#section-getter-property-selection-strategy"></a>12.17. 自定义 getter 属性选择策略</h3>
<div class="paragraph">
<p>当使用 Hibernate Validator 验证 bean 时，将验证其属性。属性既可以是字段，也可以是 getter。默认情况下，Hibernate Validator 尊重 javabean 规范，只要下面的条件之一是真实的，Hibernate Validator 就会考虑一个方法作为 getter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法名以 <code>get</code> 开头，具有非空返回类型且没有参数;</p>
</li>
<li>
<p>方法名以 <code>is</code> 开头，具有 <code>boolean</code> 的返回类型，且没有参数;</p>
</li>
<li>
<p>方法名以 <code>has</code> 开头，返回 <code>boolean</code> 类型，没有参数(这个规则是特定于 Hibernate Validator 的，javabean 规范没有强制要求)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然这些规则在遵循经典 JavaBeans 约定时通常是适当的，但是它可能会发生，特别是在代码生成器中，JavaBeans 变数命名原则不遵循，而 getter 的名称遵循不同的约定。</p>
</div>
<div class="paragraph">
<p>在这种情况下，应该重新定义检测 getter 的策略，以便完全验证对象。</p>
</div>
<div class="paragraph">
<p>这个需求的一个典型例子是当类遵循一个流畅的变数命名原则时，如<a href="#example-using-fluent-api-pattern">Example 159, &#8220;使用非标准 getter 的类&#8221;</a>。</p>
</div>
<div id="example-using-fluent-api-pattern" class="exampleblock">
<div class="title">Example 159. 使用非标准 getter 的类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.getterselectionstrategy;

public class User {

	private String firstName;
	private String lastName;
	private String email;

	// [...]

	@NotEmpty
	public String firstName() {
		return firstName;
	}

	@NotEmpty
	public String lastName() {
		return lastName;
	}

	@Email
	public String email() {
		return email;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果验证了这样的对象，则不会对 getter 执行验证，因为标准策略没有检测到它们。</p>
</div>
<div class="exampleblock">
<div class="title">Example 160. 使用默认 getter 属性选择策略验证具有非标准 getter 的类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.buildValidatorFactory()
		.getValidator();

User user = new User( "", "", "not an email" );

Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validate( user );

// as User has non-standard getters no violations are triggered
assertEquals( 0, constraintViolations.size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了让 Hibernate Validator 将这些方法视为属性，应该配置一个自定义的 <code>GetterPropertySelectionStrategy</code> 。在这种特殊情况下，可能执行的战略是:</p>
</div>
<div class="exampleblock">
<div class="title">Example 161. 自定义 <code>GetterPropertySelectionStrategy</code> 实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">package org.hibernate.validator.referenceguide.chapter12.getterselectionstrategy;

public class FluentGetterPropertySelectionStrategy implements GetterPropertySelectionStrategy {

	private final Set&lt;String&gt; methodNamesToIgnore;

	public FluentGetterPropertySelectionStrategy() {
		// we will ignore all the method names coming from Object
		this.methodNamesToIgnore = Arrays.stream( Object.class.getDeclaredMethods() )
				.map( Method::getName )
				.collect( Collectors.toSet() );
	}

	@Override
	public Optional&lt;String&gt; getProperty(ConstrainableExecutable executable) {
		if ( methodNamesToIgnore.contains( executable.getName() )
				|| executable.getReturnType() == void.class
				|| executable.getParameterTypes().length &gt; 0 ) {
			return Optional.empty();
		}

		return Optional.of( executable.getName() );
	}

	@Override
	public Set&lt;String&gt; getGetterMethodNameCandidates(String propertyName) {
		// As method name == property name, there always is just one possible name for a method
		return Collections.singleton( propertyName );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有多种方法可以配置 Hibernate Validator 来使用这个策略。它可以通过编程方式完成(参见<a href="#custom-getter-strategy-programmatically">Example 162, &#8220;以编程方式配置自定义 <code>GetterPropertySelectionStrategy</code>&#8221;</a> ) ，也可以在 XML 配置中使用 <code>hibernate.validator.getter_property_selection_strategy</code> 属性(参见<a href="#custom-getter-strategy-xml">Example 163, &#8220;使用 XML 属性配置自定义 <code>GetterPropertySelectionStrategy</code>&#8221;</a> )。</p>
</div>
<div id="custom-getter-strategy-programmatically" class="exampleblock">
<div class="title">Example 162. 以编程方式配置自定义 <code>GetterPropertySelectionStrategy</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		// Setting a custom getter property selection strategy
		.getterPropertySelectionStrategy( new FluentGetterPropertySelectionStrategy() )
		.buildValidatorFactory()
		.getValidator();

User user = new User( "", "", "not an email" );

Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validate( user );

assertEquals( 3, constraintViolations.size() );</code></pre>
</div>
</div>
</div>
</div>
<div id="custom-getter-strategy-xml" class="exampleblock">
<div class="title">Example 163. 使用 XML 属性配置自定义 <code>GetterPropertySelectionStrategy</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;validation-config
        xmlns="https://jakarta.ee/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/configuration
            https://jakarta.ee/xml/ns/validation/validation-configuration-3.0.xsd"
        version="3.0"&gt;

    &lt;property name="hibernate.validator.getter_property_selection_strategy"&gt;
        org.hibernate.validator.referenceguide.chapter12.getterselectionstrategy.NoPrefixGetterPropertySelectionStrategy
    &lt;/property&gt;

&lt;/validation-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用 <code>HibernateValidatorConfiguration#addMapping(ConstraintMapping)</code> 添加编程约束的情况下，添加映射应该始终在配置所需的 getter 属性选择策略之后进行。否则，默认策略将用于在定义策略之前添加的映射。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-property-node-name-provider"><a class="anchor" href="#section-property-node-name-provider"></a>12.18. 自定义违反约束的属性名解析</h3>
<div class="paragraph">
<p>假设我们有一个简单的数据类，在某些字段上有 <code>@NotNull</code> 约束:</p>
</div>
<div id="example-person-class" class="exampleblock">
<div class="title">Example 164. Person 数据类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public class Person {
	@NotNull
	@JsonProperty("first_name")
	private final String firstName;

	@JsonProperty("last_name")
	private final String lastName;

	public Person(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个类可以通过 <a href="https://github.com/FasterXML/jackson">Jackson</a> 库序列化到 JSON:</p>
</div>
<div id="example-person-object-to-json" class="exampleblock">
<div class="title">Example 165. 将 Person 对象序列化到 JSON</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public class PersonSerializationTest {
	private final ObjectMapper objectMapper = new ObjectMapper();

	@Test
	public void personIsSerialized() throws JsonProcessingException {
		Person person = new Person( "Clark", "Kent" );

		String serializedPerson = objectMapper.writeValueAsString( person );

		assertEquals( "{\"first_name\":\"Clark\",\"last_name\":\"Kent\"}", serializedPerson );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正如我们看到的，对象被序列化为:</p>
</div>
<div id="example-person-json" class="exampleblock">
<div class="title">Example 166. Person as json</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>{
  "first_name": "Clark",
  "last_name": "Kent"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意属性的名称是如何不同的。在 Java 对象中，我们有 <code>firstName</code>  和 <code>lastName</code> ，而在 JSON 输出中，我们有 <code>first_name</code> 和 <code>last_name</code> 。我们通过 <code>@JsonProperty</code> 注释定制了这种行为。</p>
</div>
<div class="paragraph">
<p>现在假设我们在 REST 环境中使用这个类，其中用户可以在请求体中以 JSON 的形式发送 <a href="#example-person-json">a <code>Person</code> instance as JSON</a> 。在指示验证失败的字段时，最好指出他们在 JSON 请求中使用的 <code>first_name</code> ，而不是我们在内部 Java 代码中使用的名称，<code>firstName</code> 。</p>
</div>
<div class="paragraph">
<p><code>org.hibernate.validator.spi.nodenameprovider.PropertyNodeNameProvider</code> 契约允许我们这样做。通过实现它，我们可以定义在验证期间如何解析属性的名称。在我们的示例中，我们希望从 Jackson 配置中读取值。</p>
</div>
<div class="paragraph">
<p>如何做到这一点的一个例子是利用 Jackson API:</p>
</div>
<div id="example-jackson-property-node-name-provider" class="exampleblock">
<div class="title">Example 167. JacksonPropertyNodeNameProvider 实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">import org.hibernate.validator.spi.nodenameprovider.JavaBeanProperty;
import org.hibernate.validator.spi.nodenameprovider.Property;
import org.hibernate.validator.spi.nodenameprovider.PropertyNodeNameProvider;

import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;

public class JacksonPropertyNodeNameProvider implements PropertyNodeNameProvider {
	private final ObjectMapper objectMapper = new ObjectMapper();

	@Override
	public String getName(Property property) {
		if ( property instanceof JavaBeanProperty ) {
			return getJavaBeanPropertyName( (JavaBeanProperty) property );
		}

		return getDefaultName( property );
	}

	private String getJavaBeanPropertyName(JavaBeanProperty property) {
		JavaType type = objectMapper.constructType( property.getDeclaringClass() );
		BeanDescription desc = objectMapper.getSerializationConfig().introspect( type );

		return desc.findProperties()
				.stream()
				.filter( prop -&gt; prop.getInternalName().equals( property.getName() ) )
				.map( BeanPropertyDefinition::getName )
				.findFirst()
				.orElse( property.getName() );
	}

	private String getDefaultName(Property property) {
		return property.getName();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在进行验证时:</p>
</div>
<div id="example-jackson-property-node-name-provider-field" class="exampleblock">
<div class="title">Example 168. JacksonPropertyNodeNameProvider 的使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">public class JacksonPropertyNodeNameProviderTest {
	@Test
	public void nameIsReadFromJacksonAnnotationOnField() {
		ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
				.configure()
				.propertyNodeNameProvider( new JacksonPropertyNodeNameProvider() )
				.buildValidatorFactory();

		Validator validator = validatorFactory.getValidator();

		Person clarkKent = new Person( null, "Kent" );

		Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate( clarkKent );
		ConstraintViolation&lt;Person&gt; violation = violations.iterator().next();

		assertEquals( violation.getPropertyPath().toString(), "first_name" );
	}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以看到属性路径现在返回 <code>first_name</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，当注释在 getter 上时，这也是可行的:</p>
</div>
<div id="example-jackson-property-node-name-provider-getter" class="exampleblock">
<div class="title">Example 169. getter 上的注释</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="JAVA">@Test
public void nameIsReadFromJacksonAnnotationOnGetter() {
	ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
			.configure()
			.propertyNodeNameProvider( new JacksonPropertyNodeNameProvider() )
			.buildValidatorFactory();

	Validator validator = validatorFactory.getValidator();

	Person clarkKent = new Person( null, "Kent" );

	Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate( clarkKent );
	ConstraintViolation&lt;Person&gt; violation = violations.iterator().next();

	assertEquals( violation.getPropertyPath().toString(), "first_name" );
}

public class Person {
	private final String firstName;

	@JsonProperty("last_name")
	private final String lastName;

	public Person(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	@NotNull
	@JsonProperty("first_name")
	public String getFirstName() {
		return firstName;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这只是我们为什么要更改属性名称解析方式的一个用例。</p>
</div>
<div class="paragraph">
<p><code>org.hibernate.validator.spi.nodenameprovider.PropertyNodeNameProvider</code> 以实现以您认为合适的任何方式提供属性名(例如，从注释中读取)。</p>
</div>
<div class="paragraph">
<p>还有两个界面值得一提:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.validator.spi.nodenameprovider.Property</code> 属性是保存有关属性的元数据的基接口。它只有一个 <code>String getName()</code> 方法，可用于获取属性的“original”名称。这个接口应该用作解析名称的默认方式(参见<a href="#example-jackson-property-node-name-provider">Example 167, &#8220;JacksonPropertyNodeNameProvider 实现&#8221;</a>中如何使用它)。</p>
</li>
<li>
<p><code>org.hibernate.validator.spi.nodenameprovider.JavaBeanProperty</code> 是一个接口，它包含有关 bean 属性的元数据。它扩展了 <code>org.hibernate.validator.spi.nodenameprovider.Property</code> 。属性，并提供一些附加方法，如 <code>Class&lt;?&gt; getDeclaringClass()</code> ，它返回属性所有者的类。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-annotation-processor"><a class="anchor" href="#validator-annotation-processor"></a>13. 注释处理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你有没有无意中做过一些事情，比如</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在不支持的数据类型上指定约束注释(例如用 <code>@Past</code> 注释一个 String)</p>
</li>
<li>
<p>注释 javabean 属性的 setter (而不是 getter 方法)</p>
</li>
<li>
<p>使用约束注释(不支持)注释静态字段/方法？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么 Hibernate Validator 注释处理器就是适合您的工具。通过插入构建过程并在约束注释使用不正确时引发编译错误，它有助于防止此类错误。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以在 <a href="http://sourceforge.net/projects/hibernate/files/hibernate-validator">Sourceforge</a> 或者 Maven Central 等常见的存储库 GAV <code>org.hibernate.validator:hibernate-validator-annotation-processor:7.0.1.Final</code> 中找到 Hibernate Validator Annotation Processor 作为发行包的一部分。决赛。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="validator-annotationprocessor-prerequisites"><a class="anchor" href="#validator-annotationprocessor-prerequisites"></a>13.1. 先决条件</h3>
<div class="paragraph">
<p>Hibernate Validator 注释处理器基于 <a href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a> 定义的“Pluggable Annotation Processing API ”， <a href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a> 是 Java 平台的一部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="validator-annotationprocessor-features"><a class="anchor" href="#validator-annotationprocessor-features"></a>13.2. 功能</h3>
<div class="paragraph">
<p>从 Hibernate Validator 7.0.1.Final 开始，Hibernate Validator 注释处理器检查如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>注释元素的类型允许使用约束注释</p>
</li>
<li>
<p>只有非静态字段或方法用约束注释注释</p>
</li>
<li>
<p>只有非基元字段或方法用 <code>@Valid</code> 注释</p>
</li>
<li>
<p>只有这些方法用约束注释注释，这些约束注释是有效的 javabean getter 方法(可选地，参见下面)</p>
</li>
<li>
<p>只有这样的注释类型用约束注释注释，这些约束注释本身就是约束注释</p>
</li>
<li>
<p>使用 <code>@GroupSequenceProvider</code> 定义动态默认组序列是有效的</p>
</li>
<li>
<p>注释参数值是有意义和有效的</p>
</li>
<li>
<p>继承层次结构中的方法参数约束尊重继承规则</p>
</li>
<li>
<p>方法在继承层次结构中返回值约束遵循继承规则</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="validator-annotationprocessor-options"><a class="anchor" href="#validator-annotationprocessor-options"></a>13.3. 选项</h3>
<div class="paragraph">
<p>Hibernate Validator Annotation Processor 的行为可以通过以下 <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html#BHCHACIB">processor options</a> 来控制:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>diagnosticKind</code></dt>
<dd>
<p>控制如何报告约束问题。必须是 enum <code>javax.tools.Diagnostic.Kind</code> 中某个值的字符串表示形式。例如 <code>WARNING</code> 。每当 AP 检测到约束问题时，<code>ERROR</code> 值将导致编译停止。默认为 <code>ERROR</code> 。</p>
</dd>
<dt class="hdlist1"><code>methodConstraintsSupported</code></dt>
<dd>
<p>控制在任何类型的方法中是否允许约束。使用 Hibernate Validator 支持的方法级别约束时，必须将其设置为 <code>true</code> 。可以将其设置为 <code>false</code> ，以便只允许在由 Jakarta Bean Validation API 定义的 javabean getter 方法中存在约束。默认为 <code>true</code> 。</p>
</dd>
<dt class="hdlist1"><code>verbose</code></dt>
<dd>
<p>控制是否显示详细的处理信息，这对调试有用。一定是 <code>true</code> 的或 <code>false</code> 的。默认为 <code>false</code>。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="validator-annotationprocessor-usage"><a class="anchor" href="#validator-annotationprocessor-usage"></a>13.4. 使用注释处理器</h3>
<div class="paragraph">
<p>本节详细说明如何将 Hibernate Validator 注释处理器集成到命令行构建(Maven、 Ant、 javac)以及基于 IDE 的构建(Eclipse、 IntelliJ IDEA、 NetBeans)中。</p>
</div>
<div class="sect3">
<h4 id="validator-annotationprocessor-commandline"><a class="anchor" href="#validator-annotationprocessor-commandline"></a>13.4.1. 命令行构建</h4>
<div class="sect4">
<h5 id="validator-annotationprocessor-maven"><a class="anchor" href="#validator-annotationprocessor-maven"></a>13.4.1.1. Maven</h5>
<div class="paragraph">
<p>对于 Maven 使用 Hibernate Validator 注释处理器，可以通过 <code>annotationProcessorPaths</code> 选项设置如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 170. 在 Maven 中使用 Hibernate Validator 注释处理器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;project&gt;
    [...]
    &lt;build&gt;
        [...]
        &lt;plugins&gt;
            [...]
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.6.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;annotationProcessorPaths&gt;
                        &lt;path&gt;
                            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
                            &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;
                            &lt;version&gt;7.0.1.Final&lt;/version&gt;
                        &lt;/path&gt;
                    &lt;/annotationProcessorPaths&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            [...]
        &lt;/plugins&gt;
        [...]
    &lt;/build&gt;
    [...]
&lt;/project&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validator-annotationprocessor-gradle"><a class="anchor" href="#validator-annotationprocessor-gradle"></a>13.4.1.2. Gradle</h5>
<div class="paragraph">
<p>当使用 <a href="https://gradle.org">Gradle</a> 时，将注释处理器作为一个 <code>annotationProcessor</code> 依赖项引用就足够了。</p>
</div>
<div class="exampleblock">
<div class="title">Example 171. 使用 Gradle 的注释处理器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="groovy">dependencies {
	annotationProcessor group: 'org.hibernate.validator', name: 'hibernate-validator-annotation-processor', version: '7.0.1.Final'

	// any other dependencies ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validator-annotationprocessor-ant"><a class="anchor" href="#validator-annotationprocessor-ant"></a>13.4.1.3. Apache Ant</h5>
<div class="paragraph">
<p>与直接使用 javac 类似，在调用 <a href="http://ant.apache.org/">Apache Ant</a> 的  <a href="http://ant.apache.org/manual/CoreTasks/javac.html">javac task</a> ，可以将注释处理器作为编译器参数添加:</p>
</div>
<div class="exampleblock">
<div class="title">Example 172. 使用 Ant 的注释处理器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="XML">&lt;javac srcdir="src/main"
       destdir="build/classes"
       classpath="/path/to/validation-api-3.0.0.jar"&gt;
       &lt;compilerarg value="-processorpath" /&gt;
       &lt;compilerarg value="/path/to/hibernate-validator-annotation-processor-7.0.1.Final.jar"/&gt;
&lt;/javac&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validator-annotationprocessor-javac"><a class="anchor" href="#validator-annotationprocessor-javac"></a>13.4.1.4. javac</h5>
<div class="paragraph">
<p>在命令行上使用 <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/javac/index.html">javac</a> 进行编译时，使用“ processorpath”选项指定 JAR <em>hibernate-validator-annotation-processor-7.0.1.Final.jar</em> ，如下面的清单所示。编译器将自动检测处理器并在编译期间调用它。</p>
</div>
<div class="exampleblock">
<div class="title">Example 173. 使用带 javac 的注释处理器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>javac src/main/java/org/hibernate/validator/ap/demo/Car.java \
   -cp /path/to/validation-api-3.0.0.jar \
   -processorpath /path/to/hibernate-validator-annotation-processor-7.0.1.Final.jar</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validator-annotationprocessor-ide"><a class="anchor" href="#validator-annotationprocessor-ide"></a>13.4.2. IDE builds</h4>
<div class="sect4">
<h5 id="_eclipse"><a class="anchor" href="#_eclipse"></a>13.4.2.1. Eclipse</h5>
<div class="paragraph">
<p>如果您已经安装了 <a href="https://www.eclipse.org/m2e/">M2E Eclipse plug-in</a> 插件，那么将为上述配置的 Maven 项目自动设置注释处理器。</p>
</div>
<div class="paragraph">
<p>对于普通的 Eclipse 项目，按照以下步骤设置注释处理器:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>右键单击项目，选择 "Properties"</p>
</li>
<li>
<p>进入「"Java Compiler"  ，确保 "Compiler compliance level" 设定为  "1.8" 。否则处理器将不会被激活</p>
</li>
<li>
<p>进入 "Java Compiler - Annotation Processing" 并选择 "Enable annotation processing"</p>
</li>
<li>
<p>转到 "Java Compiler - Annotation Processing - Factory Path" ，添加 JAR
hibernate-validator-annotation-processor-7.0.1.Final.jar</p>
</li>
<li>
<p>确认 the workspace rebuild</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，您应该可以在编辑器和 "Problem" 视图中看到任何注释问题，它们都是常规的错误标记:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="annotation_processor_eclipse.png" alt="annotation processor eclipse">
</div>
</div>
</div>
<div class="sect4">
<h5 id="validator-annotationprocessor-idea"><a class="anchor" href="#validator-annotationprocessor-idea"></a>13.4.2.2. IntelliJ IDEA</h5>
<div class="paragraph">
<p>使用 <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> (9及以上版本)中的注释处理器必须遵循以下步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Go to "File", then "Settings",</p>
</li>
<li>
<p>Expand the node "Compiler", then "Annotation Processors"</p>
</li>
<li>
<p>Choose "Enable annotation processing" and enter the following as "Processor path":
/path/to/hibernate-validator-annotation-processor-7.0.1.Final.jar</p>
</li>
<li>
<p>Add the processor&#8217;s fully qualified name org.hibernate.validator.ap.ConstraintValidationProcessor
to the "Annotation Processors" list</p>
</li>
<li>
<p>If applicable add you module to the "Processed Modules" list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Rebuilding your project then should show any erroneous constraint annotations:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="annotation_processor_intellij.png" alt="annotation processor intellij">
</div>
</div>
</div>
<div class="sect4">
<h5 id="validator-annotationprocessor-netbeans"><a class="anchor" href="#validator-annotationprocessor-netbeans"></a>13.4.2.3. NetBeans</h5>
<div class="paragraph">
<p>The <a href="http://www.netbeans.org/">NetBeans</a> IDE supports using
annotation processors within the IDE build. To do so, do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Right-click your project, choose "Properties"</p>
</li>
<li>
<p>Go to "Libraries", tab "Processor", and add the JAR hibernate-validator-annotation-processor-7.0.1.Final.jar</p>
</li>
<li>
<p>Go to "Build - Compiling", select "Enable Annotation Processing" and "Enable Annotation Processing
in Editor". Add the annotation processor by specifying its fully qualified name
org.hibernate.validator.ap.ConstraintValidationProcessor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any constraint annotation problems will then be marked directly within the editor:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="annotation_processor_netbeans.png" alt="annotation processor netbeans">
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="validator-annotationprocessor-known-issues"><a class="anchor" href="#validator-annotationprocessor-known-issues"></a>13.5. Known issues</h3>
<div class="paragraph">
<p>The following known issues exist as of July 2017:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Container element constraints are not supported for now.</p>
</li>
<li>
<p>Constraints applied to a container but in reality applied to the container elements (be it via
the <code>Unwrapping.Unwrap</code> payload or via a value extractor marked with <code>@UnwrapByDefault</code>) are not supported
correctly.</p>
</li>
<li>
<p><a href="https://hibernate.atlassian.net/browse/HV-308">HV-308</a>: Additional validators
registered for a constraint
<a href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#chapter-xml-configuration">using XML</a> are
not evaluated by the annotation processor.</p>
</li>
<li>
<p>Sometimes custom constraints can&#8217;t be
<a href="https://hibernate.atlassian.net/browse/HV-293">properly evaluated</a> when
using the processor within Eclipse. Cleaning the project can help in these situations. This seems to
be an issue with the Eclipse JSR 269 API implementation, but further investigation is required here.</p>
</li>
<li>
<p>When using the processor within Eclipse, the check of dynamic default group sequence definitions
doesn&#8217;t work. After further investigation, it seems to be an issue with the Eclipse JSR 269 API
implementation.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validator-further-reading"><a class="anchor" href="#validator-further-reading"></a>14. 进一步阅读</h2>
<div class="sectionbody">
<div class="paragraph">
<p>最后但并非最不重要的是，一些关于进一步阅读的渠道。</p>
</div>
<div class="paragraph">
<p>示例的一个很好的来源是 Jakarta Bean Validation TCK，它可以在 <a href="https://github.com/beanvalidation/beanvalidation-tck/">GitHub</a> 上进行匿名访问。特别是 TCK 的 <a href="https://github.com/beanvalidation/beanvalidation-tck/tree/master/tests">tests</a> 可能会引起人们的兴趣。 <a href="http://beanvalidation.org/2.0/spec/">The Jakarta Bean Validation</a> 规范本身也是加深您对 Jakarta Bean Validation和 Hibernate Validator 的理解的一个很好的方法。</p>
</div>
<div class="paragraph">
<p>如果你对 Hibernate Validator 有任何进一步的问题，或者想要分享你的一些用例，可以看看 <a href="http://community.jboss.org/en/hibernate/validator">Hibernate Validator
Wiki</a> ，https://discourse.hibernate.org/c/hibernate-validator[Hibernate Validator Forum] 和 <a href="https://stackoverflow.com/questions/tagged/hibernate-validator">Hibernate Validator tag on Stack Overflow</a> 。</p>
</div>
<div class="paragraph">
<p>如果您想报告一个 bug，请使用 <a href="https://hibernate.atlassian.net/projects/HV/">Hibernate&#8217;s Jira</a> 。欢迎反馈！</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-04 16:31:38 +0800
</div>
</div>
<script src="./assets/run_prettify.min.js"></script>
<script>
    prettyPrint()
</script>
<script src="./assets/tocbot.min.js"></script>
<script>
    /* Tocbot dynamic TOC, works with tocbot 3.0.2 */
    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({
        contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4',
        smoothScroll: false
    });
    var handleTocOnResize = function() {
        var width = window.innerWidth ||
            document.documentElement.clientWidth ||
            document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({
                contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false
            });
        } else {
            tocbot.refresh({
                contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4',
                smoothScroll: false
            });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();
</script>
</body>
</html>