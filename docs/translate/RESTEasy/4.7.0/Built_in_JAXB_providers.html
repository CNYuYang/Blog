<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 22 章 JAXB providers</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="home" href="index.html" title="RESTEasy JAX-RS"/><link rel="up" href="index.html" title="RESTEasy JAX-RS"/><link rel="prev" href="Content_Marshalling_Providers.html" title="第 21 章 Content Marshalling/Providers"/><link rel="next" href="Atom.html" title="第 23 章 RESTEasy Atom Support"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="Content_Marshalling_Providers.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="Atom.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="Built_in_JAXB_providers"/>第 22 章 JAXB providers</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#decorators">22.1. JAXB Decorators</a></span></dt><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#Pluggable_JAXBContext_s_with_ContextResolvers">22.2. Pluggable JAXBContext's with ContextResolvers</a></span></dt><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#JAXB_+_XML_provider">22.3. JAXB + XML provider</a></span></dt><dd><dl><dt><span class="sect2"><a href="Built_in_JAXB_providers.html#XmlHeader">22.3.1. @XmlHeader and @Stylesheet</a></span></dt></dl></dd><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#JAXB_+_JSON_provider">22.4. JAXB + JSON provider</a></span></dt><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#JAXB_+_FastinfoSet_provider">22.5. JAXB + FastinfoSet provider</a></span></dt><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#JAXB_Collections">22.6. Arrays and Collections of JAXB Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="Built_in_JAXB_providers.html#collections_on_client">22.6.1. Retrieving Collections on the client side</a></span></dt><dt><span class="sect2"><a href="Built_in_JAXB_providers.html#json_list">22.6.2. JSON and JAXB Collections/arrays</a></span></dt></dl></dd><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#JAXB_Map">22.7. Maps of JAXB Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="Built_in_JAXB_providers.html#maps_client_side">22.7.1. Retrieving Maps on the client side</a></span></dt><dt><span class="sect2"><a href="Built_in_JAXB_providers.html#json_map">22.7.2. JSON and JAXB maps</a></span></dt></dl></dd><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#JAXB_INTERFACES">22.8. Interfaces, Abstract Classes, and JAXB</a></span></dt><dt><span class="sect1"><a href="Built_in_JAXB_providers.html#configuration">22.9. Configurating JAXB Marshalling</a></span></dt></dl></div>
   

   <p>
      As required by the specification, RESTEasy JAX-RS includes support for (un)marshalling JAXB annotated classes.
      RESTEasy provides multiple JAXB Providers to address some subtle differences between classes generated by XJC
      and classes which are simply annotated with @XmlRootElement, or working with JAXBElement classes directly.
   </p>
   <p>

      For the most part, developers using the JAX-RS API, the selection of which provider is invoked will be
      completely transparent. For developers wishing to access the providers directly (which most folks won't need to
      do), this document describes which provider is best suited for different configurations.
   </p>
   <p>
      A JAXB Provider is selected by RESTEasy when a parameter or return type is an object that is annotated with
      JAXB annotations (such as @XmlRootEntity or @XmlType) or if the type is a JAXBElement. Additionally, the
      resource class or resource method will be annotated with either a @Consumes or @Produces annotation and
      contain one or more of the following values:
   </p>
   <p>

      </p><div class="itemizedlist"><ul><li>
            text/*+xml
         </li><li>
            application/*+xml
         </li><li>
            application/*+fastinfoset
         </li><li>
            application/*+json
         </li></ul></div><p>

   </p>
   <p>

   </p>
   <p>

      RESTEasy will select a different provider based on the return type or parameter type used in the resource. This
      section describes how the selection process works.
   </p>
   <p>

      @XmlRootEntity
      When a class is annotated with a @XmlRootElement annotation, RESTEasy will select the
      JAXBXmlRootElementProvider. This provider handles basic marshaling and unmarshalling of custom JAXB
      entities.
   </p>
   <p>

      @XmlType
      Classes which have been generated by XJC will most likely not contain an @XmlRootEntity annotation. In order
      for these classes to marshalled, they must be wrapped within a JAXBElement instance. This is typically
      accomplished by invoking a method on the class which serves as the XmlRegistry and is named ObjectFactory.
   </p>
   <p>

      The JAXBXmlTypeProvider provider is selected when the class is annotated with an XmlType annotation and not an
      XmlRootElement annotation.
   </p>
   <p>

      This provider simplifies this task by attempting to locate the XmlRegistry for the target class. By default, a
      JAXB implementation will create a class called ObjectFactory and is located in the same package as the target
      class. When this class is located, it will contain a "create" method that takes the object instance
      as a parameter. For example, if the target type is called "Contact", then the ObjectFactory class
      will have a method:
   </p>
   <p>

      public JAXBElement createContact(Contact value) {..
   </p>
   <p>

      JAXBElement&lt;?&gt;
      If your resource works with the JAXBElement class directly, the RESTEasy runtime will select the
      JAXBElementProvider. This provider examines the ParameterizedType value of the JAXBElement in order to select
      the appropriate JAXBContext.
   </p>
   <p>

   </p>
   <p>


   </p>
    <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="decorators"/>22.1. JAXB Decorators</h2></div></div></div>
        
        <p>Resteasy's JAXB providers have a pluggable way to decorate Marshaller and Unmarshaller instances.
        The way it works is that you can write an annotation that can trigger the decoration of a
        Marshaller or Unmarshaller.  Your decorators can do things like set Marshaller or Unmarshaller properties,
        set up validation, stuff like that.  Here's an example.  Let's say we want to have an annotation
        that will trigger pretty-printing, nice formatting, of an XML document.  If we were doing raw
        JAXB, we would set a property on the Marshaller of Marshaller.JAXB_FORMATTED_OUTPUT.  Let's
        write a Marshaller decorator.</p>
        <p>First we define a annotation:</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.jboss.resteasy.annotations.Decorator;

@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Decorator(processor = PrettyProcessor.class, target = Marshaller.class)
public @interface Pretty {}
</pre>
        <p>To get this to work, we must annotate our @Pretty annotation with a meta-annotation called
        @Decorator.  The target() attribute must be the JAXB Marshaller class.  The processor()
        attribute is a class we will write next.</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.jboss.resteasy.core.interception.DecoratorProcessor;
import org.jboss.resteasy.annotations.DecorateTypes;

import javax.xml.bind.Marshaller;
import javax.xml.bind.PropertyException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.Produces;
import java.lang.annotation.Annotation;

/**
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
@DecorateTypes({"text/*+xml", "application/*+xml"})
public class PrettyProcessor implements DecoratorProcessor&lt;Marshaller, Pretty&gt;
{
    public Marshaller decorate(Marshaller target, Pretty annotation,
                  Class type, Annotation[] annotations, MediaType mediaType)
    {
       target.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
    }
}
</pre>
    <p>
        The processor implementation must implement the DecoratorProcessor interface and should also be annotated
        with @DecorateTypes.  This annotation specifies what media types the processor can be used with. Now that
        we've defined our annotation and our Processor, we can use it on our JAX-RS resource methods
        or JAXB types as follows:
    </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@GET
@Pretty
@Produces("application/xml")
public SomeJAXBObject get() {...}
</pre>
        <p>If you are confused, check the RESTEasy source code for the implementation of @XmlHeader</p>
    </div>
   <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="Pluggable_JAXBContext_s_with_ContextResolvers"/>22.2. Pluggable JAXBContext's with ContextResolvers</h2></div></div></div>
      

      <p>

         You should not use this feature unless you know what you're doing.
      </p>
      <p>

         Based on the class you are marshalling/unmarshalling, RESTEasy will, by default create and cache JAXBContext
         instances per class type. If you do not want RESTEasy to create JAXBContexts, you can plug-in your own by
         implementing an instance of javax.ws.rs.ext.ContextResolver
      </p>
      <p>

</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
public interface ContextResolver&lt;T&gt;
{
    T getContext(Class&lt;?&gt; type);
}

@Provider
@Produces("application/xml")
public class MyJAXBContextResolver implements ContextResolver&lt;JAXBContext&gt;
{
    JAXBContext getContext(Class&lt;?&gt; type)
    {
        if (type.equals(WhateverClassIsOverridedFor.class)) return JAXBContext.newInstance()...;
    }
}
</pre><p>
      </p>
      <p>

         You must provide a @Produces annotation to specify the media type the context is meant for. You must also
         make sure to implement ContextResolver&lt;JAXBContext&gt;. This helps the runtime match to the correct
         context resolver. You must also annotate the ContextResolver class with @Provider.
      </p>
      <p>

         There are multiple ways to make this ContextResolver available.
      </p>
      <p>

         </p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>
               Return it as a class or instance from a javax.ws.rs.core.Application implementation
            </li><li>
               List it as a provider with resteasy.providers
            </li><li>
               Let RESTEasy automatically scan for it within your WAR file. See Configuration Guide
            </li><li>
               Manually add it via ResteasyProviderFactory.getInstance().registerProvider(Class) or
               registerProviderInstance(Object)
            </li></ol></div><p>

      </p>
      <p>


      </p>
   </div>
   <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_+_XML_provider"/>22.3. JAXB + XML provider</h2></div></div></div>
      
       <p>
           RESTEasy is required to provide JAXB provider support for XML.  It has a few extra annotations
           that can help code your app.
       </p>
       <div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="XmlHeader"/>22.3.1. @XmlHeader and @Stylesheet</h3></div></div></div>
           
           <p>Sometimes when outputting XML documents you may want to set an XML header. RESTEasy provides
           the @org.jboss.resteasy.annotations.providers.jaxb.XmlHeader annotation for this.  For example:</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement
public static class Thing
{
    private String name;

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}

@Path("/test")
public static class TestService
{
    @GET
    @Path("/header")
    @Produces("application/xml")
    @XmlHeader("&lt;?xml-stylesheet type='text/xsl' href='${baseuri}foo.xsl' ?&gt;")
    public Thing get()
    {
        Thing thing = new Thing();
        thing.setName("bill");
        return thing;
    }
}
</pre>
           <p>
               The @XmlHeader here forces the XML output to have an xml-stylesheet header.  This header
               could also have been put on the Thing class to get the same result.  See the javadocs for more
               details on how you can use substitution values provided by resteasy.
               </p>
           <p>
               RESTEasy also has a convenience annotation for stylesheet headers.  For example:
           </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement
public static class Thing
{
    private String name;

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}

@Path("/test")
public static class TestService
{
    @GET
    @Path("/stylesheet")
    @Produces("application/xml")
    @Stylesheet(type="text/css", href="${basepath}foo.xsl")
    @Junk
    public Thing getStyle()
    {
        Thing thing = new Thing();
        thing.setName("bill");
        return thing;
    }
}
</pre>
       </div>
   </div>
   <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_+_JSON_provider"/>22.4. JAXB + JSON provider</h2></div></div></div>
      

      <p>
         RESTEasy allows you to marshall JAXB annotated POJOs to and from JSON. This provider wraps the Jackson2 library to accomplish this.
      </p>
      <p>
           To use this integration with Jackson you need to import the resteasy-jackson2-provider Maven module.
       </p>
      <p>
         For example, consider this JAXB class:
      </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement(name = "book")
public class Book
{
    private String author;
    private String ISBN;
    private String title;

    public Book()
    {
    }

    public Book(String author, String ISBN, String title)
    {
        this.author = author;
        this.ISBN = ISBN;
        this.title = title;
    }

    @XmlElement
    public String getAuthor()
    {
        return author;
    }

    public void setAuthor(String author)
    {
    this.author = author;
    }

    @XmlElement
    public String getISBN()
    {
        return ISBN;
    }

    public void setISBN(String ISBN)
    {
        this.ISBN = ISBN;
    }

    @XmlAttribute
    public String getTitle()
    {
        return title;
    }

    public void setTitle(String title)
    {
        this.title = title;
    }
}
</pre>
       <p>
           And we can write a method to use the above entity:
       </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Path("/test_json")
@GET
@Produces(MediaType.APPLICATION_JSON)
public Book test_json() {
    Book book = new Book();
    book.setTitle("EJB 3.0");
    book.setAuthor("Bill Burke");
    book.setISBN("596529260");
    return book;
}
</pre>
       <p>
           Requesting from the above method, and we can see the default Jackson2 marshaller would return JSON that looked like this:
       </p>
       <p>
</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
$ http localhost:8080/dummy/test_json
HTTP/1.1 200
...
Content-Type: application/json

{
"ISBN": "596529260",
"author": "Bill Burke",
"title": "EJB 3.0"
}</pre><p>
       </p>
   </div>
   <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_+_FastinfoSet_provider"/>22.5. JAXB + FastinfoSet provider</h2></div></div></div>
      

      <p>

         RESTEasy supports the FastinfoSet mime type with JAXB annotated classes. Fast infoset documents are faster
         to serialize and parse, and smaller in size, than logically equivalent XML documents. Thus, fast infoset
         documents may be used whenever the size and processing time of XML documents is an issue. It is configured
         the same way the XML JAXB provider is so really no other documentation is needed here.
      </p>
       <p>
           To use this integration with Fastinfoset you need to import the resteasy-fastinfoset-provider Maven module.  Older versions
           of RESTEasy used to include this within the resteasy-jaxb-provider but we decided to modularize it more.
       </p>
      <p>


      </p>
   </div>
   <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_Collections"/>22.6. Arrays and Collections of JAXB Objects</h2></div></div></div>
      
      <p>
         RESTEasy will automatically
         marshal arrays, java.util.Set's, and java.util.List's of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
      </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement(name = "customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer
{
    @XmlElement
    private String name;

    public Customer()
    {
    }

    public Customer(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }
}

@Path("/")
public class MyResource
{
    @PUT
    @Path("array")
    @Consumes("application/xml")
    public void putCustomers(Customer[] customers)
    {
        Assert.assertEquals("bill", customers[0].getName());
        Assert.assertEquals("monica", customers[1].getName());
    }

    @GET
    @Path("set")
    @Produces("application/xml")
    public Set&lt;Customer&gt; getCustomerSet()
    {
        HashSet&lt;Customer&gt; set = new HashSet&lt;Customer&gt;();
        set.add(new Customer("bill"));
        set.add(new Customer("monica"));

        return set;
    }

    @PUT
    @Path("list")
    @Consumes("application/xml")
    public void putCustomers(List&lt;Customer&gt; customers)
    {
        Assert.assertEquals("bill", customers.get(0).getName());
        Assert.assertEquals("monica", customers.get(1).getName());
    }
}
</pre>
   <p>
      The above resource can publish and receive JAXB objects.  It is assumed that are wrapped in a collection element
   </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;collection&gt;
    &lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
    &lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
&lt;collection&gt;
</pre>
   <p>You can change the namespace URI, namespace tag, and collection element name by using the @org.jboss.resteasy.annotations.providers.jaxb.Wrapped annotation on a parameter or method</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Wrapped
{
    String element() default "collection";

    String namespace() default "http://jboss.org/resteasy";

    String prefix() default "resteasy";
}
</pre>
<p>So, if we wanted to output this XML</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;foo:list xmlns:foo="http://foo.org"&gt;
    &lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
    &lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
&lt;/foo:list&gt;
</pre>
<p>We would use the @Wrapped annotation as follows: </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@GET
@Path("list")
@Produces("application/xml")
@Wrapped(element="list", namespace="http://foo.org", prefix="foo")
public List&lt;Customer&gt; getCustomerSet()
{
    List&lt;Customer&gt; list = new ArrayList&lt;Customer&gt;();
    list.add(new Customer("bill"));
    list.add(new Customer("monica"));

    return list;
}
</pre>

  <div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="collections_on_client"/>22.6.1. Retrieving Collections on the client side</h3></div></div></div>
  
  <p>
  If you try to retrieve a <code class="classname">List</code>
  or <code class="classname">Set</code> of JAXB objects in the obvious way on the client side:
  </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
      Response response = request.get();
      List&lt;Customer&gt; list = response.readEntity(List.class);
</pre>

  <p>
  the call to <code class="methodname">readEntity()</code> will fail because it has no way of knowing the
  element type <code class="classname">Customer</code>. The trick is to use an instance of
  <code class="classname">javax.ws.rs.core.GenericType</code>:
  </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
      Response response = request.get();
      GenericType&lt;List&lt;Customer&gt;&gt; genericType = new GenericType&lt;List&lt;Customer&gt;&gt;() {};
      List&lt;Customer&gt; list = response.readEntity(genericType);
</pre>

  <p>
  For more information about <code class="classname">GenericType</code>, please see its javadoc.
  </p>

  <p>
  The same trick applies to retrieving a <code class="classname">Set</code>:
  </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
      Response response = request.get();
      GenericType&lt;Set&lt;Customer&gt;&gt; genericType = new GenericType&lt;Set&lt;Customer&gt;&gt;() {};
      Set&lt;Customer&gt; set = response.readEntity(genericType);
</pre>

  <p>
  On the other hand, <code class="classname">GenericType</code> is not necessary to retrieve an array of JAXB objects:
  </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
      Response response = request.get();
      Customer[] array = response.readEntity(Customer[].class);
</pre>
  </div>

  <div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="json_list"/>22.6.2. JSON and JAXB Collections/arrays</h3></div></div></div>
    
    <p>RESTEasy supports using collections with JSON.  It encloses lists, sets, or arrays of returned JAXB objects within a simple
    JSON array.  For example:</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
    @XmlAttribute
    private String test;

    public Foo()
    {
    }

    public Foo(String test)
    {
        this.test = test;
    }

    public String getTest()
    {
        return test;
    }

    public void setTest(String test)
    {
        this.test = test;
    }
}
</pre>
 <p>This a List or array of this Foo class would be represented in JSON like this:</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
[{"foo":{"@test":"bill"}},{"foo":{"@test":"monica}"}}]
</pre>
 <p>It also expects this format for input</p>
  </div>
</div>
   <div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_Map"/>22.7. Maps of JAXB Objects</h2></div></div></div>
      
      <p>
         RESTEasy will automatically
         marshal maps of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
         Your parameter or method return type must be a generic with a String as the key and the JAXB object's type.
     </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement(namespace = "http://foo.com")
public static class Foo
{
    @XmlAttribute
    private String name;

    public Foo()
    {
    }

    public Foo(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }
}

@Path("/map")
public static class MyResource
{
    @POST
    @Produces("application/xml")
    @Consumes("application/xml")
    public Map&lt;String, Foo&gt; post(Map&lt;String, Foo&gt; map)
    {
        Assert.assertEquals(2, map.size());
        Assert.assertNotNull(map.get("bill"));
        Assert.assertNotNull(map.get("monica"));
        Assert.assertEquals(map.get("bill").getName(), "bill");
        Assert.assertEquals(map.get("monica").getName(), "monica");
        return map;
    }
}
</pre>
   <p>
      The above resource can publish and receive JAXB objects within a map.  By default, they are wrapped in a "map" element in the
      default namespace.  Also, each "map" element has zero or more "entry" elements with a "key" attribute.
   </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;map&gt;
    &lt;entry key="bill" xmlns="http://foo.com"&gt;
        &lt;foo name="bill"/&gt;
    &lt;/entry&gt;
    &lt;entry key="monica" xmlns="http://foo.com"&gt;
        &lt;foo name="monica"/&gt;
    &lt;/entry&gt;
&lt;/map&gt;
</pre>
   <p>You can change the namespace URI, namespace prefix and map, entry, and key element and attribute names by using the @org.jboss.resteasy.annotations.providers.jaxb.WrappedMap annotation on a parameter or method</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface WrappedMap
{
    /**
     * map element name
     */
    String map() default "map";

    /**
     * entry element name *
     */
    String entry() default "entry";

    /**
     * entry's key attribute name
     */
    String key() default "key";

    String namespace() default "";

    String prefix() default "";
}
</pre>
<p>So, if we wanted to output this XML</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;hashmap&gt;
    &lt;hashentry hashkey="bill" xmlns:foo="http://foo.com"&gt;
        &lt;foo:foo name="bill"/&gt;
    &lt;/hashentry&gt;
&lt;/map&gt;
</pre>
<p>We would use the @WrappedMap annotation as follows: </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Path("/map")
public static class MyResource
{
    @GET
    @Produces("application/xml")
    @WrappedMap(map="hashmap", entry="hashentry", key="hashkey")
    public Map&lt;String, Foo&gt; get()
    {
        ...
        return map;
    }
}
</pre>

  <div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="maps_client_side"/>22.7.1. Retrieving Maps on the client side</h3></div></div></div>
  
  <p>
  If you try to retrieve a <code class="classname">Map</code>
  of JAXB objects in the obvious way on the client side:
  </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
      Response response = request.get();
      Map&lt;String, Customer&gt; map = response.readEntity(Map.class);
</pre>

  <p>
  the call to <code class="methodname">readEntity()</code> will fail because it has no way of knowing the
  element type <code class="classname">Customer</code>. The trick is to use an instance of
  <code class="classname">javax.ws.rs.core.GenericType</code>:
  </p>

<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
      Response response = request.get();
      GenericType&lt;Map&lt;String, Customer&gt; genericType = new GenericType&lt;Map&lt;String, Customer&gt;&gt;() {};
      Map&lt;String, Customer&gt; map = response.readEntity(genericType);
</pre>

  <p>
  For more information about <code class="classname">GenericType</code>, please see its javadoc.
  </p>
  </div>

  <div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="json_map"/>22.7.2. JSON and JAXB maps</h3></div></div></div>
    
    <p>RESTEasy supports using maps with JSON.  It encloses maps returned JAXB objects within a simple
    JSON map.  For example:</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
    @XmlAttribute
    private String test;

    public Foo()
    {
    }

    public Foo(String test)
    {
        this.test = test;
    }

    public String getTest()
    {
        return test;
    }

    public void setTest(String test)
    {
        this.test = test;
    }
}
</pre>
 <p>This a List or array of this Foo class would be represented in JSON like this:</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
{ "entry1" : {"foo":{"@test":"bill"}}, "entry2" : {"foo":{"@test":"monica}"}}}
</pre>
 <p>It also expects this format for input</p>
  </div>
</div>
<div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_INTERFACES"/>22.8. Interfaces, Abstract Classes, and JAXB</h2></div></div></div>
   
   <p>
    Some objects models use abstract classes and interfaces heavily.  Unfortunately, JAXB doesn't work with interfaces
    that are root elements and RESTEasy can't unmarshal parameters that are interfaces or raw abstract classes because
    it doesn't have enough information to create a JAXBContext.  For example:
   </p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
public interface IFoo {}

@XmlRootElement
public class RealFoo implements IFoo {}

@Path("/jaxb")
public class MyResource {

    @PUT
    @Consumes("application/xml")
    public void put(IFoo foo) {...}
}
</pre>
<p>
  In this example, you would get an error from RESTEasy of something like "Cannot find a MessageBodyReader for...".  This is because
  RESTEasy does not know that implementations of IFoo are JAXB classes and doesn't know how to create a JAXBContext for it.  As a workaround,
 RESTEasy allows you to use the JAXB annotation @XmlSeeAlso on the interface to correct the problem.  (NOTE, this will not work with manual, hand-coded JAXB).
</p>
<pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@XmlSeeAlso(RealFoo.class)
public interface IFoo {}
</pre>
<p>
The extra @XmlSeeAlso on IFoo allows RESTEasy to create a JAXBContext that knows how to unmarshal RealFoo instances.
</p>
</div>

<div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration"/>22.9. Configurating JAXB Marshalling</h2></div></div></div>
   
   <p>
     As a consumer of XML datasets, JAXB is subject to a form of attack
     known as the XXE (Xml eXternal Entity) Attack
     (<a class="ulink" href="http://www.securiteam.com/securitynews/6D0100A5PU.html">http://www.securiteam.com/securitynews/6D0100A5PU.html</a>),
     in which expanding an external entity causes an unsafe file to be loaded.  Preventing the expansion of
     external entities is discussed in <a class="xref" href="Content_Marshalling_Providers.html#Configuring_Document_Marshalling" title="21.4. Configuring Document Marshalling">第 21.4 节 “Configuring Document Marshalling”</a>.  The same
     parameter,
   </p>

   <div class="blockquote"><blockquote class="blockquote">
     resteasy.document.expand.entity.references
   </blockquote></div>

   <p>applies to JAXB unmarshallers as well.</p>


   <p>
     <a class="xref" href="Content_Marshalling_Providers.html#Configuring_Document_Marshalling" title="21.4. Configuring Document Marshalling">第 21.4 节 “Configuring Document Marshalling”</a> also discusses the prohibition of DTDs and the
     imposition of limits on entity expansion and the number of attributes per element. The parameters
   </p>

   <div class="blockquote"><blockquote class="blockquote">
     resteasy.document.secure.disableDTDs
   </blockquote></div>

   <p>and</p>

   <div class="blockquote"><blockquote class="blockquote">
     resteasy.document.secure.processing.feature
   </blockquote></div>

   <p>
     discussed there, and their default values, also apply to the representation of JAXB objects.
   </p>
</div>
</div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="Content_Marshalling_Providers.html"><strong>上一页</strong>第 21 章 Content Marshalling/Providers</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="Atom.html"><strong>下一页</strong>第 23 章 RESTEasy Atom Support</a></li></ul></body></html>